<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title> ucore lab1 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ucore lab1上来先看看Intel 80386 Programmer’s Reference Manual, 1987 (HTML)吧。http:&#x2F;&#x2F;www.logix.cz&#x2F;michal&#x2F;doc&#x2F;i386&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content=" ucore lab1">
<meta property="og:url" content="http://wjk.moe/os/ucore%20lab1/">
<meta property="og:site_name">
<meta property="og:description" content="ucore lab1上来先看看Intel 80386 Programmer’s Reference Manual, 1987 (HTML)吧。http:&#x2F;&#x2F;www.logix.cz&#x2F;michal&#x2F;doc&#x2F;i386&#x2F;">
<meta property="og:locale">
<meta property="og:image" content="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1_figs/image003.png">
<meta property="article:published_time" content="2019-09-29T05:46:25.000Z">
<meta property="article:modified_time" content="2020-10-07T16:27:32.039Z">
<meta property="article:author" content="am009">
<meta property="article:tag" content="ucore">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1_figs/image003.png">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wjk.moe"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-os/ucore lab1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/os/ucore%20lab1/" class="article-date">
  <time datetime="2019-09-29T05:46:25.000Z" itemprop="datePublished">2019-09-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS/">OS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
       ucore lab1
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ucore-lab1"><a href="#ucore-lab1" class="headerlink" title="ucore lab1"></a>ucore lab1</h1><p>上来先看看Intel 80386 Programmer’s Reference Manual, 1987 (HTML)吧。<br><a target="_blank" rel="noopener" href="http://www.logix.cz/michal/doc/i386/">http://www.logix.cz/michal/doc/i386/</a></p>
<a id="more"></a>


<h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_ref_ucore-resource.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_ref_ucore-resource.html</a></p>
</blockquote>
<p>跟我一起写makefile</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://seisman.github.io/how-to-write-makefile/functions.html">https://seisman.github.io/how-to-write-makefile/functions.html</a></p>
</blockquote>
<p>makefile这鬼东西真tm功能强，强得我什么都看不懂。原来在那个眼花缭乱的makefile里面全是各种各样的函数。。。。<br>但是实际上不需要全部读懂，稍微看看就好，这个不是重点，而且好像这个脚本比较通用。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013484370/article/details/50638353">https://blog.csdn.net/u013484370/article/details/50638353</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># add files to packet: (#files, cc[, flags, packet, dir])</span><br><span class="line">#此模板，就是真正在makefile中用来编译所有的目表文件，并生成makefile规则的模板。</span><br><span class="line">define do_add_files_to_packet</span><br><span class="line">#__temp_packet__用来记录所有的临时目标文件。</span><br><span class="line">__temp_packet__ :&#x3D; $(call packetname,$(4))</span><br><span class="line">ifeq ($$(origin $$(__temp_packet__)),undefined)</span><br><span class="line">$$(__temp_packet__) :&#x3D;</span><br><span class="line">endif</span><br><span class="line">__temp_objs__ :&#x3D; $(call toobj,$(1),$(5))</span><br><span class="line">$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(5))))</span><br><span class="line">$$(__temp_packet__) +&#x3D; $$(__temp_objs__)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<p>其他资料：</p>
<blockquote>
<p>How to make an Operating System<br><a target="_blank" rel="noopener" href="https://samypesse.gitbook.io/how-to-create-an-operating-system/chapter-3">https://samypesse.gitbook.io/how-to-create-an-operating-system/chapter-3</a><br>别人的lab1实验报告:<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2f95d38afa1d">https://www.jianshu.com/p/2f95d38afa1d</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/maruixin/p/3175894.html">https://www.cnblogs.com/maruixin/p/3175894.html</a></p>
</blockquote>
<h2 id="硬盘读取"><a href="#硬盘读取" class="headerlink" title="硬盘读取"></a>硬盘读取</h2><blockquote>
<p>《读取磁盘：LBA方式》<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mlzrq/p/10223060.html">https://www.cnblogs.com/mlzrq/p/10223060.html</a></p>
</blockquote>
<p>这个写的比那个gitbook实验指导书讲得好一点</p>
<blockquote>
<p>LBA简介<br>磁盘读取发展</p>
<p>IO操作读取硬盘的三种方式：</p>
<p>chs方式 ：小于8G (8064MB)</p>
<p>LBA28方式：小于137GB</p>
<p>LBA48方式：小于144,000,000 GB</p>
<p>LBA方式访问使用了data寄存器，LBA寄存器（总共3个），device寄存器，command寄存器来完成的。</p>
<p>LBA28和LBA48方式：<br>LBA28方式使用28位来描述一个扇区地址，最大支持128GB的硬磁盘容量。</p>
<p>LBA28的寄存器</p>
</blockquote>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>端口</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>data寄存器</td>
<td>0x1F0    已经读取或写入的数据，大小为两个字节（16位数据)</td>
<td>每次读取1个word,反复循环，直到读完所有数据</td>
</tr>
<tr>
<td>features寄存器</td>
<td>0x1F1</td>
<td>读取时的错误信息，写入时的额外参数</td>
</tr>
<tr>
<td>sector count寄存器</td>
<td>0x1F2</td>
<td>指定读取或写入的扇区数</td>
</tr>
<tr>
<td>LBA low寄存器</td>
<td>0x1F3</td>
<td>lba地址的低8位</td>
</tr>
<tr>
<td>LBA mid寄存器</td>
<td>0x1F4</td>
<td>lba地址的中8位</td>
</tr>
<tr>
<td>LBA high寄存器</td>
<td>0x1F5</td>
<td>lba地址的高8位</td>
</tr>
<tr>
<td>device寄存器</td>
<td>0x1F6</td>
<td>lba地址的前4位（占用device寄存器的低4位）<br />主盘值为0（占用device寄存器的第5位）<br />第6位值为1<br />LBA模式为1，CHS模式为0（占用device寄存器的第7位）<br />第8位值为1</td>
</tr>
<tr>
<td>command寄存器</td>
<td>0x1F7</td>
<td>读取，写入的命令，返回磁盘状态。<br />1 读取扇区:0x20 写入扇区:0x30<br />磁盘识别:0xEC</td>
</tr>
<tr>
<td>IDE通道1，读写0x1f0-0x1f7号端口</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IDE通道2，读写0x170-0x17f号端口</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>Program header描述的是一个段在文件中的位置、大小以及它被放进内存后所在的位置和大小。<br>所以bootmain中的读取elf文件，需要把每一个段都按照指定的虚拟地址和size加载好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; is this a valid ELF?</span><br><span class="line">    if (ELFHDR-&gt;e_magic !&#x3D; ELF_MAGIC) &#123;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; load each program segment (ignores ph flags)</span><br><span class="line">    ph &#x3D; (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph &#x3D; ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; call the entry point from the ELF header</span><br><span class="line">    &#x2F;&#x2F; note: does not return</span><br><span class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br></pre></td></tr></table></figure>
<p>但是为什么是ph-&gt;p_va &amp; 0xFFFFFF？<br>去掉了前面一个字节。<br>答：应该不是因为硬盘的问题，可能是内存大小的限制</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012418573/article/details/73823524">https://blog.csdn.net/u012418573/article/details/73823524</a><br>2、链接地址VS加载地址<br>（1）链接地址：是虚拟地址，代码中的绝对跳转地址和全局变量的地址都依赖于链接地址，链接地址改变时，这些地址也会改变，但相对跳转不依赖与链接地址。<br>（2）加载地址：程序被加载到的物理地址<br>（3）关系：链接地址经过地址转换要等于物理地址（加载地址）<br>（4）内核的加载地址：0x100000处，参加bootmain.c<br>（5）内核的链接地址：0xf0100000处，但是我们没有那么大的内存，故：ELFHDR-&gt;e_entry&amp;0xFFFFFF</p>
</blockquote>
<p>另外，这个问题好像不简单啊：</p>
<blockquote>
<p>ucore Lab2 调试时断点无效分析<br><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_3dce1e7b0102x6t3.html">http://blog.sina.com.cn/s/blog_3dce1e7b0102x6t3.html</a></p>
</blockquote>
<p>就是说，lab2的bootloader加载完成之后，会加载一个新的gdt段表，让地址多了一个KERNBASE(0xC0000000)。而lab1没有这个功能，就直接通过这样与一下来解决。</p>
<h2 id="实模式到保护模式的切换"><a href="#实模式到保护模式的切换" class="headerlink" title="实模式到保护模式的切换"></a>实模式到保护模式的切换</h2><p>问：16位到32位的切换是瞬间完成的吗？</p>
<p>问：发现进入实模式之后的ljmp之后，cs自动变成8<br>答：代码段寄存器（CS）的内容不能由装载指令（如MOV）直接设置，而只能被那些会改变程序执行顺序的指令（如JMP、INT、CALL）间接地设置。<br>8代表序号为1的段描述符表。进入实模式之前就要设置好段描述符表。</p>
<blockquote>
<p>下面摘自《计算机启动流程分析–以JOS为例（从BIOS到刚进入boot loader）》<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/old_memory/article/details/79572498">https://blog.csdn.net/old_memory/article/details/79572498</a></p>
</blockquote>
<p>$CR0_PE_ON是CR0设置实模式或保护模式的开关，这里打开，表明接下来的地址都是32位的虚拟地址（必须注意，这里由于是刚开始，所有的虚拟地址和物理地址等价），然而，系统是怎样真正进入32位寻址的呢？以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"> </span><br><span class="line">  .code32                     # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br></pre></td></tr></table></figure>
<p>它的作用仅仅是跳转到下一行，但是ljmp有副作用：$PROT_MODE_CSEG的值会被加载，boot.S文件开头的宏表明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br></pre></td></tr></table></figure>
<p>它的值是0x8，这个值被存入CS寄存器，它会与GDT一起影响地址翻译。</p>
<p>摘录结束，另外在文件bootblock.asm中有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">7c2d:	ea                   	.byte 0xea</span><br><span class="line">7c2e:	32 7c 08 00          	xor    0x0(%eax,%ecx,1),%bh</span><br></pre></td></tr></table></figure>
<p>这说明反汇编失败了？所以ljmp实际上是32位才有的指令吧。<br>可是为什么在gdb里面却显示<br>0x7c2d &lt;seta20+25&gt;:    ljmp   $0xb866,$0x87c32<br>只是跳转到7c32，为什么有这么多一堆东西？<br>严重怀疑在jmp之前还是十六位的代码。</p>
<p>另外这篇文章说得特别好啊，说出了内幕：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/5303304">https://blog.csdn.net/dog250/article/details/5303304</a><br>ljmp的含义是长跳，长跳主要就是重新加载寄存器，32位保护模式主要体现在段寄存器，具有可以参考段选择子和段描述符的概念，如果不用长跳的话，那么段寄存器不会重新加载，后面的取指结果仍然是老段寄存器中的值，当然保护模式不会生效了，Intel手册上有讲可见寄存器和不可见寄存器的篇章，可以看一下，其实实模式就是保护模式的一种权限全开放的特殊情况，就是说段寄存器左移相当于右边添加0，而这添加的0可以看做保护模式的RPL，RPL为0代表Intel的0环，当然是全权限了。</p>
<p>不过Intel的实模式的概念实属不得已而为之，现在的意义已经不大了，从实模式启动然后跳转到保护模式纯粹是在绕圈子，没有实质的意义，商业上为了保护以前的投资不得不将技术做的没有意义的复杂…</p>
</blockquote>
<hr>
<blockquote>
<p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14 个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。目前所谓的64TB（2^(14+32) =2^46 ）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p>
</blockquote>
<p>没想到说32位系统最多有4gb内存不是假的啊。。。换页还能换着用超出4gb的内存吗？</p>
<p>另外为什么是2^13次方？<br>因为段寄存器占用了三个比特位用来干别的。参见<br><a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_1_protection_mode.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_1_protection_mode.html</a><br>这实验指导书这次摘录得特别好啊！</p>
<hr>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>问： 如果某个段描述符要求的权限级别是3，那么我通过加载段寄存器，index选择这个描述符，但是权限级是0，那这样不就让当前权限变成0了？<br>答：对应的段因为权限是三，本来就没有对权限做限制。所以访问起来并没有什么区别。<br>但是如果再切换的话就会造成影响，使得能够切换到ring0的数据段。<br>难道是真正切换时，权限级不由自己加载的段寄存器的值确定，而是由选择出来的段描述符的权限级确定？</p>
<p>特权级和特权级转移<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/377f473dd0a9">https://www.jianshu.com/p/377f473dd0a9</a></p>
<p>这段描述符的结构很重要。<br><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1_figs/image003.png"></p>
<ul>
<li>段基地址：规定线性地址空间中段的起始地址。在80386保护模式下，段基地址长32位。因为基地址长度与寻址地址的长度相同，所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不象实方式下规定的边界必须被16整除。</li>
<li>段界限：规定段的大小。在80386保护模式下，段界限用20位表示，而且段界限可以是以字节为单位或以4K字节为单位。</li>
<li>段属性：确定段的各种性质。:<ul>
<li>段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。</li>
<li>类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。</li>
<li>描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。</li>
<li>段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。图5-4显示了当存在位为0时，描述符的格式。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。</li>
<li>已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.logix.cz/michal/doc/i386/chp06-03.htm#06-03-01">http://www.logix.cz/michal/doc/i386/chp06-03.htm#06-03-01</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Figure 6-1. Protection Fields of Segment Descriptors</span><br><span class="line">                           DATA SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+---------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     |  TYPE   |#################|</span><br><span class="line"> |###BASE 31..24###|G|B|0|V| 19..16  |P| DPL |         |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     |1|0|E|W|A|#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-+-+-+-+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|        SEGMENT LIMIT 15..0        | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                        EXECUTABLE SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+---------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     |  TYPE   |#################|</span><br><span class="line"> |###BASE 31..24###|G|D|0|V| 19..16  |P| DPL |         |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     |1|0|C|R|A|#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-+-+-+-+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|        SEGMENT LIMIT 15..0        | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                         SYSTEM SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+-+-------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     | |       |#################|</span><br><span class="line"> |###BASE 31..24###|G|X|0|V| 19..16  |P| DPL |0| TYPE  |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     | |       |#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-------+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|       SEGMENT LIMIT 15..0         | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line">        A   - ACCESSED                              E   - EXPAND-DOWN</span><br><span class="line">        AVL - AVAILABLE FOR PROGRAMMERS USE         G   - GRANULARITY</span><br><span class="line">        B   - BIG                                   P   - SEGMENT PRESENT</span><br><span class="line">        C   - CONFORMING                            R   - READABLE</span><br><span class="line">        D   - DEFAULT                               W   - WRITABLE</span><br><span class="line">        DPL - DESCRIPTOR PRIVILEGE LEVEL</span><br><span class="line"></span><br><span class="line">Table 6-1. System and Gate Descriptor Types</span><br><span class="line">Code      Type of Segment or Gate</span><br><span class="line"></span><br><span class="line">  0       -reserved</span><br><span class="line">  1       Available 286 TSS</span><br><span class="line">  2       LDT</span><br><span class="line">  3       Busy 286 TSS</span><br><span class="line">  4       Call Gate</span><br><span class="line">  5       Task Gate</span><br><span class="line">  6       286 Interrupt Gate</span><br><span class="line">  7       286 Trap Gate</span><br><span class="line">  8       -reserved</span><br><span class="line">  9       Available 386 TSS</span><br><span class="line">  A       -reserved</span><br><span class="line">  B       Busy 386 TSS</span><br><span class="line">  C       386 Call Gate</span><br><span class="line">  D       -reserved</span><br><span class="line">  E       386 Interrupt Gate</span><br><span class="line">  F       386 Trap Gate</span><br></pre></td></tr></table></figure>



<h2 id="IDT的结构"><a href="#IDT的结构" class="headerlink" title="IDT的结构"></a>IDT的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Figure 9-1. IDT Register and Table</span><br><span class="line">                                              INTERRUPT DESCRIPTOR TABLE</span><br><span class="line">                                              +------+-----+-----+------+</span><br><span class="line">                                        +----&gt;|      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #N -|</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     +------+-----+-----+------+</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     +------+-----+-----+------+</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #2 -|</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     |------+-----+-----+------|</span><br><span class="line">            IDT REGISTER                |     |      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #1 -|</span><br><span class="line">                    15            0     |     |      |     |     |      |</span><br><span class="line">                   +---------------+    |     |------+-----+-----+------|</span><br><span class="line">                   |   IDT LIMIT   |----+     |      |     |     |      |</span><br><span class="line">  +----------------+---------------|          |- GATE FOR INTERRUPT #0 -|</span><br><span class="line">  |            IDT BASE            |---------&gt;|      |     |     |      |</span><br><span class="line">  +--------------------------------+          +------+-----+-----+------+</span><br><span class="line">   31                             0</span><br></pre></td></tr></table></figure>
<p>这里的idt limit是idt的长度减1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Figure 9-3. 80306 IDT Gate Descriptors</span><br><span class="line">                                80386 TASK GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----------------+</span><br><span class="line">  |#############(NOT USED)############| P |DPL|0 0 1 0 1|###(NOT USED)####|4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----------------|</span><br><span class="line">  |             SELECTOR              |#############(NOT USED)############|0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                                80386 INTERRUPT GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----+-----------+</span><br><span class="line">  |           OFFSET 31..16           | P |DPL|0 1 1 1 0|0 0 0|(NOT USED) |4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----+-----------|</span><br><span class="line">  |             SELECTOR              |           OFFSET 15..0            |0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                                80386 TRAP GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----+-----------+</span><br><span class="line">  |          OFFSET 31..16            | P |DPL|0 1 1 1 1|0 0 0|(NOT USED) |4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----+-----------|</span><br><span class="line">  |             SELECTOR              |           OFFSET 15..0            |0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br></pre></td></tr></table></figure>
<p>关于 Segment Present</p>
<blockquote>
<p>Segment-Present bit: If this bit is zero, the descriptor is not valid for use in address transformation; the processor will signal an exception when a selector for the descriptor is loaded into a segment register. Figure 5-4 shows the format of a descriptor when the present-bit is zero. The operating system is free to use the locations marked AVAILABLE. Operating systems that implement segment-based virtual memory clear the present bit in either of these cases:</p>
<p>When the linear space spanned by the segment is not mapped by the paging mechanism.<br>When the segment is not present in memory.</p>
</blockquote>
<h2 id="TSS-（Task-Status-Segment）"><a href="#TSS-（Task-Status-Segment）" class="headerlink" title="TSS （Task Status Segment）"></a>TSS （Task Status Segment）</h2><p>没想到在看似平常的GDT下面，居然出现了一个全新的没见过的概念。。。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yasmi/articles/5198138.html">https://www.cnblogs.com/yasmi/articles/5198138.html</a></p>
<p>首先GDT里有TSS Descriptor，用来保存当前指令地址。<br>另外，在IDT里有Task Gate Discriptor，相当于是TSS的一个指针，不过在权限上可以单独设置<br>Task Gate Discriptor在LDT里居然也有！<br><a target="_blank" rel="noopener" href="http://www.logix.cz/michal/doc/i386/chp07-04.htm">http://www.logix.cz/michal/doc/i386/chp07-04.htm</a></p>
<ol>
<li>加载task register<br>ltr 指令使用提供的 selector 在 GDT / LDT 里索引查找到 TSS descriptor 后，加载到 TR 寄存器里。初始的 TSS descriptor 必须设为 available 状态，否则不能加载到 TR。processor 加载 TSS descriptor 后，将 TSS descriptor 置为 busy 状态。</li>
<li>任务切换<br>当前进程要切换另一个进程时，可以使用 2 种 selector 进行：使用 TSS selector 以及 Task gate selector（任务门符）。<br>当前进程的执行环境被保存在当前进程的 TSS segment 中。<br>发生了 TSS selector 切换。新的 TSS selector 被加载到 TR.selector，而新的 TSS descriptor 也被加载到 TR 寄存的隐藏部分。<br>processor 从当前的 TSS segment 取出新进程的执行环境。经过相关的 selector &amp; descriptor  的常规检查以及权限检查。通过之后才真正加载。<br>将新进程的 TSS descriptor 置为 busy 状态。使得新进程不能重入。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.xuebuyuan.com/737019.html">https://www.xuebuyuan.com/737019.html</a><br>我们可以看到，只有用CALL指令+调用门方式跳转，且目标代码段是非一致代码段时，才会引起CPL的变化，即引起代码执行特权级的跃迁，这是目前得知的改变执行特权级的唯一办法</p>
</blockquote>
<p>mark 关于push esp pop esp<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/particleHorizon/article/details/78722683">https://blog.csdn.net/particleHorizon/article/details/78722683</a></p>
<h2 id="中断门调用过程"><a href="#中断门调用过程" class="headerlink" title="中断门调用过程"></a>中断门调用过程</h2><p>最早设置好idt表，通过汇编指令lidt。里面保存了表的大小和起始地址，地址指向的表的每一项都有地址，段寄存器，特权级这三个属性。特权级限制了访问，而地址加上段寄存器的组合就指向了中断服务程序。<br>于是当发生中断的时候，cpu就会找到指定的地址调用。<br>调用前，会依次把一些重要的寄存器压栈。<br>(特权级切换时还有的ss, esp)eflags, cs, eip, error code。<br>然后就像call调用一样，跳转到指定的地方继续运行。<br>这里，一般的操作系统会继续保存上下文，以方便恢复一切结束中断。被打断的有当前的各种寄存器，还有栈。结束的时候就恢复自己保存的栈和寄存器再iret就可以了。<br>当不切换栈的时候是直接保存在当前栈上，反正之后会回来清理，中断的时候cpu忙，旧的栈也没有人来用。<br>切换栈的时候，系统是会从tss段取出esp吗？保存的栈帧是在系统栈还是在用户栈？？</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chaozhu/p/6283495.html">https://www.cnblogs.com/chaozhu/p/6283495.html</a></p>
<ol>
<li>在发生中断、异常时前，程序运行在用户态，ESP指向的是Interrupted Procedure’s Stack，即用户栈。</li>
<li>运行下一条指令前，检测到中断（x86不会在指令执行没有指向完期间响应中断）。从TSS中取出esp0字段（esp0代表的是内核栈指针，特权级0）赋给ESP，所以此时ESP指向了Handler’s Stack，即内核栈。</li>
<li>cpu控制单元将用户堆栈指针（TSS中的ss，sp字段，这代表的是用户栈指针）压入栈，ESP已经指向内核栈，所以入栈指的的是入内核栈。</li>
<li>cpu控制单元依次压入EFLAGS、CS、EIP、Error Code（如果有的话）。此时内核栈指针ESP位置见图4中的ESP After Transfer to Handler。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.xuebuyuan.com/915513.html">https://www.xuebuyuan.com/915513.html</a><br>也是讲堆栈切换的</p>
<p>为什么当前的tss保存的是内核的东西？虽然这和TSS的用法不符，但是应该没错吧。<br>为什么垃圾intel 80386 程序员手册没有在中断一节说清楚？是我瞎吗</p>
<p>那么当一个os初始化完成之后，它第一个用户态程序是怎么切换权限级的？直接加载一个更低的权限？<br>当系统解析ELF文件的时候，就要安排好各种数据，分段（有页吗？）设置好权限（读写执行）和权限级。然后跳转过去吗？这样不就直接转换</p>
<h2 id="8295A和8253-timer"><a href="#8295A和8253-timer" class="headerlink" title="8295A和8253 timer"></a>8295A和8253 timer</h2><p>详解8259A<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/longintchar/article/details/79439466">https://blog.csdn.net/longintchar/article/details/79439466</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/8253%E8%8A%AF%E7%89%87/3699917">https://baike.baidu.com/item/8253%E8%8A%AF%E7%89%87/3699917</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wjk.moe/os/ucore%20lab1/" data-id="ckfy5cz4n0015jsvp5m9de3co" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/os/ucore%20lab2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
           ucore lab2
        
      </div>
    </a>
  
  
    <a href="/%E6%A0%91%E8%8E%93%E6%B4%BEresbian/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"> 树莓派resbian</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E5%AD%A6/">大学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspberrypi/" rel="tag">raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspbian/" rel="tag">raspbian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CTF/" style="font-size: 20px;">CTF</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/raspberrypi/" style="font-size: 10px;">raspberrypi</a> <a href="/tags/raspbian/" style="font-size: 10px;">raspbian</a> <a href="/tags/ucore/" style="font-size: 20px;">ucore</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 10px;">开发</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/os/rcore%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"> rcore学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/unlink/"> unlink</a>
          </li>
        
          <li>
            <a href="/2019/HG6201m%E5%85%89%E7%8C%AB%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"> 烽火HG6201M交叉编译transmission成功!!</a>
          </li>
        
          <li>
            <a href="/%E4%B8%80%E5%8F%A5%E8%AF%9D/"> 一句话博客</a>
          </li>
        
          <li>
            <a href="/windows%E6%9D%83%E9%99%90/"> windows 权限提升与监控</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 am009<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>