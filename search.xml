<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title> COM与RPC</title>
    <url>/COM%E4%B8%8ERPC/</url>
    <content><![CDATA[<h1 id="COM与RPC"><a href="#COM与RPC" class="headerlink" title="COM与RPC"></a>COM与RPC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>COM，组件对象模型，它解决的问题是二进制间兼容性问题，并在此基础上实现了RPC。</p>
<p>主要学习资料： <a href="https://zhuanlan.zhihu.com/c_1234485736897552384">COM编程攻略</a></p>
<p>它的兼容思想是通过只暴露接口，不得出现跨边界的编译器相关行为，从而实现二进制的兼容。即不依赖结构体的布局，不依赖类型转换和new、delete的实现。</p>
<p>AddRef()：返回之后的引用计数。</p>
<p>Release()：一旦引用计数为0，实现者必须要释放此对象。</p>
<p>QueryInterface()</p>
<h2 id="接口转换的实现原则"><a href="#接口转换的实现原则" class="headerlink" title="接口转换的实现原则"></a>接口转换的实现原则</h2><p><code>HRESULT QueryInterface(REFIID iid, void** ppvObject);</code> </p>
<p>1、如果可以成功拿出接口，返回S_OK。如果ppvObject为空，返回E_POINTER。如果不能拿出接口，那么返回E_NOINTERFACE。</p>
<p>2、QueryInterface(下面简称QI)是静态的，不是动态的。这说明，一个对象QI能否成功，和时间没有关系。如果某个特定的类的实例QI(A)-&gt;B（执行QueryInterface拿到B），那么任何时候都应该能拿到B。</p>
<p>3、QI是自反的（如果QI(A)-&gt;B，那么QI(B)-&gt;A。</p>
<p>4、QI是对称的。</p>
<p>5、QI是可传递的。</p>
<p>6、如果需要取的是IUnknown(IID_IUnknown)，那么必须要返回相同的指针。</p>
<h2 id="IUnknown-继承模型-聚合模型"><a href="#IUnknown-继承模型-聚合模型" class="headerlink" title="IUnknown 继承模型 聚合模型"></a>IUnknown 继承模型 聚合模型</h2><p>继承模型：一个接口继承IUnknown，要用的时候转换成自己。</p>
<p>聚合模型：实现IUnknown的是套壳接口，QI的时候返回不同的接口。</p>
<p>结合聚合模型的特点和接口转换的实现原则，进行推理：用不同的地址代表不同接口的具体实现：</p>
<ol>
<li>根据自反性，必须能够一次任意转换。因此所有的聚合在同一个套壳接口的类型调用QI的时候必须调用套壳接口的QI。</li>
<li>根据</li>
</ol>
<h2 id="ATL实现的三层模型"><a href="#ATL实现的三层模型" class="headerlink" title="ATL实现的三层模型"></a>ATL实现的三层模型</h2><p><code>Wrapper -&gt; YourClass -&gt; Internal</code> </p>
<p><img src="COM%E4%B8%8ERPC/COM.jpg" alt="COM"></p>
<p><code>CComObject</code> 对应继承模型，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Base</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CComObject</span> :</span> </span><br><span class="line">	<span class="keyword">public</span> Base</span><br></pre></td></tr></table></figure>

<p><code>CComAggObject</code> 则对应的是聚合模型，不再直接继承。</p>
<p>YourClass需要继承internal和各种需要的interface，并用宏指明转换规则。从而创建<code>_QueryInterface</code> 函数和静态与 <code>_GetEntries</code> 的Entries。由 <code>InternalQueryInterface</code> 来调用API遍历这个表。YourClass不只是一个分发器，而是把接口的实现都作为自己的成员函数。</p>
<p>Interface是带有很多虚函数的基类罢了。虚函数是父类声明时，用来告知编译器，希望即使把子类作为父类，调用同名方法的时候要调用子类的方法。</p>
<ol>
<li>调用QI（wrapper的）会调用到内部的YourClass分发器的QI。</li>
<li>成功分发，转换类型后，再调用QI得调用回Wrapper的QI。</li>
</ol>
<p><code>CComObjectRootBase</code> 类型自身就有m_pOuterUnknown成员，和<code>OuterAddRef</code> 、 <code>OuterRelease</code> 函数，用来对聚合模型实现支持。它的QI就是总的QI，之后转换出去的COM接口都要调用回来这里的QI。</p>
<p>其实是COM手动实现了对与Interface类型的转换？YourClass注册Interface的时候，通过一个方法的静态数组成员来记录每个IID和对应的指针相对于this的偏移，转换的时候用到。但实际上，外围的CComAggObject持有的是通过模板生成的CComContainedObject。它通过模板继承上面写的类，重写了QueryInterface。通过CComAggObject拿到的都是继承自己的类之后的CComContainedObject了，此时构建的时候传入了原来的IUnokown的指针，通过继承和重新实现QI，把QI导向到了总的QI。导向方法是转调OuterQueryInterface，它调用了CComObjectRootBase的m_pOuterUnknown-&gt;QueryInterface</p>
<p>由于拿到的总是被<code>CComContainedObject </code> 包围的QI，这里是调用<code>CComContainedObject </code> 的QI。此时则调用的之前保存的OuterUnknown的QI。</p>
<p>QI，的时候，是把</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ol>
<li><p>首先vs2019选ATL项目模板，创建ATLMessageBox项目，选择服务exe</p>
<p>此时的解决方案里面有ATLMessgaeBox和ATLMessageBoxPS项目，后者是ProxyStub代理桩，给享受服务的客户端用的，客户端调用对应服务的时候由它来处理序列化，通讯等事情。</p>
</li>
<li><p><strong>uuidgen /i /ohello.idl</strong> 创建带有UUID的IDL文件</p>
</li>
<li><p>IDL 文件描述接口，填写创建</p>
</li>
<li><p>rgs注册表消息，填写创建</p>
</li>
<li><p>创建MessageBox.cpp MessageBox.h</p>
</li>
<li><p>注册：C:\Users\warren\source\repos\ATLMessageBox\x64\Debug\ATLMessageBox.exe /RegServer</p>
</li>
</ol>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page">Remote Procedure Call</a> </p>
<p>主要分析的是 <a href="https://github.com/microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/netds/rpc/hello/Hellop.c">这个微软的例子RPCHello</a> </p>
<p>TODO rpc的跨平台，是否支持linux或者Unix / Apple</p>
<p>RPC的环境内置在windows中，而RPC的开发环境在windows sdk中。</p>
<p>Microsoft Interface Definition Language MIDL，用来描述调用的接口。</p>
<p>客户端程序调用的服务端的函数，实际上不是真正的实现函数，而是一个stub函数，负责把参数转换成标准的NDR格式，通过网络传输请求。</p>
<p>服务器的运行时函数接受请求，转换参数，最后再调用服务端的stub函数，返回值数据的时候也是类似的方法传输回去。</p>
<p>RPC有如下组件：MIDL编译器，运行时的lib和头文件，Name service provider和Endpoint mapper。还有uuidgen工具。</p>
<p>承载RPC的dll有通过命名管道的、tcp/ip、NetBIOS、SPX、IPX、UDP的等等。</p>
<p>开发的过程包括：开发接口-&gt;开发服务端-&gt;开发客户端。</p>
<p>接口的定义主要包括的是IDL文件和ACF文件。编写后用MIDL编译器得到服务端和客户端的stub。VS1029中idl文件属于源文件，而acf文件属于资源文件。编译时的选项在项目的属性中多出来的MIDL项里面配置。</p>
<ul>
<li><p>Hello_c.c 客户端stub</p>
</li>
<li><p>Hello.h 两边都包括的头文件</p>
</li>
<li><p>Hello_s.c 服务端的stub</p>
</li>
</ul>
<p>Hellop.c 这个文件不是生成的，（example里面的）包含对server的procedure的实现。</p>
<p>Hellos.c和Helloc.c里面就是真正的RPC代码了。这一块才是重点关注的部分。</p>
<h3 id="MIDL"><a href="#MIDL" class="headerlink" title="MIDL"></a>MIDL</h3><p>服务端和客户端代码容易混在一起，在同一个项目里建立两个文件夹。</p>
<p>默认情况下，客户端和服务端的stub函数名字相同，导致不能同时链接服务端和客户端的stub，编译的时候加上 <code>/prefix</code> 参数可以避免这种情况。</p>
<p>如果编译的时候不加上 <a href="https://docs.microsoft.com/en-us/windows/win32/midl/-osf"><code>/osf</code></a> (Open Software Foundation compatibility mode)，就需要提供一个函数分配和回收内存。开启这个模式会失去很多功能特性。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>API调用序列大致如下</p>
<p>RpcServerUseProtseqEp</p>
<p>RpcServerRegisterAuthInfo (增加安全机制)</p>
<p>RpcServerRegisterIfEx</p>
<p>RpcServerListen</p>
<p>RpcMgmtWaitServerListen 循环等待</p>
<p>RpcMgmtStopServerListening</p>
<p>RpcServerUnregisterIf</p>
<p>applications must specify a string that represents a combination of </p>
<ol>
<li><p>an RPC protocol, </p>
<ol>
<li>Network Computing Architecture connection-oriented protocol (NCACN)</li>
<li>Network Computing Architecture datagram protocol (NCADG)</li>
<li>Network Computing Architecture local remote procedure call (NCALRPC) </li>
</ol>
<p>一般都选这个NCALRPC ？</p>
</li>
<li><p>a transport protocol and a network protocol. TCP/IP. IPX/SPX, NetBIOS, AppleTalk DSP什么的。肯定选tcp/ip </p>
</li>
</ol>
<p><strong>ncalrpc</strong> for local communications and <strong>ncacn_ip_tcp</strong> or <strong>ncacn_http</strong> for remote communications are recommended</p>
<p>选好了就可以通过the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose"><strong>RpcStringBindingCompose</strong></a> and <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding"><strong>RpcBindingFromStringBinding</strong></a> functions创建binding的handle了。</p>
<p>另外需要实现 the <a href="https://docs.microsoft.com/en-us/windows/desktop/Rpc/the-midl-user-allocate-function"><strong>midl_user_allocate</strong></a> and <a href="https://docs.microsoft.com/en-us/windows/desktop/Rpc/the-midl-user-free-function"><strong>midl_user_free</strong></a> 这两个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __RPC_FAR * __RPC_USER <span class="title">midl_user_allocate</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">malloc</span>(len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __RPC_USER <span class="title">midl_user_free</span><span class="params">(<span class="keyword">void</span> __RPC_FAR * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>源文件添加上生成的 _c.c后缀的文件。此外要加上任何可能需要的lib文件</p>
<p>API调用序列如下</p>
<p>RpcStringBindingCompose</p>
<p>RpcBindingFromStringBinding</p>
<p>RpcBindingSetAuthInfoEx (增加安全机制)</p>
<p>HelloProc</p>
<p>RpcStringFree</p>
<p>RpcBindingFree</p>
<h4 id="spn"><a href="#spn" class="headerlink" title="spn"></a>spn</h4><p><em>Service Principal Name</em> is a concept from Kerberos</p>
<p>实现安全机制的时候用的，所以目前可以暂时不管。</p>
]]></content>
  </entry>
  <entry>
    <title> 堆复习</title>
    <url>/heap/</url>
    <content><![CDATA[<h1 id="堆复习"><a href="#堆复习" class="headerlink" title="堆复习"></a>堆复习</h1><p>64位时, 默认开启的fastbin范围(chunk总大小)是0x20 - 0x80<br>32位TODO</p>
<p>tcache是64个单向链表，最多7个节点(chunk)，chunk的大小在32bit上是8到512（8byte递增）；在64bits上是16到1024（16bytes递增）。<br>fastbin只有10个链表, 范围肯定很小, 而和smallbins有62个, 大小基本重合.</p>
<p>当某一个tcache链表满了7个，再有对应的chunk（不属于fastbin的）被free，就直接进入了unsortedbin中。<br>tcache_perthread_struct结构，一般是在heapbase+0x10（0x8）的位置。对应tcache的数目是char类型。</p>
<h2 id="堆块结构"><a href="#堆块结构" class="headerlink" title="堆块结构"></a>堆块结构</h2><p>堆块大小计算: 使用者视角, 两个指针的大小的整数倍(不包括下一个块的prevsize), 或者指针大小的奇数倍(包括下一个块的prevsize). 采用后一种说法</p>
<p>管理者视角, 每个堆块前面有size和prevsize, 其中prevsize属于前一个堆块, 当前一个堆块是空闲的时候, 会放上前一个堆块的大小. (有没有标志位?? TODO). 管理者视角来说的话, 堆块的大小为: (n * 两个指针的大小) + 指针大小(prevsize) + 指针大小(size). 也就是n+1倍的两个指针大小. size域保存的就是这种大小. 因此谈到各种bin的时候也是指包括size域的大小.</p>
<p>chunk指针一般指向prev_size域的开始处. </p>
<p>堆块siza域最低位是AMP. (32位的时候只有3bit, 但是64位的时候就有4bit没有用了. 但还是只用3bit) </p>
<p>总结NON_MAIN_ARENA块和mmapped块与其他正常块的区别. 在libc_malloc调用int_malloc返回的时候, 会检测得到的堆块是不是当前arena的. ?? TODO</p>
<p>mmapped的块指一页内存大小的整数倍的分配来的内存. 其他两个bit会被忽略, 因为它是单独的一块, 不会和其他空闲块相邻, 也不会在任何arena里. 回收的时候会直接调用munmap</p>
<h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p>malloc_state描述arena的结构体. 主线程的arena是全局变量, 其他的arena在堆上(TODO). non_main_arena 可以有多个”堆”(heap_info).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk 不在其他任何bin里 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Unsorted, small and large bins */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins 表示某个bin空 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list, 组织各个arena */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">mstate</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><p>fastbin有10个,位于fastbinsY, 单链表, 栈式后进先出, 大小是 <code>(1 * 两个指针的大小) + 2 * 指针大小</code> 到 <code>(10 * 两个指针的大小) + 2 * 指针大小</code>. 内部的堆块标记为使用中, 不前后合并</p>
<p>其他的bin都是双链表.<code>mchunkptr bins[NBINS * 2 - 2];</code>中, 两个指针是一个bin. 下标为0的bin没有被使用, 下标为1的是unsorted bin. 下标2-63的是small bin. 下标64-126的是large bin.</p>
<p>small bins 有 62个. 列表式的先进后出. 范围是16=0x10 — 504=0x1f8大小.(含header) 64位是32=0x20 - 1008=0x3f0大小</p>
<p>large bins 有63个. 前32个, 每个bin管理64大小, 后16个, 每个bin管理512字节的范围, 8个4096, 2个262144, 1个剩下的任何大小.</p>
<p>top chunk是最底下的chunk, 使用sbrk的时候扩大的就是这个chunk. 它的prev_inuse位总是在的, 因为相邻的free chunk在free的时候总会被合并.</p>
<p>last remainder chunk 上一个被分隔的chunk</p>
<h2 id="bins的循环"><a href="#bins的循环" class="headerlink" title="bins的循环"></a>bins的循环</h2><p>综述: free的bins首先放到unsorted里, malloc遍历unsorted的时候顺便整理放到各个bins里</p>
<h3 id="malloc-init-state"><a href="#malloc-init-state" class="headerlink" title="malloc_init_state"></a>malloc_init_state</h3><p>对非fastbin, 创建头节点指向尾节点的循环<br>设置mstate的flags中的FASTCHUNKS_BIT.<br>初始化top chunk为第一个unsorted bin中的chunk.</p>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>__libc_malloc获取了arena后调用该函数.<br>如果大小在fastbin中. 去fastbin中找, 没有则到下一步, 有则检查得到的块, 检查通过后返回.<br>大小在small bin的时候, 去small bin中找, 如果对应的bin为空, 则下一步. 有则从末尾取一个, 检查一下另外一个方向的链表是否正常. 然后设置内存相邻的下一个chunk的prev_inuse, 最后返回<br>大小在large bin的, 也到large bin里找. 找完后调用malloc_consolidate (如果arena有FASTCHUNKS_BIT).<br>如果都没找到就遍历unsorted bin, (只有这时候才会把chunk放到bins里面) 从尾部遍历, 遍历的时候插入large bin的时候会总是插入第二个位置.<br>当1. 申请的chunk是small bin大小. 2. 当前的chunk是last remainder. 3. 这个chunk的大小大于请求的大小, 则将这个chunk分割, 剩下的部分还放回unsorted bin.<br>还没找到的话, 如果是large bin, 就遍历每个更大的large bin, 找到小的但大于要求大小的large bin. 能分隔则分隔, 不能分隔(剩下的空间小于最小chunk大小)则不分隔返回. 分隔出来的chunk插入到unsorted bin 末尾.<br>如果是small bin, 开始考虑更大small bin的分割. 同样找到最小的但大于要求大小的chunk分隔.<br>如果都不能满足, 则使用top chunk. 剩下的成为新的top chunk<br>如果还不能满足, 调用sysmalloc用mmap分配内存.</p>
<h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>如果在fastbin 区间内, 插入人fastbin<br>再前后合并, 注意和top chunk的合并, 检查unsorted bin 并插入头节点.</p>
<h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><p>遍历每个fastbin, 前后如果有free chunk先调用unlink后合并, 放到unsorted bin 头部里面去.<br>如果是top chunk当然和top chunk 合并</p>
<h2 id="层次化描述malloc"><a href="#层次化描述malloc" class="headerlink" title="层次化描述malloc"></a>层次化描述malloc</h2><p>malloc和free这内存管理的逻辑过于复杂, 而且很多逻辑耦合比较紧密, 不好拆开分块理解. 导致了学习的难度. 这里试图采取迭代的思想, 毕竟大型项目都是从简单到复杂的迭代出来的.</p>
<h3 id="small-bin-large-bin模型"><a href="#small-bin-large-bin模型" class="headerlink" title="small bin+large bin模型"></a>small bin+large bin模型</h3><p>该模型中只有small bin和large bin. 堆块的分配, 第一阶段是精确查找. 无法在对应的bin中找到时进入第二阶段是best fit查找, 找到满足要求的最小的堆块, 分隔或者不分割得到最终的堆块.<br>free的时候也前后合并, 合并了再放到bin里.<br>该模型还包含了top chunk. free的时候如果和top chunk 相邻, 则和top chunk合并.<br>当small/large bin中任何chunk都无法满足的时候, 首先看top chunk, 然后使用mmap去满足.<br>包含了binmap的数据结构, 方便跳过空的bins. binmap中标记为空的bin一定为空, 但是标记为有的bin则不一定必须有chunk, 也可以为空.</p>
<p>(精确查找阶段对于large bin是只要求处于相同bin内还是必须相同大小?? TODO 怀疑是后者)</p>
<h3 id="sl-small-large-unsorted-bin模型"><a href="#sl-small-large-unsorted-bin模型" class="headerlink" title="sl(small large) + unsorted bin模型"></a>sl(small large) + unsorted bin模型</h3><p>该模型加入了unsorted bin. free的时候直接放入unsorted bin开头, 而malloc的时候, 在精确查找和best fit查找之间插入unsorted bin查找, 在末尾一边找一边处理unsorted bin.<br>当unsorted bin碰到大小合适的bin的时候直接返回, 否则就一直查找处理(把遍历过的chunk插入合适的small/large bin中).</p>
<p>为了使unsorted bin处理的时间更加均匀, 处理unsorted bin中的chunk最多处理MAX_ITER个.</p>
<h3 id="改进1-减少多次分割时的开销"><a href="#改进1-减少多次分割时的开销" class="headerlink" title="改进1 减少多次分割时的开销."></a>改进1 减少多次分割时的开销.</h3><p>经常会碰到小bin完全空, 分配时总是去某个large bin中分割的情况. 这种情况每次分配小块的时候都需要遍历一次很多small bin和large bin. 可以做出改进.<br>当每次有split的时候, 将剩下的chunk作为last remainder chunk单独指针保存, 并且插入unsorted bin的末尾.<br>当遍历unsorted bin的时候, 如果是小chunk(在small bin范围内), 当前指向的chunk是last remainder chunk, 并且大小大于要求的大小, 则优先分隔该chunk直接返回.</p>
<h3 id="slu-fast-bin模型"><a href="#slu-fast-bin模型" class="headerlink" title="slu + fast bin模型"></a>slu + fast bin模型</h3><p>增加10个fast bin 作为上述模型的外包层. free的时候, 如果是fast bin范围内的直接放入fast bin(因为fast bin无限容量.233 这也说明unsorted bin不会有fast bin范围的chunk?? TODO) malloc的时候的精确查找阶段先去fast bin里面找(fast bin范围内), 没有再去small/large bin里找.</p>
<p>引入 malloc_consolidate函数, 用于把fast bin中的chunk清理到small bin 中去. 引入flags中的 FASTCHUNKS_BIT 指示当前的arena有没有fast bin.</p>
<p>best fit阶段也不能满足, 找到了topchunk. 如果top chunk也不能满足要求, 就先清理掉fast bin再去mmap. 调用malloc_consolidate, 然后再去重新遍历unsorted bin, 把所有的chunk都清理了. 之后再回到这里, 发现没有fast bin的时候再通过mmap满足要求.</p>
<p>当分配large bin而精确查找阶段也满足了的时候也调用 malloc_consolidate.</p>
<h2 id="sluf-tcache模型"><a href="#sluf-tcache模型" class="headerlink" title="sluf + tcache模型"></a>sluf + tcache模型</h2><p>在fast bin之前增加tcache. (在__libc_malloc()调用_int_malloc()之前)在获取arena之前, 就先看tcache, 有则直接返回. free的时候优先放到tcache, 满了才继续放到别处.</p>
<p>tcache是很多个链表, 保存大小相同的chunk.<br>tcache是直接指向下一个的tcache_next, 而不是指向堆块头部. 直接形成链表<br>tcache_perthread_struct用于维护各个tcache内空闲堆块的数量, 和索引各个tcache.<br>第一次malloc的时候, 会malloc一块区域保存tcache_perthread_struct.</p>
<h2 id="与其他部分的关系"><a href="#与其他部分的关系" class="headerlink" title="与其他部分的关系"></a>与其他部分的关系</h2><p>glibc2.26 开始有了tcache, 并默认开启. tcache比small bin还多一点.<br>内存释放的时候, tcache没满优先放到tcache. 分配的时候, 调用malloc之前看看tcache有没有.<br>申请fastbin大小的内存的时候, 找到fastbin内如果找到, 把fastbin上其他块填入tcache中. smallbin同理.<br>处理unsorted bin的时候, 即使找到大小合适的块, 也不直接返回, 而是</p>
<h2 id="查阅的资料"><a href="#查阅的资料" class="headerlink" title="查阅的资料"></a>查阅的资料</h2><p>64位时, 默认开启的fastbin范围(chunk总大小)是0x20 - 0x80<br>32位TODO</p>
<p>tcache是64个单向链表，最多7个节点(chunk)，chunk的大小在32bit上是8到512（8byte递增）；在64bits上是16到1024（16bytes递增）。<br>fastbin只有10个链表, 范围肯定很小, 而和smallbins有62个, 大小基本重合.</p>
<p>当某一个tcache链表满了7个，再有对应的chunk（不属于fastbin的）被free，就直接进入了unsortedbin中。<br>tcache_perthread_struct结构，一般是在heapbase+0x10（0x8）的位置。对应tcache的数目是char类型。</p>
<h2 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h2><blockquote>
<p>绕过tcache使得堆块free后进入unsorted bin的方式通常有两种：</p>
</blockquote>
<blockquote>
<p>每个tcache链上默认最多包含7个块，再次free这个大小的堆块将会进入其他bin中，例如tcache_attack/libc-leak<br>默认情况下，tcache中的单链表个数是64个，64位下可容纳的最大内存块大小是1032（0x408），故只要申请一个size大于0x408的堆块，然后free即可</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title> ollvm 学习</title>
    <url>/ollvm/</url>
    <content><![CDATA[<h1 id="ollvm-学习"><a href="#ollvm-学习" class="headerlink" title="ollvm 学习"></a>ollvm 学习</h1><p>ollvm/armariris/hikari 三个一起学习.<br><a href="https://www.leadroyal.cn/?p=1072">ollvm/armariris/hikari 适配llvm10</a></p>
<p>llvm提供了很方便地操作二进制代码的api. 自己移植不一定有利于学习, 移植主要解决的是llvm版本更新的各种杂七杂八的变化, 反而那些主要的逻辑不要求理解. </p>
<p>计划: </p>
<ol>
<li>作为使用者, 使用这几个代码混淆器, 成功编译混淆代码(使用移植好到llvm10的代码)</li>
<li>作为开发者, 学习混淆的原理, 学习代码编写的思路, 熟悉llvm的api.</li>
<li>开始考虑混淆的对策</li>
</ol>
<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opt -load lib&#x2F;LLVMHello.so -help</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opt -load lib&#x2F;LLVMHello.so -hello &lt; hello.bc &gt; out.bc</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -Xclang -load -Xclang Obfuscation.dll</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -c -emit-llvm $1.c</span><br></pre></td></tr></table></figure>



<h2 id="如何编写pass"><a href="#如何编写pass" class="headerlink" title="如何编写pass"></a>如何编写pass</h2><p>要运行的代码是 <a href="https://github.com/LeadroyaL/llvm-pass-tutorial">https://github.com/LeadroyaL/llvm-pass-tutorial</a> , 这里每个项目是单独的文件夹. 三个项目合在一起, 共用外面的cmake文件. 为了明白这个移植怎么跑起来, 学习源码外的pass项目的建立. 先学下面的项目, 配置好路径.<br><a href="https://github.com/abenkhadra/llvm-pass-tutorial">pass-skeleton</a></p>
<p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">如何写一个pass llvm.org</a><br>确实, 写一个pass就真的是一个pass, 出来一个so文件, 在passmanager里过一遍llvm bytecode. pass的加载和运行暴露在命令行选项. </p>
<ol>
<li>pass项目可以单独在源码外</li>
</ol>
<p>编译的时候需要在 <code>[LLVM_DIR]</code> 找到llvm的配置. 该项目骨架会通过 <code>$LLVM_HOME</code> 环境变量设置好 <code>[LLVM_DIR]</code><br>编译出来可以使用opt直接运行pass. 也可以clang编译的时候指定opt加载这个so文件, 然后加上调用so的选项.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-7.0 -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c$</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>pass项目在llvm源码内</li>
</ol>
<p>可以像他们几个项目一样直接在llvm-project源码内的 <code>/lib/Transform</code> 修改. 并且修改默认加载这个pass, 只需要给出使用的选项.</p>
<h3 id="源码外的pass"><a href="#源码外的pass" class="headerlink" title="源码外的pass"></a>源码外的pass</h3><p><a href="http://llvm.org/docs/CMake.html#developing-llvm-passes-out-of-source">Developing LLVM passes out of source</a></p>
<p>LLVM_HOME 应该是 <code>/usr/lib/llvm-10</code>, 这样就会设置LLVM_DIR为 <code>/usr/lib/llvm-10/lib/cmake/llvm</code> LLVM_DIR里面有LLVMConfig.cmake, 设置了这个环境变量, cmake中调用 <code>find_package(LLVM REQUIRED CONFIG)</code> 就可以找到llvm作为一个cmake的library</p>
<p>为了构建源码外的pass, 重要的cmake语句有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line">project(llvm-pass-tutorial)</span><br><span class="line"></span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br><span class="line">add_subdirectory(ollvm)  # ollvm</span><br><span class="line">add_subdirectory(Hikari)  # Hikari</span><br><span class="line">add_subdirectory(Armariris)  # Armariris</span><br></pre></td></tr></table></figure>
<p>在每个文件夹内的CMakeList里调用 <code>add_library</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_library(Armariris MODULE</span><br><span class="line">        # List your source files here.</span><br><span class="line">        CryptoUtils.cpp</span><br><span class="line">        StringObfuscation.cpp</span><br><span class="line">        Substitution.cpp</span><br><span class="line">        Flattening.cpp</span><br><span class="line">        Utils.cpp</span><br><span class="line">        include&#x2F;Transforms&#x2F;Obfuscation&#x2F;Flattening.h</span><br><span class="line">        include&#x2F;Transforms&#x2F;Obfuscation&#x2F;StringObfuscation.h</span><br><span class="line">        include&#x2F;Transforms&#x2F;Obfuscation&#x2F;Substitution.h</span><br><span class="line">        include&#x2F;Transforms&#x2F;Obfuscation&#x2F;Utils.h</span><br><span class="line">        Enter.cpp</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h3 id="案例-ollvm做出的修改"><a href="#案例-ollvm做出的修改" class="headerlink" title="案例: ollvm做出的修改"></a>案例: ollvm做出的修改</h3><p>以下是ollvm4.0和llvm4.0进行对比的不同的文件. 来自<a href="https://magic-king.net/2020/02/27/ollvm-learning/">这里</a> 使用<a href="https://truehumandesign.se/s_diffinity.php">Diffinity</a>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;include&#x2F;llvm&#x2F;Transforms&#x2F;Obfuscation&#x2F; # obfuscation的头文件</span><br><span class="line">.&#x2F;include&#x2F;llvm&#x2F;Transforms&#x2F;CryptoUtils.h # obfuscation的头文件</span><br><span class="line">.&#x2F;lib&#x2F;Transforms&#x2F;IPO&#x2F;LLVMBuild.txt</span><br><span class="line">.&#x2F;lib&#x2F;Transforms&#x2F;IPO&#x2F;PassManagerBuilder.cpp # Pass注册</span><br><span class="line">.&#x2F;lib&#x2F;Transforms&#x2F;Obfuscation&#x2F; # obfuscation source code</span><br><span class="line">.&#x2F;lib&#x2F;Transforms&#x2F;CMakeLists.txt</span><br><span class="line">.&#x2F;lib&#x2F;Transforms&#x2F;LLVMBuild.txt</span><br><span class="line">.&#x2F;tools&#x2F;clang # 集成clang,要在gitignore里取消clang的注释</span><br><span class="line">.&#x2F;.gitignore</span><br><span class="line">.&#x2F;CMakeLists.txt</span><br><span class="line">.&#x2F;CODE_OWNERS.TXT</span><br><span class="line">.&#x2F;LICENSE.TXT</span><br></pre></td></tr></table></figure>

<h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>为了避免编译llvm. 我采用直接apt安装的方式安装llvm, 源码外建立pass项目.<br>好像安装了llvm-dev<br>安装后在 <code>/usr/lib/llvm-10</code> 附近有各种编译头文件</p>
<p>在<code>project(llvm-pass-tutorial)</code>之后加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(ENV&#123;LLVM_HOME&#125; &#x2F;usr&#x2F;lib&#x2F;llvm-10)</span><br></pre></td></tr></table></figure>

<h2 id="使用pass"><a href="#使用pass" class="headerlink" title="使用pass"></a>使用pass</h2><h3 id="ubuntu的pass测试"><a href="#ubuntu的pass测试" class="headerlink" title="ubuntu的pass测试"></a>ubuntu的pass测试</h3><p>为了方便地测试我的pass，我想要方便地看到结果。输入是c语言的helloworld程序，输出路过pass后的中间表示。</p>
<h2 id="visual-studio-配置使用pass"><a href="#visual-studio-配置使用pass" class="headerlink" title="visual studio 配置使用pass"></a>visual studio 配置使用pass</h2><p>经过查阅资料, 没找到, 不能android一样,<br><a href="https://stackoverflow.com/questions/48947973/use-llvm-in-a-cmake-build">重新编译才能得到cmake库</a><br>编译后将build文</p>
<p>在Windows平台编译不是一个简单的问题，需要各种支持。现在虽然难，但似乎有人成功了。</p>
<p>安装</p>
<p>了tdm-Gcc之后用如下的选项编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS&#x3D;&quot;clang&quot; -DLLVM_EXPORT_SYMBOLS_FOR_PLUGINS&#x3D;On ..\llvm</span><br></pre></td></tr></table></figure>

<p>出现报错，说</p>
<p>cant close file too big</p>
<p>改设置上一些其他的选项试试，看看能不能好一点。可能只能编译release版本的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS&#x3D;&quot;clang&quot; -DLLVM_EXPORT_SYMBOLS_FOR_PLUGINS&#x3D;On -DLLVM_INCLUDE_TESTS&#x3D;Off DLLVM_TARGETS_TO_BUILD&#x3D;&quot;X86&quot; -DCMAKE_BUILD_TYPE&#x3D;Release ..\llvm</span><br></pre></td></tr></table></figure>

<p>时间过于漫长，我把环境变量里面的clang提前了，不行的话看看能不能clang自己编译自己。</p>
<p>TODO 描述编译经历</p>
<ol>
<li>坚持使用MSVC编译，使用MSVC自带的开发控制台的x64 native tools</li>
<li>使用上面的方法后，即使用Ninja生成器，不加-hHost=x64，也能正确用上64位的toolchain好像</li>
<li>源码内pass比源码外pass更容易配</li>
</ol>
<p>现在是windows平台，in source编写pass。</p>
<h2 id="编写混淆pass"><a href="#编写混淆pass" class="headerlink" title="编写混淆pass"></a>编写混淆pass</h2><ol>
<li><p>自己编写的pass编译成dll之后是否只能通过opt运行？不能通过clang自动运行？</p>
<p><a href="https://www.cs.cornell.edu/~asampson/blog/clangpass.html">这里</a> 其实是一种挺Hack的方法，让组件加载dll/so的时候去注册，我在windows上这样加载LLVMHello.dll 会报错 <code>动态链接库(DLL)初始化例程失败。 (0x45A)</code> </p>
<p>首先写一个bat自动化进行编译成中间代码和使用pass的过程。</p>
<p>一种方法是源码内编写pass，直接修改相关代码加载pass，这种方法其实挺不容易的，我首先在clang的一些cmakelist里加入了Hello链接进去，但是似乎还是需要注册？需要继续深入了解研究看看源码，看问题4 <a href="https://medium.com/@mshockwave/writing-llvm-pass-in-2018-part-iv-d69dac57171d">内置的方法</a> </p>
<p>否则即使在源码内编写，也出来的是动态库，还是只能opt加载。。。</p>
</li>
<li><p>头文件缺失的问题怎么解决？visual studio是怎么编译的？</p>
<p>visual studio 最近有了llvm支持。而我自己编译的llvm是没有基本的C++头文件的。用微软的安装包安的clang也是一样，所以可能是手动添加了include路径？</p>
</li>
<li><p>llvm的pass是如何注册命令行选项的？怎样编译成dll，又如何不出dll而是内置到clang里？</p>
<p>想要内置考虑可以通过<a href="https://llvm.org/docs/WritingAnLLVMPass.html#building-pass-plugins">llvm plugin</a>。是否编译成dll和Transform里的自己的pass的CmakeList里的add_llvm_library 里是否加上Module参数有关系。加上就是动态链接，不加上就是静态链接出来。</p>
</li>
<li><p>Transform的那些pass是怎么加载进clang里的？</p>
<p>lib/CodeGen/CMakeList.txt</p>
<p>tools/driver/CMakeList.txt</p>
<p>这两个地方有clang会link进去的东西。</p>
<p>要去掉自己的MODULE BUILDTREE_ONLY</p>
<p>我编译进去了，但是好像不太行。。 </p>
<p>好像要在IPO的PassManagerBuilder::populateFunctionPassManager/populateModulePassManager</p>
<p> <a href="https://medium.com/@mshockwave/writing-llvm-pass-in-2018-part-iv-d69dac57171d">内置的方法</a> </p>
</li>
<li><p>bytecode转可执行文件？</p>
<p>可以直接clang编译成可执行文件 <a href="https://blog.csdn.net/pc153262603/article/details/89553688">来源</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang a.o.bc -o struct</span><br></pre></td></tr></table></figure>

<p>首先llc编译成S的汇编文件，再用gcc什么的生成可执行文件 <a href="https://stackoverflow.com/questions/32523847/how-to-make-llvm-bc-file-executable">来自</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">llc -filetype&#x3D;obj hello.bc -o hello.o</span><br><span class="line">llc hello.bc -o hello.s</span><br><span class="line">gcc hello.o&#x2F;s -o hello</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="pass的集成"><a href="#pass的集成" class="headerlink" title="pass的集成"></a>pass的集成</h2><ol>
<li><p>要有一个ID，初始值不重要，因为是根据ID的地址区别各个函数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char Hello::ID &#x3D; 0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册pass，得到一个命令行。这里是通过构造函数注册的，我们只需要初始化一个类。这种方法似乎只对opt有效？？当有这个选项的时候我们的pass才会被加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;,</span><br><span class="line">                             false &#x2F;* not modify CFG *&#x2F;,</span><br><span class="line">                             false &#x2F;* pure Analysis Pass *&#x2F;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载时自动注册，这里用的是匿名函数，我们可以写一个函数。这种方法对opt无效。对<code>clang -Xclang -load -Xclang Obfuscation.dll</code> 有效。这种注册方法有待探索。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static RegisterStandardPasses Y(</span><br><span class="line">    PassManagerBuilder::EP_EarlyAsPossible,</span><br><span class="line">    [](const PassManagerBuilder &amp;Builder,</span><br><span class="line">       legacy::PassManagerBase &amp;PM) &#123; PM.add(new Hello()); &#125;);</span><br></pre></td></tr></table></figure>

<p>TODO：研究原理。它会先调用PassManagerBuilder::addGlobalExtension，这个函数则是Transform/IPO里的，它把<code>std::make_tuple(Ty, std::move(Fn), ExtensionID)</code> 放到GlobalExtensions这个static全局Vector里面。最终是populateFunctionPassManager这里把注册的这些东西放进FPM的</p>
</li>
<li><p>命令行选项，加载后通过参数更详细地控制pass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static cl::opt&lt;int&gt;</span><br><span class="line">ObfProbRate(&quot;bcf_prob&quot;, cl::desc(&quot;Choose the probability [%] each basic blocks will be obfuscated by the -bcf pass&quot;), cl::value_desc(&quot;probability rate&quot;), cl::init(defaultObfRate), cl::Optional);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cl::opt&lt;RegisterMyPasses::FunctionPassCtor, false,</span><br><span class="line">        RegisterPassParser&lt;RegisterMyPasses&gt; &gt;</span><br><span class="line">MyPassOpt(&quot;mypass&quot;,</span><br><span class="line">          cl::init(&amp;createDefaultMyPass),</span><br><span class="line">          cl::desc(&quot;my pass option help&quot;));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="OLLVM-实现解析"><a href="#OLLVM-实现解析" class="headerlink" title="OLLVM 实现解析"></a>OLLVM 实现解析</h2><h3 id="Instruction-substitution"><a href="#Instruction-substitution" class="headerlink" title="Instruction substitution"></a>Instruction substitution</h3><p>指令替换是最简单的。对于加减与或 异或这五种运算，分别有多种替换方法，ollvm随机选一个替换。增加的命令行选项是每个函数替换多少遍。第一遍替换的是原始的指令，后面每次替换的就是混淆后的指令了，通过反复替换增加复杂度。</p>
<p>如何让自己的pass在优化后运行？ 可以考虑opt过了pass之后，编译的时候就用 -O0 ?</p>
<p>继承Funcpass的Substitution有几个函数指针数组，在初始化的时候把自己的成员函数填进去，之后通过随机数产生器随机调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123;</span><br><span class="line">  <span class="keyword">for</span> (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inst-&gt;isBinaryOp()) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (inst-&gt;getOpcode()) &#123;</span><br><span class="line">      <span class="keyword">case</span> BinaryOperator::Add:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BinaryOperator::Sub:</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>真正核心的替换函数，参数只是那个指令<code>BinaryOperator *bo</code>。</p>
<p><img src="ollvm/image-20200928135000792.png" alt="image-20200928135000792"></p>
<p>addNeg：增加一个Neg指令，把加法变成减法。addDoubleNeg同理。</p>
<p>精髓在于BinaryOperator::Create的方法的最后一个参数是InsertBefore，这样按顺序插入到那个指令前面，最后的时候再对原来的指令调用replaceAllUsesWith，用最后生成的指令去替换它就好了。意味着用最后一个指令产生的值去替换它产生的值。</p>
<p>binaryOperator成员如下，rem是取余数的运算符 <a href="https://llvm.org/docs/LangRef.html#binary-operations">多找找llvm手册</a> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Standard binary operators...</span><br><span class="line"> FIRST_BINARY_INST(13)</span><br><span class="line">HANDLE_BINARY_INST(13, Add  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(14, FAdd , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(15, Sub  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(16, FSub , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(17, Mul  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(18, FMul , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(19, UDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(20, SDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(21, FDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(22, URem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(23, SRem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(24, FRem , BinaryOperator)</span><br></pre></td></tr></table></figure>

<p>TODO 确实会留下原来被代替的指令。需要在合适的时候调用<code>bo-&gt;eraseFromParent();</code>直接调用会导致iterator出现问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; vec.erase(i); </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title> i2s学习与maixpy麦克风</title>
    <url>/i2s/</url>
    <content><![CDATA[<h1 id="i2s学习与maixpy麦克风"><a href="#i2s学习与maixpy麦克风" class="headerlink" title="i2s学习与maixpy麦克风"></a>i2s学习与maixpy麦克风</h1><p>适配麦克风中.</p>
<p><a href="https://www.allaboutcircuits.com/technical-articles/introduction-to-the-i2s-interface/">https://www.allaboutcircuits.com/technical-articles/introduction-to-the-i2s-interface/</a></p>
<p><a href="https://hackaday.com/2019/04/18/all-you-need-to-know-about-i2s/">https://hackaday.com/2019/04/18/all-you-need-to-know-about-i2s/</a></p>
<p><a href="https://www.jianshu.com/p/e4f07bcd9df4">https://www.jianshu.com/p/e4f07bcd9df4</a></p>
<p><a href="https://www.cnblogs.com/schips/p/12305649.html">https://www.cnblogs.com/schips/p/12305649.html</a></p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>SCK/BLCK/SLCK</td>
<td>clock</td>
</tr>
<tr>
<td>WS/LRCK</td>
<td>word select</td>
</tr>
<tr>
<td>SD/SDATA</td>
<td>data</td>
</tr>
<tr>
<td>NC</td>
<td>(悬空)</td>
</tr>
<tr>
<td>EN</td>
<td>片选/启用? 直接接到了3v3</td>
</tr>
<tr>
<td>LR</td>
<td>左右选择</td>
</tr>
</tbody></table>
<p>I2S就是被设计来传送音频数据的, 其他的数据都是之后的hacky玩法. 它用一条线区分左右声道, 一条时钟线同步信号, 和一条真正的线传送数据. 在我们板子的receiver=master的情况下, 时钟和WS是接收方发送给麦克风的, 发送方通过SD发送数据给接收方.</p>
<p>I2S允许两个声道的数据在一条线上传送. 因此有了左右声道的选择线. 采样的时候要交替左右轮流读一个字, 导致这个选择线的信号也类似于时钟. 麦克风的规格书里推荐的就是两个麦克风的三条I2S线相连, 一个L/R接地, 一个L/R接电源, 这样就成为了一个立体麦克风.</p>
<p>板子的L/R是接地的, 因此音频要在左声道接受, 需要给出WS为低的时候才有数据, 否则为0. 这是使用的左对齐标准, 24bit的采样数据包装在32位中. 最右边8bit固定为0. Phillips标准则在WS高的时候发送左声道数据.</p>
<p>MSB优先发送. 变化WS之后要等一个时钟周期再开始接受数据. SCLK的频率=2×采样频率×采样位数, LRCK的频率等于采样频率, 这样就刚好能完整收集左右声道的采样数据了.</p>
<p>下面这段来自麦克风的规格书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I²S DATA INTERFACE</span><br><span class="line">  The serial data is in slave mode I²S format, which has 24‐bit depth in a 32 bit word. In a stereo frame there are 64 SCK cycles, or 32 SCK cycles per data‐word. When L&#x2F;R&#x3D;0, the output data in the left channel, while L&#x2F;R&#x3D;Vdd, data in the right channel. The output data pin (SD) is tristated after the LSB is output so that another microphone can drive the common data line.</span><br><span class="line">Data Word Length</span><br><span class="line">  The output data‐word length is 24 bits per channel. The Mic must always have 64 clock cycles for every stereo data‐word (fSCK &#x3D; 64 × fWS).</span><br><span class="line">Data‐Word Format</span><br><span class="line">  The default data format is I²S, MSB‐first. In this format, the MSB of each word is delayed by one SCK cycle from the start of each half‐frame.</span><br></pre></td></tr></table></figure>

<h2 id="k210的I2S"><a href="#k210的I2S" class="headerlink" title="k210的I2S"></a>k210的I2S</h2><p>k210有3个I2S, 因此说它能接6麦克风阵列.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其中I²S0 支持可配置连接语音处理模块，实现语音增强和声源定向的功能。</span><br><span class="line">• 总线宽度可配置为8，16，和32 位</span><br><span class="line">• 每个接口最多支持4个立体声通道</span><br><span class="line">• 由于发送器和接收器的独立性，所以支持全双工通讯</span><br><span class="line">• APB 总线和I²S SCLK 的异步时钟</span><br><span class="line">• 音频数据分辨率为12,16,20,24 和32 位</span><br><span class="line">• I²S0 发送FIFO 深度为64 字节, 接收为8 字节，I²S1 和I²S2 的发送和接收FIFO 深度都为8字节</span><br><span class="line">• 支持DMA 传输</span><br><span class="line">• 可编程FIFO 阈值</span><br></pre></td></tr></table></figure>

<p>k210使用的是4通道的I2S.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[MAIXPY]: numchannels &#x3D; 2</span><br><span class="line">[MAIXPY]: samplerate &#x3D; 22050</span><br><span class="line">[MAIXPY]: byterate &#x3D; 88200</span><br><span class="line">[MAIXPY]: blockalign &#x3D; 4</span><br><span class="line">[MAIXPY]: bitspersample &#x3D; 16</span><br></pre></td></tr></table></figure>
<p>目前还是没声音, 需要学习I2S的FIFO是什么意思. 深度是什么意思, 然后就是怎么处理ws的, 为什么每个I2S有4个输入,4个输出引脚, 采样率怎么设置</p>
<p>4个输入和4个输出应该是对应4个channel, 可能方便切换吧?? 接受数据的时候, 一个每次传送数据的cycle. 每次传送的数据的bit数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>word_length/RESOLUTION</td>
<td>每个word的长度. 12/16/20/24/32选24</td>
</tr>
<tr>
<td>word_select_size/SCLK_CYCLES</td>
<td>16/24/32选32. 大概是指在WS不变化的时候的cycle数, 也就是WS周期的一半.</td>
</tr>
<tr>
<td>word_mode</td>
<td>选左对齐.</td>
</tr>
</tbody></table>
<p>有声音了, 关键是上面列举的参数选择. I2S学习先告一段落.</p>
<p>i2s_set_dma_divide_16 函数能设置让DMA的时候自动把32 比特INT32 数据分成两个16 比特的左右声道数据。 那么这32bit的数据从哪来的?</p>
<p>I2S要不要设置时钟周期??</p>
]]></content>
  </entry>
  <entry>
    <title> ov2640 摄像头模块</title>
    <url>/ov2640/</url>
    <content><![CDATA[<h1 id="ov2640-摄像头模块"><a href="#ov2640-摄像头模块" class="headerlink" title="ov2640 摄像头模块"></a>ov2640 摄像头模块</h1><p>关键在于学习如何操作寄存器<br>k210的dvp datasheet:</p>
<blockquote>
<p>3.9 数字视频接口(DVP)<br>DVP 是摄像头接口模块，特性如下：</p>
<ul>
<li>支持DVP接口的摄像头</li>
<li>支持SCCB协议配置摄像头寄存器</li>
<li>最大支持640X480 及以下分辨率，每帧大小可配置</li>
<li>支持YUV422 和RGB565 格式的图像输入</li>
<li>支持图像同时输出到KPU和显示屏:<ul>
<li>输出到KPU 的格式可选RGB888，或YUV422输入时的Y分量</li>
<li>输出到显示屏的格式为RGB565</li>
</ul>
</li>
<li>检测到一帧开始或一帧图像传输完成时可向CPU发送中断</li>
</ul>
</blockquote>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>PCLK,即像素时钟,一个PCLK时钟,输出一个(或半个)像素。</p>
<p>VSYNC,即帧同步信号。</p>
<p>HREF/ HSYNC,即行同步信号。</p>
<h2 id="颜色格式-RGB-YUV-YCbCr"><a href="#颜色格式-RGB-YUV-YCbCr" class="headerlink" title="颜色格式 RGB, YUV, YCbCr"></a>颜色格式 RGB, YUV, YCbCr</h2><h2 id="sccb"><a href="#sccb" class="headerlink" title="sccb"></a>sccb</h2><p>SCCB 特性都与 I2C 无区别, 可以直接用I2C控制器去通信</p>
<h2 id="dvp"><a href="#dvp" class="headerlink" title="dvp"></a>dvp</h2><p>各种大大小小的时钟, 最终形成了同步的信号. 一个帧同步信号的有效时间内有很多个行同步信号, 每个行同步信号的有效时间内有很多像素时钟.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>SVGA: 800 x 600<br>摄像头也可以配置缩放. 没写怎么配置的缩放的.</p>
<h2 id="图形翻转"><a href="#图形翻转" class="headerlink" title="图形翻转"></a>图形翻转</h2><p>0xFF=1的时候, 04寄存器最高两位分别是水平镜像和垂直翻转.<br>widora的ov2640例程中, 注释了airv r3 back的地方是 d8 也就是这两位都有.<br>maixpy则是只有水平镜像(0xa8). 在去掉水平镜像之后, 也就是两个bit都不设置的时候(0x28), 后置摄像头显示刚好正常.<br>(怀疑是)两边lcd的方向设置不一致, maixpy暂时调整摄像头这边.</p>
<h2 id="代码对比阅读"><a href="#代码对比阅读" class="headerlink" title="代码对比阅读"></a>代码对比阅读</h2><p>linux的ov2640代码可能是发源地, 也是最完善的吧. 接着是openmv的代码, 比maixpy的整齐很多, 不乱. 接着就是kendryte的代码, 也许是参照openmv的,对比一下widora的例程. 最后是maixpy的代码.</p>
<h2 id="widora对比kentryte"><a href="#widora对比kentryte" class="headerlink" title="widora对比kentryte"></a>widora对比kentryte</h2><p>代码的对比最好先format后diff. 这样即使widora他们声明数组是好几个一行, 也能迅速展平方便对比</p>
<p>经过对比发现, 除了多设置了一个翻转bit之外, 只有这两个不同.<br>官方是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;0x5a, 0xc8&#125;,</span><br><span class="line">&#123;0x5b, 0x96&#125;,</span><br></pre></td></tr></table></figure>
<p>widora是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;0x5a, 0x50&#125;,</span><br><span class="line">&#123;0x5b, 0x3C&#125;,</span><br></pre></td></tr></table></figure>
<p>搜索ov2640和zmow, 找到了Android的相关驱动代码!!! Android它们相关驱动可能比linux还完善.</p>
<p>#define ZMOW        0x5A /* Zoom: Out Width  OUTW[7:0] (real/4) <em>/<br>#define   ZMOW_OUTW_SET(x)      VAL_SET(x, 0xFF, 2, 0)<br>#define ZMOH        0x5B /</em> Zoom: Out Height OUTH[7:0] (real/4) */</p>
<p>这样看的话, widora是: 320*240分辨率. 官方是800*600, 修改这里确实说得过去, 不过也不注释一下…</p>
<p>没想到这样的例程都用到了ai加速器?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置允许导流到AI模型</span></span><br><span class="line">dvp_set_output_enable(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">//enable to ai</span></span><br><span class="line"><span class="comment">// DVP不直接导流到LCD</span></span><br><span class="line">dvp_set_output_enable(<span class="number">1</span>, <span class="number">1</span>);    <span class="comment">//disable to lcd</span></span><br></pre></td></tr></table></figure>
<p>dvp_set_ai_addr设置AI 存放图像的地址，供AI 模块进行算法处理。<br>void dvp_set_ai_addr(uint32_tr_addr, uint32_tg_addr, uint32_tb_addr)设置采集图像在内存中的存放地址，可以用来显示。<br>dvp_clear_interrupt(DVP_STS_FRAME_START | DVP_STS_FRAME_FINISH); 一般表示当前的这种中断处理完了, 可以来新的中断了. 算是是中断的pending位?.<br>dvp_config_interrupt(DVP_CFG_START_INT_ENABLE | DVP_CFG_FINISH_INT_ENABLE, 1); 打开中断开关<br>dvp_start_convert() 在开始采集图像的时候调用 表示开始采集图像<br>dvp_disable_auto() 禁用自动接收图像模式。</p>
<p>总结起来, 就是开启dvp中断. k210的dvp会提供开始采集和停止采集的两种中断. 开始采集的时候, 在中断处理中调用start_convert. 结束采集的时候, 设置标志位. 当中断退出的时候, 忙等的处理器就会注意到标志位, 清零并设置切换buffer的标志, 向屏幕发送数据. 另外就是中断处理的时候根据buffer标志设置buffer.<br>根据需要切换buffer是在结束采集的时候?? 不应该啊, 切换buffer不是为了让采集和输出不在同一个buffer吗.</p>
<p>根据LCD的需求来切换dvp数据放到哪个缓存，目的是保证把图像传给LCD的时候, dvp不是正好输出到这个buf。</p>
<p>buf大小上, ai为什么要给三个RGB的buf? 我修改了zoom出来的大小是否相关的buf大小也需要变化?<br>查看发现widora和官方的main函数一直, buf大小相同.<br>RGB565是2字节一个像素. 这里是320*240*2 = 38400个uint32 (widora的dvp buffer大小.)<br>而AI的buffer大小是3*12c00 = 38400 这是怎么回事? RGB怎么可能均分呢? 这可是RGB565.</p>
<p>set_framesize在设置QVGA的时候不仅设置了dvp_set_image_size, 也设置了摄像头那边的zoom寄存器.</p>
<h2 id="ov2640-帧率"><a href="#ov2640-帧率" class="headerlink" title="ov2640 帧率"></a>ov2640 帧率</h2><p>分析software application notes的帧率设置案例.<br>下面的寄存器都在0xff=1的情况下<br>首先是0x11寄存器, 最低4位为clock dividor. 寄存器的值高帧率的时候为0, 低的时候为1, 可能divide了就帧率减半吗?<br>0x12寄存器的(低到高)第三位, zoom mode. svga的时候设为1, uxga的时候为0<br>0x2a寄存器, 大家都设置为0 line interval adjust value的高四位, Hsync start/end point adjustment MSB. 0x2b也为0, line interval adjust value的低8位. 帧率会被这个12bit的值微调.<br>0x46为低位, 0x47为高位, 组成了frame length adjustment. 这个值每多1, 就在帧中增加了1个水平线的时间. 0x47大家也都设置为0. 这个值是调整帧率的关键.<br>0x3d寄存器很神秘, 在手册的保留寄存器的范围内. svga设置为了0x38, uxga设置成了0x34</p>
<p>SVGA 800×600来看的话, 高度是600. frame length adjustment为0时的刷新率是30fps. 而增加了clock dividor, 帧率减半得到15fps. 如果只frame length adjustment设置为了0x87=135, 那么帧率就乘上了缩放倍数(600/600+135), 得到25fps.</p>
<p>总之关键在于寄存器0x11和寄存器0x46 0x47. </p>
<table>
<thead>
<tr>
<th>type</th>
<th>clock dividor</th>
<th>frame length adjustment</th>
</tr>
</thead>
<tbody><tr>
<td>widora/kendryte</td>
<td>0</td>
<td>0x22</td>
</tr>
<tr>
<td>maixpy</td>
<td>0</td>
<td>0x22</td>
</tr>
</tbody></table>
<p>当前maixpy的帧率, 30fps * (600/600+34) = 28.4帧… 为什么是这种奇怪的帧数? 难道是我哪里理解错了? 或者为了凑什么倍数??</p>
<h2 id="ov2460-颜色"><a href="#ov2460-颜色" class="headerlink" title="ov2460 颜色"></a>ov2460 颜色</h2><p>0xff=<br>CTRL0 = 0xC2寄存器 最低四位由低到高依次为RAW_EN, RGB_EN, YUV_EN, YUV422. 默认和maixpy的配置都是0x0C=1100<br>0xDA寄存器的名字是IMAGE_MODE, bit0 byte swap for DVP(low/high byte first), bit[3:2] 00-&gt;yuv422, 01-&gt;raw10, 10-&gt; RGB565, 11-&gt;Reserved<br>kendryte是0x08, 也就是RGB565, maixpy是0x01, 也就是YUV422+byte swap</p>
<p>这边寄存器的设置要和那边dvp的接收设置匹配起来. 而调用picformat只是设置dvp的接收的格式. </p>
<h2 id="maixpy和openmv的代码解析"><a href="#maixpy和openmv的代码解析" class="headerlink" title="maixpy和openmv的代码解析"></a>maixpy和openmv的代码解析</h2><p>openmv的代码更大型一些, 功能更多. 对摄像头相关的寄存器使用得更灵活. 前面的配置一般还是svga, 但是最后zoom出来分辨率不会那么大.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sensor    </span><br><span class="line">import lcd</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.run(1)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    img &#x3D; sensor.snapshot()</span><br><span class="line">    lcd.display(img)</span><br></pre></td></tr></table></figure>
<p>先在这个典型的例程里, 依次分析一下各个函数.<br>代码结构依次是py_sensor.c -&gt; sensor.c -&gt; ov2460.c<br>首先是探测过程, 读取厂家和型号id. ov2460_init函数会填写sensor结构体, 暴露出内部函数.<br>设置frame_size的时候, 也会设置摄像头的zoom相关寄存器.<br>set_pixformat似乎没有用了, 而且似乎是yuv. 设置成其他的格式会花屏. 也许是方便直接输入模型吧.<br>set_framerate也无法设置, ov2460.c中直接返回-1了.</p>
<p>sensor和lcd没有直接的关联或者相互调用, snapshot函数则是传过去的关键.<br>snapshot函数甚至还对buf做了什么jpeg压缩处理, 考虑了连接ide的情况.</p>
<p>超时不一定是摄像头配置问题. 也可能是中断处理问题. 试了下去掉双buf选项编译还是不行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    #ifdef CONFIG_BOARD_AIRVR3</span><br><span class="line">	&#123;0x5a, 0x50&#125;,</span><br><span class="line">	&#123;0x5b, 0x3c&#125;,</span><br><span class="line">    #else</span><br><span class="line">	&#123;0x5a, 0xc8&#125;,</span><br><span class="line">	&#123;0x5b, 0x96&#125;,</span><br><span class="line">    #endif</span><br><span class="line">	&#123;0x5c, 0x00&#125;,</span><br><span class="line">	&#123;0xc3, 0xed&#125;,</span><br><span class="line">	&#123;0x7f, 0x00&#125;,</span><br><span class="line">	&#123;0xe5, 0x1f&#125;,</span><br><span class="line">	&#123;0xdd, 0x7f&#125;,</span><br><span class="line">	&#123;0x05, 0x00&#125;,</span><br><span class="line">#if 1	&#x2F;&#x2F;color bar</span><br><span class="line">	&#123;0xff, 0x01&#125;,</span><br><span class="line">	&#123;0x12, 0x02&#125;,</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>


<h2 id="尝试log"><a href="#尝试log" class="headerlink" title="尝试log"></a>尝试log</h2><p>reduced the clock to 11MHz, 似乎能提高帧率</p>
<p>图像格式的问题, 搞清楚是怎么设置的. 八成不是中断的问题…<br>把RGB关掉试试, 用YUV也是好的</p>
<p>测试情况:<br>使用airv配置 不注释svga, 有时花屏有时正常显示, 图像也上下左右反了<br>使用maixpy配置有时无法显示, 有时正常</p>
<p>不会显示异常的关键是选对dvp的颜色格式和摄像头配置的颜色格式</p>
<p>maixpy的摄像头相关还是不太行, 可能有bug. 这里如果不设置framesize就直接snapshot, 会报错Not init.<br>之后居然就崩了…</p>
<p>这就是软件工程的困境吗?</p>
<p>等一波新版本发布, github watch了</p>
<p>不会是供电问题吧… 只有程序小的时候才能正常显示</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天添加散热片发现, k210在dvp2lcd的时候发热还是非常大的. 而当我把k210吹冷了之后, 摄像头就又能用了.<br>可能摄像头本身就是好的吧, 一个是摄像头的参数不如官方的例程调教得好, 有一些彩色条纹. 看电脑屏幕有波纹(可能是正常现象.)<br>另外就是Back的时候, 需要额外设置hmirror(1)的时候才是正确的, 之后可以把这个设置搞成默认.</p>
<p>也可能是摄像头发热严重(更可能了, 因为我CPU降频了还是不太稳.) 这个还不好贴散热片<br>降频试试, 改代码增加了个clock devidor, 帧率减半, 看看会不会好一点</p>
<p>最后发现帧率减半确实稳定了一些, 没有显示的时候手动按下reset也容易来显示.<br>另外修改main.py, 利用time的计时器, 计算了一下调用sensor.snapshot和lcd.display消耗的时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while True:</span><br><span class="line">    img&#x3D;sensor.snapshot()</span><br><span class="line">    print(&#39;sensor time consume:&#39;)</span><br><span class="line">    print(time.ticks_diff(time.ticks_us(), last))</span><br><span class="line">    last &#x3D; time.ticks_us()</span><br><span class="line">    lcd.display(img)</span><br><span class="line">    print(&#39;display time consume:&#39;)</span><br><span class="line">    print(time.ticks_diff(time.ticks_us(), last))</span><br><span class="line">    last &#x3D; time.ticks_us()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sensor time consume:</span><br><span class="line">64081</span><br><span class="line">display time consume:</span><br><span class="line">158648</span><br><span class="line">sensor time consume:</span><br><span class="line">64122</span><br><span class="line">display time consume:</span><br><span class="line">158715</span><br><span class="line">sensor time consume:</span><br><span class="line">64022</span><br><span class="line">display time consume:</span><br><span class="line">158769</span><br><span class="line">sensor time consume:</span><br><span class="line">63994</span><br><span class="line">display time consume:</span><br><span class="line">158708</span><br><span class="line">sensor time consume:</span><br><span class="line">64098</span><br><span class="line">display time consume:</span><br><span class="line">158698</span><br></pre></td></tr></table></figure>
<p>可能拖后腿的还是这个小屏吧? 毕竟只有一根线的spi? 或者说是maixpy的display太消耗时间了?</p>
<p>看了看那边widora例程的频率确实高一些, 设置<code>lcd.freq(20000000)</code>和那边相同之后帧率感觉高了一些, 不知道是不是错觉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sensor time consume:</span><br><span class="line">73897</span><br><span class="line">display time consume:</span><br><span class="line">148786</span><br><span class="line">sensor time consume:</span><br><span class="line">74002</span><br><span class="line">display time consume:</span><br><span class="line">148886</span><br><span class="line">sensor time consume:</span><br><span class="line">73860</span><br><span class="line">display time consume:</span><br><span class="line">148909</span><br><span class="line">sensor time consume:</span><br><span class="line">73860</span><br><span class="line">display time consume:</span><br><span class="line">148867</span><br></pre></td></tr></table></figure>
<p>把这个帧率也搞成默认吧. 直接在makefile里面设置就可以. 帧率就先不考虑, 主要考虑摄像头的稳定性, 不会重启用不了就好</p>
<p>我以为freq.conf是自己改的, 没想到是设置之后自动保存的, 我们不用改…</p>
<p>希望maixpy越来越好.</p>
]]></content>
  </entry>
  <entry>
    <title> 设置最新版本的windows10 能够访问的samba服务器</title>
    <url>/samba/</url>
    <content><![CDATA[<h1 id="设置最新版本的windows10-能够访问的samba服务器"><a href="#设置最新版本的windows10-能够访问的samba服务器" class="headerlink" title="设置最新版本的windows10 能够访问的samba服务器"></a>设置最新版本的windows10 能够访问的samba服务器</h1><p>需要有只读的公共访问和可读可写的非公共访问<br>注意的地方是, 第一次访问可能会询问用户名密码, 不代表guest配置失败, 乱输用户名即可通过<code>map to guest = bad user</code> 作为guest</p>
<h2 id="关键配置1-加密和签名"><a href="#关键配置1-加密和签名" class="headerlink" title="关键配置1 加密和签名"></a>关键配置1 加密和签名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	server signing &#x3D; mandatory</span><br><span class="line">#	smb encrypt &#x3D; mandatory</span><br></pre></td></tr></table></figure>
<p>查看日志发现, 新版本的win10(还是samba服务器??)对没有加密也没有签名的连接会拒绝. 所以需要这两个选项.</p>
<p>加密必须要用户名和密码, 因为加密的会话密钥就是和用户名关联的. 因此为了guest用户, 需要注释掉加密的选项.</p>
<p>来自<a href="https://serverfault.com/questions/874423/how-to-enable-samba-encryption-and-do-not-require-user-authentication">How to enable SAMBA encryption and do not require user authentication
</a></p>
<h2 id="关键配置2"><a href="#关键配置2" class="headerlink" title="关键配置2"></a>关键配置2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#	min protocol &#x3D; SMB2</span><br></pre></td></tr></table></figure>
<p>自从win10开始, 默认使用的就是SMB3_11了, 在 <code>启用或关闭windows功能</code> 里开启SMB1/CIFS, 访问时就可能会使用SMB2. 这里调试的时候可以考虑强制改成SMB3. 发现关键问题之后为了兼容性注释掉了</p>
<h2 id="关键配置3"><a href="#关键配置3" class="headerlink" title="关键配置3"></a>关键配置3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guest account &#x3D; guest</span><br><span class="line">null passwords &#x3D; yes</span><br></pre></td></tr></table></figure>
<p>默认是<code>guest account = nobody</code>. #TODO<br>第二个参数 <code>null passwords</code> 不加上, 使用空密码登录的时候就会被拒绝.</p>
<h2 id="关键配置4-ntlm-auth"><a href="#关键配置4-ntlm-auth" class="headerlink" title="关键配置4 ntlm auth"></a>关键配置4 ntlm auth</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntlm auth &#x3D; ntlmv1-permitted</span><br><span class="line">lanman auth &#x3D; yes</span><br><span class="line">raw NTLMv2 auth &#x3D; yes</span><br></pre></td></tr></table></figure>
<p>win10可能会使用ntlmv1, 而经过永恒之蓝事件之后samba默认只接受ntlmv2了.<br>关键的只是第一条, 后面的两条是逛的时候发现的, 加了可以增加兼容性.</p>
<p><a href="https://bgstack15.wordpress.com/2017/10/01/samba-and-ntlm-for-windows-clients/">Samba and ntlm for Windows clients</a></p>
<p><a href="https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html#NTLMAUTH">samba config ntlmauth</a></p>
<h2 id="关键配置5-passdb-backend"><a href="#关键配置5-passdb-backend" class="headerlink" title="关键配置5 passdb backend"></a>关键配置5 passdb backend</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passdb backend &#x3D; smbpasswd:&#x2F;etc&#x2F;samba&#x2F;smbpasswd</span><br><span class="line">smb passwd file &#x3D; &#x2F;etc&#x2F;samba&#x2F;smbpasswd</span><br></pre></td></tr></table></figure>
<p>新版本默认使用的不是smbpasswd, 默认的数据库位置更不是 <code>/etc/samba/smbpasswd</code>. 新版本似乎用的是 <code>pdbedit</code>? </p>
<p>指定数据库文件位置似乎是用第一行的方式了, 第二行似乎没有效果了?</p>
<h2 id="关键配置6-force-user"><a href="#关键配置6-force-user" class="headerlink" title="关键配置6 force user"></a>关键配置6 force user</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">force user &#x3D; pi</span><br></pre></td></tr></table></figure>
<p>强制用户了之后上传的文件的所有者就都是一样的了</p>
<h2 id="总体配置"><a href="#总体配置" class="headerlink" title="总体配置:"></a>总体配置:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">    map to guest &#x3D; Bad User</span><br><span class="line">	server signing &#x3D; mandatory</span><br><span class="line">#	smb encrypt &#x3D; mandatory</span><br><span class="line">#	min protocol &#x3D; SMB2</span><br><span class="line">	passdb backend &#x3D; smbpasswd:&#x2F;etc&#x2F;samba&#x2F;smbpasswd</span><br><span class="line">	smb passwd file &#x3D; &#x2F;etc&#x2F;samba&#x2F;smbpasswd</span><br><span class="line">	guest account &#x3D; guest</span><br><span class="line">	null passwords &#x3D; yes</span><br><span class="line">	security&#x3D;user</span><br><span class="line">	ntlm auth &#x3D; ntlmv1-permitted</span><br><span class="line">	lanman auth &#x3D; yes</span><br><span class="line">	raw NTLMv2 auth &#x3D; yes</span><br><span class="line"></span><br><span class="line">[ro]</span><br><span class="line">        # This share allows anonymous (guest) access</span><br><span class="line">        # without authentication!</span><br><span class="line">        path &#x3D; &#x2F;home&#x2F;pi&#x2F;</span><br><span class="line">#	force user &#x3D; pi</span><br><span class="line">        read only &#x3D; yes</span><br><span class="line">        guest ok &#x3D; yes</span><br><span class="line">#        guest only &#x3D; yes</span><br><span class="line"></span><br><span class="line">[rw]</span><br><span class="line">	path &#x3D; &#x2F;home&#x2F;pi&#x2F;</span><br><span class="line">	read only &#x3D; no</span><br><span class="line">	valid users &#x3D; pi</span><br><span class="line">	force user &#x3D; pi</span><br></pre></td></tr></table></figure>

<h2 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h2><p>windows 清除登录密码首先要凭据管理器删除<br>接着我任务管理器关闭explorer再启动, 没有用, 只有重启</p>
<p>debug samba 的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service smbd stop</span><br><span class="line">sudo smbd -F -S -d&#x3D;10</span><br></pre></td></tr></table></figure>
<p>此时再连接, 就可以看到debug信息了. -d指定的loglevel从1到10.<br><code>-d=5</code>的时候的log就已经很多了, <code>-d=3</code> 的时候log不是很多.平时一般先使用 <code>-d=3</code></p>
]]></content>
  </entry>
  <entry>
    <title> SPI</title>
    <url>/spi/</url>
    <content><![CDATA[<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>Widora AIRV R3 适配Maixpy 项目</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到推荐就买了, 毕竟板载的传感器太全了, 一个小板子就什么都有了, 而且便宜. 导致我走上了这条路. 希望能静下心来. 学到什么. 我经常为了像这样做到些什么而学习, 但往往走偏, 后期只想着想要做到的事情, 完全抛弃了学习, 瞎试, 就是不去继续学.</p>
<p>TODO: 为maixpy 贡献一点文档</p>
<h2 id="spi总线"><a href="#spi总线" class="headerlink" title="spi总线"></a>spi总线</h2><p>maixpy支持其他板子, 经测试, 无法驱动本板子屏幕. 怀疑是接线有问题. 找来板子的接线图, 和各种硬件资料.</p>
<p>中景园1.14寸屏幕用的是TODO的芯片. 支持各种SPI通讯方式. 主要看屏幕控制芯片的手册.</p>
<p>SPI总线可以只靠一条线(3线接口), 或者控制/数据的电平信号线 + 真正的数据线(4线接口). 控制/数据的电平信号线为(高/低)的时候表示发送的这个字节是命令, 否则表示是数据(命令的参数). 另外, 这些传输都有时钟信号的同步.</p>
<p>片选信号变低, 选择芯片, 芯片准备接受数据. 不带(控制/数据的电平信号线)的时候传输9个bit, 第一个bit表示是控制还是数据. 带的时候连续传输8个bit,  传输第8个bit结束的时候对控制/数据信号进行采样, 判断是控制还是数据.</p>
<p>k210芯片带有fpio, 能够软件控制输出引脚和对应芯片内真正引脚的映射关系!! 可能类似fpga, 这个功能真是绝了, 可能是我见识太浅. 接spi线的时候, 一般spi接口的数据线还是直连, 其他复位, 控制/数据选择, 片选都可以直接在GPIO或者高速GPIO里面随便选一个. 因此不同板子要调整这些映射.</p>
<p>SPI总线也可以多条线, 4条,8条甚至16条等并行连接, 这个屏幕是典型的4线. 该板子可以外接的另外那个大屏幕似乎就是8数据线的spi.</p>
<p>4-line serial interface Ⅱ</p>
<table>
<thead>
<tr>
<th>Pin Name</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>CSX/CS</td>
<td>Chip selection signal</td>
</tr>
<tr>
<td>SCL</td>
<td>Clock signal</td>
</tr>
<tr>
<td>SDA</td>
<td>Serial data input data</td>
</tr>
<tr>
<td>WRX/RS</td>
<td>Data is regarded as a command when WRX is low. Data is regarded as a parameter or data when WRX is high</td>
</tr>
<tr>
<td>DCX</td>
<td>Clock signal</td>
</tr>
<tr>
<td>SDO</td>
<td>serial output data</td>
</tr>
</tbody></table>
<p>3 line interface Ⅰ spi 只有片选CSX, DCX时钟, SDA 输入输出<br>3 line interface Ⅱ 多了 SDO, 输入和输出引脚分开了.<br>4 line interface Ⅰ 只有片选CSX, WRX控制/数据(参数)选择, DCX时钟, SDA 输入输出 .<br>4 line interface Ⅱ同理.</p>
<p>DCX有时说是WRX一样的控制/数据选择. 可能是叫法的问题还是理解的问题???TODO</p>
<p>SCL –&gt; LCD_WR<br>WRX/RS –&gt; LCD_DC</p>
<p>LCD_WR是时钟<br>GPIOHS30在maixpy代表LCD复位<br>GPIOHS31代表控制/数据选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fm.unregister(36, fm.fpioa.SPI0_SS3)</span><br><span class="line">fm.register(37, fm.fpioa.SPI0_SS3)</span><br><span class="line"></span><br><span class="line">fm.unregister(37, fm.fpioa.SPI0_SCLK)</span><br><span class="line">fm.register(39, fm.fpioa.SPI0_SCLK)</span><br><span class="line"></span><br><span class="line">fm.unregister(38, fm.fpioa.GPIOHS30)</span><br><span class="line">fm.unregister(39, fm.fpioa.GPIOHS31)</span><br><span class="line">fm.register(38, fm.fpioa.GPIOHS31)</span><br></pre></td></tr></table></figure>

<p>LCD是片选3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------|-----------------------+</span><br><span class="line">|   36     |     LCD_CS            |</span><br><span class="line">+----------|-----------------------+</span><br><span class="line">|   37     |     LCD_RST           |</span><br><span class="line">+----------|-----------------------+</span><br><span class="line">|   38     |     LCD_DC            |</span><br><span class="line">+----------|-----------------------+</span><br><span class="line">|   39     |     LCD_WR            |</span><br><span class="line">+----------|-----------------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fm.unregister(36, fm.fpioa.SPI0_SS3)</span><br><span class="line">fm.unregister(37, fm.fpioa.SPI0_SCLK)</span><br><span class="line"></span><br><span class="line">fm.register(37, fm.fpioa.SPI0_SS3)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fpioa_set_function(37, FUNC_GPIOHS0 + RST_GPIONUM);</span><br><span class="line">fpioa_set_function(38, FUNC_GPIOHS0 + DCX_GPIONUM);</span><br><span class="line">fpioa_set_function(36, FUNC_SPI0_SS0+LCD_SPI_SLAVE_SELECT);</span><br><span class="line">fpioa_set_function(39, FUNC_SPI0_SCLK);</span><br></pre></td></tr></table></figure>

<p>SPI_FF_STANDARD： 标准<br>​ SPI_FF_DUAL： 双线<br>​ SPI_FF_QUAD： 四线<br>​ SPI_FF_OCTAL： 八线（SPI3 不支持）</p>
<h2 id="屏幕控制芯片TODO"><a href="#屏幕控制芯片TODO" class="headerlink" title="屏幕控制芯片TODO"></a>屏幕控制芯片TODO</h2><p>和芯片的交互基于SPI之后, 就是发送各种控制和数据. 芯片一般有nt35310和我现在的这个st7789. 首先是各种初始化的命令, 后面就是发送数据了. 显示的数据是一个个像素传送的, 有RGB565和SUV等颜色模式.</p>
<p>初始化首先发送SOFTWARE_RESET -(睡100ms 后面同理)-&gt; SLEEP_OFF –&gt; PIXEL_FORMAT_SET= 0x55 (表示是TODO模式) –&gt; DISPALY_ON</p>
<h2 id="屏幕定位"><a href="#屏幕定位" class="headerlink" title="屏幕定位"></a>屏幕定位</h2><p>横着是x, 竖着是y方向</p>
<p>控制芯片的大小是<code>320x240</code>, 当设置屏幕大小是这个值的时候.<br>屏幕的大小是<code>240x135</code>, 刚好在中间. 左右空出40, 上下空出53/52左右<br>左上角大概在(40, 52), 右下角在(280, 187)左右. 发现代码中可以设置偏移, 把偏移设置成50 40(横屏模式), 和 40 52(竖屏模式) 就好了. 基本完美.<br>而且反色了… 和代码中写的颜色是反的, 代码中初始化是背景色红色, 白色的字. 不知道是不是有意为之, 或者有的屏幕就是这样. 反色之后的背景白里透蓝, 黑色的字.<br>那我就默认反色吧, 就和代码里的颜色一致了.</p>
<p>可以设置默认的屏幕大小. 按照保证允许软件传参更改的同时, 设置好能用的默认值的这个方针.</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>micropython 解释器里面 摄像头能不能用</p>
<p>测试硅麦能不能用<br>找笑声检测模型</p>
<h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><p>引脚接的都是对的. 可以直接用, 但是不稳.<br>不知道为什么例程很稳, 而当前的maixpy经常会报错</p>
<p>TODO:<br>学习DVP接口, 学习摄像头相关的参数.<br>似乎是i2c? i2s? 2号 总线</p>
<h2 id="麦克风"><a href="#麦克风" class="headerlink" title="麦克风"></a>麦克风</h2><p>TODO:<br>完全没有声音… 全是0</p>
]]></content>
  </entry>
  <entry>
    <title> windows 权限提升与监控</title>
    <url>/windows%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="windows-权限提升与监控"><a href="#windows-权限提升与监控" class="headerlink" title="windows 权限提升与监控"></a>windows 权限提升与监控</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>在windows中有两种访问控制，首先是强制完整性控制，它蕴含在SACL中。其次是自主访问控制DACL。</p>
<p>SACL原本的用途是类似自主访问控制一样自主控制系统日志，但完整性控制加入到了它的范围内。</p>
<p>UAC提权不仅完整性从medium到了high，而且多了特权。特权是另外的资源。</p>
<p>UAC绕过的例外方法：提升的COM名字对象，UIAccess</p>
<p>从admin到system的方法：令牌窃取。</p>
<h3 id="强制完整性控制（MIC）"><a href="#强制完整性控制（MIC）" class="headerlink" title="强制完整性控制（MIC）"></a>强制完整性控制（MIC）</h3><p>windows 首先是自主访问控制, 只有很简单的强制访问控制, 在原本只是打印日志的SACL的完整性字段里. 实现的方式是”可上读, 可下写”. 为了保证完整性, 只需要严格控制写权限. TODO: 能不能下读.</p>
<p>保护完整性的强制访问控制: 低级的不可以（发送消息）影响高级的程序。</p>
<p>与之对应的是保护机密性的强制访问控制：低级的可以发消息给高级程序，而高级程序无法发消息给低级程序（泄露机密。）</p>
<p>windows中的完整性等级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SeUntrustedMandatorySid</span><br><span class="line">SeLowMandatorySid</span><br><span class="line">SeMediumMandatorySid</span><br><span class="line">SeHighMandatorySid</span><br><span class="line">SeSystemMandatorySid</span><br></pre></td></tr></table></figure>

<p>主体的缺省完整性级别是SeUntrustedMandatorySid，而客体的缺省完整性级别是SeMediumMandatorySid</p>
<blockquote>
<p>进程完整性级别是为了保证不同标签的进程（TOKEN) 和对象（SACL)之间的访问安全<br><a href="https://zh.wikipedia.org/wiki/%E5%BC%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6">https://zh.wikipedia.org/wiki/%E5%BC%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6</a></p>
<p><a href="https://en.wikipedia.org/wiki/Security_Identifier">SID</a></p>
<p>可以看到标准用户和经过权限提升的UAC用户信息的差别。用户名项中组信息和sid均相同，区别就是UAC用户是经过权限提升的，最终体现在权限上的不同如下：</p>
<p>1.组信息项中主要是Integrity levels (IL)【进程完整性级别不同】。标准用户是Medium Mandatory Level，UAC用户是High Mandatory Level,它包括Untrust， Low， Medium， Hight， System等， 级别越低，权限也就越低。我们可以通过GetTokenInformation的TokenIntegrityLevel来进行查询。<br>2.体现在Privilege中的就是UAC用户拥有很多Privilege，比如最常用的SeDebugPrivilege 。<br>注释：<br>进程完整性级别是为了保证不同标签的进程（TOKEN) 和对象（SACL)之间的访问安全，如果当前进程的TOKEN 是Low Mandatory Level， 它就不能修改具有Medium Mandatory Level的对象，即使我们对象的DACL赋予完全读写的权限。当每个进程打开对象， 我们会进行SACL和DACL检查，这个检查通过核心态函数<br>SeAccessCheck . 只有当前进程TOKEN的　完整性标签　高于或者等于　对象的完整性标，　我们才会进一步进行 DACL 检查。如果完整性标签验证通不过。 即使DACL给予再高权限都无济于事。</p>
</blockquote>
<h3 id="DACL-自主访问控制列表"><a href="#DACL-自主访问控制列表" class="headerlink" title="DACL 自主访问控制列表"></a>DACL 自主访问控制列表</h3><p>文件/注册表方面自然是还有自主访问控制. 进程没想到!!和文件一样的, 有安全描述符<br>主体是访问令牌. 每个进程都有一个基本令牌 (Primary Token)，可以被进程中的每个线程所共享, 后面线程可以获得其他令牌. 令牌里有用户sid, 组sid, 受限sid, 特权, 身份模拟级别, 完整度级别.<br>客体是对象: 文件/注册表/进程. 客体关联了安全描述符, 安全描述符包括所有者SID, 组SID, DACL, SACL(日志)</p>
<p>“属性” =&gt; “安全”, “权限”选项卡就是DACL，”审核”选项卡是SACL，“所有者”是Owner、Group。</p>
<p>每个DACL内有很多ACE, 访问控制表项, 可以接受也可以拒绝, 先找到的生效. 因此(有时?)一般拒绝的放在接受的前面.</p>
<p>impersonation 身份模拟 传输层, 被rpc使用的, 服务端可以使用客户端的令牌.</p>
<p>令牌里的权限有的没有enable, 要单独开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+0x000 Present          : Uint8B</span><br><span class="line">+0x008 Enabled          : Uint8B</span><br><span class="line">+0x010 EnabledByDefault : Uint8B</span><br></pre></td></tr></table></figure>
<p>特权Privilege在访问某个具体的安全对象时并没有作用，Privilege是表示进程是否能够进行特定的系统操作，如关闭系统、修改系统时间、加载设备驱动等。</p>
<h3 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h3><p>当用户登录Windows时，操作系统会为用户生成一对初始令牌，分别是代表着用户所拥有的全部权限的完整版本令牌(即管理员权限令牌)，以及被限制管理员权限后的普通令牌，二者互为关联令牌;此后，代表用户的进程所使用的令牌都是由普通令牌继承而来，用来进行常规的、非敏感的操作;当用户需要进行一些需要管理员权限的操作时，比如安装软件、修改重要的系统设置时，都会通过弹出提权对话框的形式提示用户面临的风险，征求用户的同意，一旦用户同意，将会切换到当前普通令牌关联的管理员权限令牌，来进行敏感操作。通过这种与用户交互的方式，避免一些恶意程序在后台稍稍执行敏感操作。<br><a href="http://blog.nsfocus.net/analysis-windows-access-authority-inspection-mechanism/">来自</a></p>
<blockquote>
<p>Access Token：是一个包含了登陆会话安全信息的 Windows 软件对象，用于指名一个用户以及他所在组以及相应的特权。<br>UAC Token：定义了Windows Vista 用户在UAC支持开启的时候的默认交互式登陆特权。一个 UAC Token 定义了最小的运行特权。<br>Full Token：给账户提供了最大的经过授权的特权。Full Token 实际上是由该用户隶属于的用户组决定的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过whoami -all查看当前用户所拥有的Privilege。</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>部分受保护进程难以获得debug, 注入等权限. 保护进程的Protection成员不为0. 两种保护类型：Protected Process(PP)，Protected Process Lite(PPL). 对于Signer为PsProtectedSignerWindows(5)和PsProtectedSignerTcb(6)的保护进程, 其Type和Signer信息会被抽取出来, 组合成sid, 保存到基本令牌中的TrustLevelSid成员中</p>
<p>通过创建受限令牌，可以获得一个普通令牌所有拥有的权限集合的一个子集，用来进行一些低权限操作，降低安全风险。</p>
<p><a href="http://www.youngroe.com/2015/08/14/Windows/Windows-Permissions-Privilege/">权限编程需要注意的</a><br><a href="http://www.cppblog.com/weiym/archive/2013/08/25/202751.html?opt=admin">权限编程2</a></p>
<h2 id="用户界面特权隔离-User-Interface-Privilege-Isolation-UIPI"><a href="#用户界面特权隔离-User-Interface-Privilege-Isolation-UIPI" class="headerlink" title="用户界面特权隔离 User Interface Privilege Isolation, UIPI"></a>用户界面特权隔离 User Interface Privilege Isolation, UIPI</h2><p>通过结合强制完整性控制，用户界面特权隔离阻止较低等完整性级别（Integrity level）的进程向较高等完整性级别进程的窗口发送消息或者安装钩子，但也有一些消息不被阻止。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-account-control-allow-uiaccess-applications-to-prompt-for-elevation-without-using-the-secure-desktop">UIAccess</a> 选项The ability to bypass UIPI restrictions across privilege levels is available for UI automation programs by using UIAccess. 但是必须签名并且安装在指定地点.</p>
<p>UAC level: asInvoker 不询问权限, 但是用户可以右键以管理员权限运行. highestAvailable时如果用户在admin用户组则和requireAdministrator一样, 必须以管理员权限运行.</p>
<blockquote>
<p>A lower privilege process cannot:</p>
</blockquote>
<blockquote>
<ul>
<li>Perform a window handle validation of higher process privilege.</li>
<li>SendMessage or PostMessage to higher privilege application windows. These application programming interfaces (APIs) return success but silently drop the window message.</li>
<li>Use thread hooks to attach to a higher privilege process.</li>
<li>Use Journal hooks to monitor a higher privilege process.</li>
<li>Perform dynamic link library (DLL)–injection to a higher privilege process.</li>
</ul>
</blockquote>
<h2 id="键盘监控的思路"><a href="#键盘监控的思路" class="headerlink" title="键盘监控的思路"></a>键盘监控的思路</h2><table>
<thead>
<tr>
<th>API</th>
<th>适用范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>GetAsyncKeyState</td>
<td></td>
<td>每次获取单个按键的状态, 轮询每个键状态, 效率略低</td>
</tr>
<tr>
<td>GetKeyboardState</td>
<td></td>
<td>一次获取所有的键的状态, 和消息队列相关</td>
</tr>
<tr>
<td>SetWindowsHookEx 指定键盘</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="SetWindowsHookEx"><a href="#SetWindowsHookEx" class="headerlink" title="SetWindowsHookEx"></a>SetWindowsHookEx</h3><p>在回调函数中，我们将接收KeyboardProc的wParam中的虚拟键码和LowLevelKeyboardProc的KBDLLHOOKSTRUCT.vkCode（wParam指向KBDLLHOOKSTRUCT）。</p>
<p>如果m_ThreadId = 0，则消息钩子是全局消息钩子。针对全局消息钩子，你必须将回调函数置于dll中，并且需要编写2个dll来分别处理x86/x64进程。</p>
<p>针对底层键盘钩子，SetWindowsHookEx的HMod参数可以为NULL或者本进程加载的模块（我测试了user32，ntdll）。</p>
<p>WH_KEYBOARD_LL不需要dll中的回调函数，并且能适应x86/x64进程。</p>
<p>WH_KEYBOARD需要两个版本的dll，分别处理x86/x64。但是如果使用x86版本的全局消息钩子，所有的x64线程仍被标记为“hooked”，并且系统在钩子应用上下文执行钩子。类似的，如果是x64，所有的32位的进程将使用x64钩子应用的回调函数。这就是为什么安装钩子的线程必须要有一个消息循环。</p>
<p>hook是在整个桌面环境(desktop)内的. uac是safe desktop, 另外一个桌面</p>
<p><a href="https://www.anquanke.com/post/id/86403">来自</a><br><a href="https://securelist.com/keyloggers-implementing-keyloggers-in-windows-part-two/36358/">专业文章</a></p>
<p>已知设置钩子是不能跨越完整度保护的. 猜测至少需要最高的完整度级别才能设置全局钩子</p>
<blockquote>
<p>“Process isolation provides a way to extend the authorization model to common extension points for inter-process communication. For example, if an application running at medium integrity were to register a hook to process Windows messages, this hook would not be active in a process running at the high integrity level.”</p>
</blockquote>
<p>所以可能可以安装但是其实不是全局?</p>
<h3 id="subsystem-console"><a href="#subsystem-console" class="headerlink" title="subsystem: console"></a>subsystem: console</h3><p>是一个过时的东西, 直接用subsystem: windows??<br><a href="https://www.devever.net/~hl/win32con">看这</a></p>
<h2 id="自启动技术"><a href="#自启动技术" class="headerlink" title="自启动技术"></a>自启动技术</h2><p><a href="https://www.jianshu.com/p/cf01fee50fb4">自启动技术</a></p>
<h2 id="bypass-uac"><a href="#bypass-uac" class="headerlink" title="bypass uac"></a>bypass uac</h2><p><a href="https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz">概述</a></p>
<p>这里研究的是COM接口绕过<br><a href="https://y4er.com/post/bypassuac-with-icmluautil/">详述</a></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><ol>
<li>权限窃取</li>
<li>使用服务的impersonation<br>真正的关键是分析其中的权限问题</li>
</ol>
<p>首先是bypass UAC, 得到SeDebugPrivilege, 然后就可以直接用窃取的方式得到System<br>没有UAC时特权很少, 完整度级别为Medium, 过了UAC就是High</p>
<p>现在就看创建服务了. 如果创建服务获取system不需要高完整度, 那就神了. 否则还是要bypass uac, 那还不如上面的方法.<br>目前我猜测大概是要高完整度的.</p>
<h2 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h2><p>远程线程注入首当其冲就是权限问题, 需要debug权限?? !!<br>meterpreter 怎么migrate的</p>
<p>打开一个同级别的进程, Medium的完整度的, OpenProcess的时候指定什么权限??</p>
<h2 id="raw-input方法的主函数的消息循环"><a href="#raw-input方法的主函数的消息循环" class="headerlink" title="raw_input方法的主函数的消息循环"></a>raw_input方法的主函数的消息循环</h2><p>发现主函数其实消息非常少… 平时只有一个消息, 开了hook之后每按下和松开都有一个事件.<br>理解为是winmain的消息传过去的吗… 或者要先给到这边, 才能给到那边winProc<br>发现如果没有getMessage的循环，无论是Hook的keylog还是rawInput的keylog都不行。创建一个子进程执行而不是在dllmain里面执行好像没什么区别？？？ notepad.exe正常使用？？<br>我的问题是，notepad.exe这种桌面程序难道不是应该winmain里有自己的Getmessage吗。。。为什么即使是注入也需要自己有getMessage的循环？？</p>
]]></content>
  </entry>
  <entry>
    <title> 一句话博客</title>
    <url>/%E4%B8%80%E5%8F%A5%E8%AF%9D/</url>
    <content><![CDATA[<h1 id="一句话博客"><a href="#一句话博客" class="headerlink" title="一句话博客"></a>一句话博客</h1><h2 id="最稳定的给自己的推送"><a href="#最稳定的给自己的推送" class="headerlink" title="最稳定的给自己的推送"></a>最稳定的给自己的推送</h2><p>通过qq邮箱SMTP，发给自己（同一个邮箱），通过qq的QQ邮箱提醒接收</p>
<h2 id="最方便地换硬盘重装系统"><a href="#最方便地换硬盘重装系统" class="headerlink" title="最方便地换硬盘重装系统"></a>最方便地换硬盘重装系统</h2><p>利用win10自带的 <code>备份与恢复（win7）</code> 借来一个大容量移动硬盘先备份，换硬盘之后恢复</p>
<h2 id="ida出现import-site-failed"><a href="#ida出现import-site-failed" class="headerlink" title="ida出现import site failed"></a>ida出现import site failed</h2><p>清空自己的PYTHONHOME才行<br>或者通过bat启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set PYTHONHOME&#x3D;</span><br><span class="line">set PYTHONPATH&#x3D;</span><br><span class="line">start C:\Users\warren\my_programs\IDA_Pro_v7.0_Portable\ida.exe</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title> 树莓派resbian</title>
    <url>/%E6%A0%91%E8%8E%93%E6%B4%BEresbian/</url>
    <content><![CDATA[<h1 id="树莓派resbian"><a href="#树莓派resbian" class="headerlink" title="树莓派resbian"></a>树莓派resbian</h1><a id="more"></a>
<p>2019-12-07<br><a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md">https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md</a><br>这是新系统？好像还不错</p>
<h2 id="上手系统安装"><a href="#上手系统安装" class="headerlink" title="上手系统安装"></a>上手系统安装</h2><p>下载系统镜像，解压。。。<br>一般发行版下载的系统的iso，但是树莓派系统是img的压缩包，要先解压。</p>
<p>刷镜像一般用win32diskimager。linux用dd命令。<br>也就是说，如果你经常刷系统，拿到树莓派如果先不急着拓展文件系统空间，安装完一些软件，就可以拿回来用win32diskimager读img镜像出来留着。<br>刷完反射性地在boot的根目录下新建ssh空文件。<br>然后就是启动，一句sudo raspi-config打开vnc。<br>树莓派还是对桌面玩家友好😭，图形界面比命令行调乱七八糟的参数好得多。</p>
<p>一些闲话：<br>回忆起很久以前ubuntu等桌面版还不知道用什么刷到优盘的时候，有个opensusu的小工具也是刷优盘镜像的。主要需要对磁盘的二进制读写能力，才能写出启动盘。<br>最近装了一次win10，以前装win7还会用用ultraISO的写入硬盘镜像到优盘，现在它已经落后变得垃圾了，写入不是卡死就是不能启动，现在用rufus-3.6p.exe这个小巧的程序特别强。装系统的时候才了解到难道uefi已经支持ntfs了吗<br>已经是第二次不能从sd卡启动了。。。是不是uefi歧视sd卡。。。只能用优盘，也不知道是不是驱动不一样。</p>
<h2 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h2><p>直接执行，进行日志的查看<br>参数：<br>-n 3<br>查看最近三条记录<br>-perr<br>查看错误日志<br>-overbose<br>查看日志的详细参数<br>–since<br>查看从什么时候开始的日志<br>–until<br>查看什么时候截止的日志</p>
<p>这条命令主要是因为我之前用手机充电器，这里会报低电压警告<br>最近买了新电源，用这个命令来看看还会不会警告。果然换了电源就看不到了</p>
<h2 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2><p>sudo iw dev wlan0 set power_save on|off<br>这条命令关闭wifi的电源管理，否则wifi不稳，我以前通过wifi进行ssh不可靠就是因为这个和电源</p>
<h2 id="安装无线网卡驱动"><a href="#安装无线网卡驱动" class="headerlink" title="安装无线网卡驱动"></a>安装无线网卡驱动</h2><p>手头有一块垃圾的tenda U6，是rtl8192eu的，还有一张rtl8812au<br><a href="https://github.com/Mange/rtl8192eu-linux-driver">https://github.com/Mange/rtl8192eu-linux-driver</a><br><a href="https://github.com/aircrack-ng/rtl8812au">https://github.com/aircrack-ng/rtl8812au</a><br>按照github的readme进行设置，<br>我有一次只是安装rtl8192eu的dkms模块，没有进行教程接下来的设置操作，就开不了机，只能重刷系统😭。<br>开机就可以执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git raspberrypi-kernel-headers build-essential dkms;</span><br></pre></td></tr></table></figure>
<p>让它慢慢下载</p>
<h2 id="networkManager"><a href="#networkManager" class="headerlink" title="networkManager"></a>networkManager</h2><p>这里我需要给树莓派固定的ip，但是发现这次树莓派每次启动wifi网卡mac地址都随机化，每次一个新ip，还查不出这个网卡是哪个厂商的。。。<br>但是图形化界面没有设置的地方，还是ubuntu的network-manager-gnome友好，里面有这个选项。<br>于是试图使用network-manager-gnome管理无线网<br>本来以为network-manager-gnome是gnome桌面专用的东西，后来装了才发现lxde照用不误，有桌面环境就行。<br>sudo apt-get install network-manager-gnome<br>这里安装后菜单就出现了advanced network Configuration<br>修改配置文件<br>sudo nano /etc/NetworkManager/NetworkManager.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">plugins&#x3D;ifupdown,keyfile</span><br><span class="line"></span><br><span class="line">[ifupdown]</span><br><span class="line">managed&#x3D;false</span><br></pre></td></tr></table></figure>
<p>把false改成true<br>#注：managed这里表示是否管理/etc/network/interfaces里配置了的网络接口<br>修改/etc/network/interfaces，在末尾加上如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">        hwaddress b8:27:eb:00:00:00</span><br></pre></td></tr></table></figure>
<p>相关原理：<br>下面基于2019年7月31日下载的raspbian系统<br>树莓派的这个发行版的网络组件和其他发行版不一样。一般linux首先读取/etc/network/interfaces，剩下没有被管理的网络接口被network-manager管理。<br>树莓派的网络也使用了networkmanager，而不使用interfaces文件，下面是树莓派默认的/etc/network/interfaces</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line"></span><br><span class="line"># Please note that this file is written to be used with dhcpcd</span><br><span class="line"># For static IP, consult &#x2F;etc&#x2F;dhcpcd.conf and &#39;man dhcpcd.conf&#39;</span><br><span class="line"></span><br><span class="line"># Include files from &#x2F;etc&#x2F;network&#x2F;interfaces.d:</span><br><span class="line">source-directory &#x2F;etc&#x2F;network&#x2F;interfaces.d</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而它include的/etc/network/interfaces.d是一个空文件夹，所以raspbian是不用interfaces的。<br>任何修改/etc/network/interfaces的教程现在都已经过时了，修改该文件会造成兼容性问题，具体表现在桌面右上角的图标失灵，不能正常管理网络。<br>桌面右上角的网络管理的图标比较简陋，软件包名称是lxplug-network，根据名字可以知道，这个应该是lxde的插件，不过肯定是用在raspbian的pixel桌面上的，而且lxplug- 还是一个系列，还包括蓝牙什么的，它在github上的链接是<br><a href="https://github.com/raspberrypi-ui/lxplug-network">https://github.com/raspberrypi-ui/lxplug-network</a><br>听说原开发者已经退休了。。。<br>当右上角的图标失灵时，显示Connection to dhcpcd lost. 点击显示No wireless interface found.<br>这里可以看出它管理网络使用的是dhcpcd，c代表client，d是deamon守护进程。<br>下面这个帖子在小白互助的时候，一位大神出来说了一句技术内幕。看来有关树莓派的问题还是到官方论坛搜索比较好，接触全球的帖子。<br><a href="https://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;t=242721&amp;p=1482723&amp;hilit=/etc/network/interfaces+mac+random#p1482723">https://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;t=242721&amp;p=1482723&amp;hilit=%2Fetc%2Fnetwork%2Finterfaces+mac+random#p1482723</a><br>其中关键的一句：<br>dhcpcd has a wpa_supplicant hook in Stretch.<br>Stretch是Debian9的代号现在都到debian10 buster了。<br>也就是说，这个管理程序还是用的是wpasupplicant，不是让你去interfaces里点名用wpasupplicant，而是它在dhcpcd里面它自己调用！用wpagui也可以管理到！<br>至于静态ip，树莓派的桌面环境可以设置。而且如果想在配置文件配置也是在dhcpcd.conf里配置。<br><a href="https://www.jianshu.com/p/bd918ef98a4d">https://www.jianshu.com/p/bd918ef98a4d</a></p>
<p>其他相关页面<br><a href="https://wiki.lxde.org/en/LXNM">https://wiki.lxde.org/en/LXNM</a><br><a href="https://wiki.lxde.org/en/LXDE-Qt">https://wiki.lxde.org/en/LXDE-Qt</a></p>
<h2 id="换tuna源"><a href="#换tuna源" class="headerlink" title="换tuna源"></a>换tuna源</h2><p>虽然树莓派基金会的镜像也能用，但是还是清华的快一些。<br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</a></p>
<h2 id="dump镜像"><a href="#dump镜像" class="headerlink" title="dump镜像"></a>dump镜像</h2><p>树莓派还是不要用太大的sd卡，完全没必要。现在因为不想以后换系统的时候重新配置文件，现在打算直接把整个sd卡做个镜像压缩一下。8g其实完全足够了。我用的32g的卡，为了省空间，打算先压缩分区大小再dump出来。</p>
<ol>
<li>fsck磁盘检查<br>要把树莓派关机，把卡拿下来，去别的linux系统上检查<br>sudo fsck /dev/sda2 -f<br>使用-f强制检查但是我检查了，还是后面报有node不对，忘了之前是怎么搞的了</li>
<li>使用diskgenius压缩分区。<br>gparted还真的不容易做压缩分区，看来还是diskgenius好啊</li>
</ol>
<p>一不小心用了这个感觉挺危险的办法：<br><a href="https://access.redhat.com/articles/1196333">https://access.redhat.com/articles/1196333</a><br><a href="https://askubuntu.com/questions/780284/shrinking-ext4-partition-on-command-line">https://askubuntu.com/questions/780284/shrinking-ext4-partition-on-command-line</a><br>还要删除分区再建立。。。</p>
<p>之后构建img文件还是使用win32diskimager，没办法，没什么其他好软件。<br>不过可以勾选只备份已有分区，挺好，没想到小工具能做到这么实用，我要是也能写出这样的工具就好了。</p>
<h2 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h2><p>windows 清除登录密码<br>加上选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min protocol &#x3D; SMB3</span><br><span class="line">security &#x3D; user</span><br></pre></td></tr></table></figure>

<p>debug samba</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service smbd stop</span><br><span class="line">sudo smbd -F -S -d&#x3D;10</span><br></pre></td></tr></table></figure>
<p>此时再连接, 就可以看到debug信息了.</p>
<p>关键配置1 要加密或者签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server signing &#x3D; mandatory</span><br><span class="line">smb encrypt &#x3D; mandatory</span><br></pre></td></tr></table></figure>
<p>关键配置2 guest account 要手动设置</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>raspberrypi</tag>
        <tag>raspbian</tag>
      </tags>
  </entry>
  <entry>
    <title> 烽火HG6201M交叉编译transmission成功!!</title>
    <url>/2019/HG6201m%E5%85%89%E7%8C%AB%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="烽火HG6201M交叉编译transmission成功"><a href="#烽火HG6201M交叉编译transmission成功" class="headerlink" title="烽火HG6201M交叉编译transmission成功!!"></a>烽火HG6201M交叉编译transmission成功!!</h1><p>我家本来wifi是靠二楼的路由器的，后来发现光猫可以发射wifi，没想到三楼的光猫信号比二楼的wifi还好！！<br>自从看到了这个光猫的账号密码，而且光猫带usb接口，登进去发现内存和cpu都很不错，而且自带samba文件共享！！顿时我对这款光猫就陷入了无尽的崇拜,甚至想再买一块来当开发板玩。</p>
<p>最近用惯了samba共享硬盘做nas，而且手头刚好有一个功率更大的和光猫电源相同dc头的12v电源，也不用怕硬盘供电不足了哈哈哈。正好硬盘盒有多，直接一个usb接上去。</p>
<p>bt做种本来有很多大文件，我用fat32的文件系统被4g的限制卡住肯定不行，我直接接我的硬盘，NTFS分区不能识别，我就想着编译一个ntfs-3g进去，但是后来没想到这光猫居然支持ntfs！！只不过不支持GPT的分区表，我改成MBR的分区表就成了，插上去自动识别！！连接后自动挂载到/mnt下，usb1_n这种格式！！不过没想到它似乎不支持ext系列文件系统。</p>
<p>接下来就是编译transmission了，为了transmission，还要编译各种它的依赖，curl，openssl什么的。openssl的动态库在光猫里有，但是因为没有头文件不能用在transmission里。。。我只能从头开始，先想办法安装旧版本的gcc，然后还不能直接上最新版本，各种挑选合适的旧版本，编译zlib，openssl，curl，libevent，百度解决各种报错，最后终于编译出来了transmission。而且我想着有了curl就可以自己写脚本搞ddns了！最近光猫有了ipv6，这样我无论在哪里都可以访问我的NAS了哈哈哈（后来发现这个ipv6虽然是公网的，但经常ping不通，无语。不知道为什么，可能移动的ipv6的路由没做好？）<br>然而我高兴得太早了，一运行curl就说invalid instruction。依赖curl的transmission也是，会报错不能运行。现在看感觉可能和openssl没选好架构，没加-mtune 34kc这个编译选项有关系。<br>最简单的交叉编译还是GO语言的，windows下一个环境变量就搞定了，可以直接放过去跑。</p>
<p>最后我还是失去了兴趣，入了openwrt的设备做nas。</p>
<p>之前了解到buildroot这个东西，听说它先要编译一个gcc，再用新的gcc去编译libc，整个linux系统等等东西，感觉它编译的太多了会很麻烦，没想到这才是真正方便的方法啊！！！这几天搞了一下，很容易就成功了。然而我已经买了其他设备做nas了。只能希望能帮到其他想拿这个光猫做NAS的人吧。</p>
<p>这光猫的web端用的是java，印象里java是很大一个，很占内存的，它居然能跑起来，虽然不知道是不是标准版的。而且这光猫的cpu使用率感觉从来都是20%以下，一般只有个位数。内存好像也挺大的。我之前网有一段时间很卡，而且光猫的samba也，就一直在怀疑是不是光猫，后来发现是蓝牙</p>
<p>————光猫相关信息——<br><a href="https://www.right.com.cn/forum/thread-783839-1-1.html">https://www.right.com.cn/forum/thread-783839-1-1.html</a><br>光猫各个挂载点都满了，几M的空间都没有，除了/osgi目录，大概有50M的空间？不记得了。编译好的东西可以放在这里或者直接放在挂载的硬盘或者优盘上面。</p>
<p>在根目录下面到处翻，还是能找到很多他们开发系统的信息的，要是没找到他们用的buildroot和linux内核版本，我可能就不会搞这个编译了。</p>
<p>好像是MTK的什么CPU，没有什么路由器用同款。<br>光猫是MIPS架构 大端序 mips32v2 34kc架构</p>
<p>下面是翻到的一些关键信息：<br>2017108-SmartHG_MTK7526_Engineering_CMCC-coverity<br>Linux (none) 2.6.36-svn159641 #15 SMP Thu Nov 2 10:18:12 CST 2017 mips unknown<br>mips-linux-glibc-4.9.3<br>proj/mtk04854/glibc-4.9.3/buildroot-2015.08.1/output/build/glibc-2.20/build/csu/start.o</p>
<p>——–编译过程————<br>我顺便上传下我的build-root的.config文件。<br>用别人的二进制文件确实不好，万一被下了毒呢。不过我还是把我编译好的上传一下，毕竟自己之前也想下载别人编译好的。<br>总之用ubuntu，去buildroot官网下载2015.08.1的版本，然后解压，把.config文件覆盖进去，就可以编译了。主要是选择对mips32，再选v2架构，toolchain里选2.6.36内核头文件<br>如果选glibc-4.9.3，它要求动态编译，我想了想还是选了静态编译，用uglibc，反正静态编译不需要加载库，这个版本不一样没关系。<br>gcc里面我勾选了c++支持和宽字符支持（不选宽字符可以少一个报错），nano需要宽字符。然后再勾选想要的包。直接选transmission，我还选了nano，vi一直懒得学用得不习惯。然后看什么顺眼就选了什么。我瞎选了很多包，导致要下载很多东西。<br>还有一个地方选并行数，根据cpu线程数选吧，我选了8。类似于make -j8吧。<br>buildroot真是强啊，想要什么包选什么包<br>或者把我上传的.config文件放到目录下，相当于使用我的配置了，可以看着上面的图片在配置里删。然后直接make。<br>接下来就是解决下载国外网站的网速问题了。可以考虑先全部下载好放到dl文件夹里面。省的卡在那里。不过这些源码包都挺小的。<br>或者有条件的直接proxychains -q make</p>
<p>这里会遇到几个报错，直接按顺序给出对应的解决网址：大家见招拆招吧</p>
<ol>
<li>一开头就遇到的host-m4什么的错误<br><a href="https://blog.csdn.net/Jun626/article/details/104870430">https://blog.csdn.net/Jun626/article/details/104870430</a></li>
<li>uclibc的宽字符的报错（不选宽字符就不会有吧）：<br><a href="https://dev.archive.openwrt.org/ticket/13095.html">https://dev.archive.openwrt.org/ticket/13095.html</a><br>这个需要下载patch打patch -p1</li>
<li>gcc-final的<br><a href="https://unix.stackexchange.com/questions/335717/how-to-handle-error-compiling-gcc-4-7-0-using-gcc-6-2-1">https://unix.stackexchange.com/questions/335717/how-to-handle-error-compiling-gcc-4-7-0-using-gcc-6-2-1</a></li>
</ol>
<p>我编译了算是2.5次，一次是编译的动态库，顺便也发出来吧，后面又觉得要选宽字符。大概率不会遇到什么其他的报错了。<br>跑起来挺快的。不包括解决报错的时间只花了半小时不到。</p>
<p>——–光猫的samba——-<br>ps一下就可以看到运行的smbd的路径，也可以找到改密码的smbpasswd。这里的用户好像要和linux系统中的用户对应，但是不好创建用户，所以推荐使用root用户，好像是smbpasswd-aroot然后就可以设置密码。然后在配置文件里面允许下root登录。因为感觉不设密码还是不安全</p>
<p>下面贴出我光猫samba的配置文件。之前配的时候看日志发现不能设置charset，因为编译的时候就不支持其他charset。我也不记得改了哪里了，应该能用吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">smbpasswdfile&#x3D;&#x2F;flash&#x2F;cfg&#x2F;app_conf&#x2F;samba&#x2F;smbpasswd</span><br><span class="line">workgroup&#x3D;WORKGROUP</span><br><span class="line">guestaccount&#x3D;root</span><br><span class="line">netbiosname&#x3D;Fiberhome-samba_test</span><br><span class="line">serverstring&#x3D;SambaServer</span><br><span class="line">dnsproxy&#x3D;no</span><br><span class="line">#displaycharset&#x3D;cp936</span><br><span class="line">#unixcharset&#x3D;UTF-8</span><br><span class="line">#doscharset&#x3D;cp936</span><br><span class="line">loglevel&#x3D;0</span><br><span class="line">logfile&#x3D;&#x2F;dev&#x2F;null</span><br><span class="line">interfaces&#x3D;0.0.0.0&#x2F;0[::]&#x2F;0</span><br><span class="line">loadprinters&#x3D;no</span><br><span class="line">security&#x3D;user</span><br><span class="line">socketoptions&#x3D;TCP_NODELAYSO_RCVBUF&#x3D;65536SO_SNDBUF&#x3D;65536</span><br><span class="line">usesendfile&#x3D;yes</span><br><span class="line">deadtime&#x3D;5</span><br><span class="line">[usbshare]</span><br><span class="line">comment&#x3D;AllStoragedevices</span><br><span class="line">forceuser&#x3D;root</span><br><span class="line">forcegroup&#x3D;root</span><br><span class="line">public&#x3D;no</span><br><span class="line">writable&#x3D;yes</span><br><span class="line">browseable&#x3D;yes</span><br></pre></td></tr></table></figure>


<hr>
<p>其实这些编译的东西我没有全部测试，毕竟已经买了openwrt做NAS，我就用了下curl是正常的，使用https需要设置-cacert到旁边的etc/ssl/certs/ca-certificates.crt。感觉应该能用，不会真的打脸翻车，又报invalid instruction吧，不过跑transmission需要自己搞一个配置文件，启动的时候设置好配置文件夹的路径。<br>顺便还编译了nginx<br>建议使用前做好备份，万一误删了什么就不好了。<br>这里都是静态编译的，直接把想要的复制出来放到优盘里，再插上光猫，开启telnet进去启动。比如transmission-daemon复制出来，在旁边的文件夹放好配置文件，启动的时候加上参数。<br>可以加上自己的开机启动脚本。开机自动启动一下transmission，然后再自己写个ddns脚本更新ipv6地址。参考：<a href="https://hotfeel.me/?p=119">https://hotfeel.me/?p=119</a></p>
]]></content>
  </entry>
  <entry>
    <title> Java复习笔记</title>
    <url>/2019/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Java复习笔记"><a href="#Java复习笔记" class="headerlink" title="Java复习笔记"></a>Java复习笔记</h1><ol>
<li>各种数据类型的存储范围<a id="more"></a>

</li>
</ol>
<h3 id="下面摘自清华的java慕课课件"><a href="#下面摘自清华的java慕课课件" class="headerlink" title="下面摘自清华的java慕课课件"></a>下面摘自清华的java慕课课件</h3><ol start="2">
<li><p>标识符<br>▫ 标识符是一个名称，与内存中的某个位置（地址）<br>相对应<br>▫ 标识符的第一个字符必须是下列字符之一：<br> 大写字母 (A-Z)<br> 小写字母 (a-z)<br> 下划线(_)<br> 美元符号 ($)<br>▫ 标识符的第二个字符及后继字符必须是：<br> 上述列表中的任意字符<br> 数字字符 (0-9)</p>
</li>
<li><p>数值型文字量<br>数据类型 文字量<br>byte,short,int 十进制数，开头不为0；0X跟十六进制数，如0XF1C4；<br>0跟八进制数，如0726<br>long 同上，但后面跟l或L，如：84l，0X1F39L<br>float 数字后跟f或F，如1.23456F，1.893E2F<br>double 后面可选d或D做后缀，如：1.23D<br>boolean true或false</p>
</li>
<li><p>扩展转换<br>▫ byte, char, short, int, long, float, double<br>▫ 从一种整数类型到另一种整数类型，或者从<br>float到double的转换不损失任何信息<br>▫ 从整数类形向float或double转换，会损失精度<br>• 窄化转换<br>▫ double, float, long, int, short, byte,char<br>▫ 窄化转换可能会丢失信息</p>
</li>
<li><p>隐含转换<br>▫ 赋值转换<br> 将表达式类型转换为制定变量的类型<br>▫ 方法调用转换<br> 适用于方法或构造方法调用中的每一个参数<br>▫ 字符串转换<br> 任何类型（包括null类型）都可以转换为字符串类型<br> 只当一个操作数是String类型时，<br>适用于+运算符的操作数</p>
</li>
<li><p>数组是对象<br>▫ 动态初始化<br>▫ 可以赋值给Object类型的变量<br>▫ 在数组中可以调用类Object 的所有方法<br>▫ 每个数组都有一个由 public final 修饰的成员变量：<br>length ，即数组含有元素的个数（length可以是正<br>数或零）</p>
</li>
</ol>
<p>注：声明新数组时的new也一样说明了数组是一个Object<br><code>arrayName=new Type[componets number];</code><br>这里数组也像其他类一样做了自己的初始化（给自己分配空间）。</p>
<ol start="7">
<li>两种数组<br>基本类型数组的每个元素都是一个基本类型的变<br>量；引用类型数组的每个元素都是对象的的引用</li>
</ol>
<p>创建数组的时，如果没有指定初始值，数组<br>便被赋予默认值初始值。<br>▫ 基本类型数值数据，默认的初始值为0；<br>▫ boolean类型数据，默认值为false;<br>▫ 引用类型元素的默认值为null。</p>
<ol start="8">
<li><p>复制数组<br><code>public static void arraycopy(Object source , int srcIndex ,Object dest , int destIndex , int length ) </code></p>
</li>
<li><p>数组的数组<br><code>int[ ][ ] myArray = new int[3][5] ;</code><br>我之前错误的理解方式是int[3]作为一个类型，int[3][5]就是5个长3的数组。<br>但是还是python的理解方式对<br><code>myArray = [int[5],int[5],int[5]]</code><br>所以无论是new后面的int[3][5],还是取值时的myArray[2][4],都表示取出。int[3]表示第一次可以取三个，从0到2，myArray[2][4]表示先取第三个再取第五个。<br>现在回首发现好像所有的语言数组都是这样的，行优先</p>
</li>
<li><p>switch<br>switch-expression、常量值value1到valueN必须是整形或字符型<br>但是最近好像增加了对string的支持</p>
</li>
<li><p>逗号<br>java里不用逗号符，但是可以用于for语句里面的分隔</p>
</li>
<li><p>可变长参数<br>• 可变长参数使用省略号表示，其实质是数组。<br>• 例如，“String … s”表示“String[] s” 。<br>• 对于具有可变长参数的方法，传递给可变长参数的实际参数可以是<br>零个到多个对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static double maxArea(Circle c, Rectangle... varRec) &#123;</span><br><span class="line">Rectangle[] rec &#x3D; varRec;</span><br><span class="line">for (Rectangle r : rec) &#123;</span><br><span class="line">&#x2F;&#x2F;…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>包<br>一个包可以包含若干个类文件，还可包含若干个包</p>
</li>
<li><p>编译单元<br>• 一个Java源代码文件称为一个编译单元，由三部分组成：<br>▫ 所属包的声明（省略，则属于默认包）；<br>▫ Import （引入）包的声明，用于导入外部的类；<br>▫ 类和接口的声明。<br>• 一个编译单元中只能有一个public类，该类名与文件名相同，编译<br>单元中的其他类往往是public类的辅助类，经过编译，每个类都会<br>产一个class文件。</p>
</li>
</ol>
<p>注：所以并不是一个文件只存一个类，而是只让存一个public类</p>
<ol start="15">
<li><p>类的成员访问权限控制<br>公有(public)<br>▫ 可以被其他任何方法访问(前提是对类成员所属的类有访问权限)<br>• 保护(protected)<br>▫ 只可被同一类及其子类的方法访问<br>• 私有(private)<br>▫ 只可被同一类的方法访问<br>• 默认(default)(无修饰)<br>▫ 仅允许同一个包内的访问；又被称为“包（package)访问权限”<br>注：主要不记得最后的默认</p>
</li>
<li><p>构造方法内的this关键字<br>• 可以使用this关键字在一个构造方法中调用另外的构造方法；<br>• 代码更简洁，维护起来也更容易；<br>• 通常用参数个数比较少的构造方法调用参数个数最多的构造方法。</p>
</li>
<li><p>对象的自动回收<br>• 无用对象<br>▫ 离开了作用域的对象；<br>▫ 无引用指向对象。<br>• Java运行时系统通过垃圾收集器周期性地释放无用对象所使用的内存。<br>• Java运行时系统会在对对象进行自动垃圾回收前，自动调用对象的finalize()方法。</p>
</li>
<li><p>finalize()方法<br>• 在类java.lang.Object中声明，因此 Java中的每一<br>个类都有该方法：<br>protected void finalize() throws throwable<br>• 用于释放资源。<br>• 类可以覆盖（重写）finalize()方法。<br>• finalize()方法有可能在任何时机以任何次序执行。</p>
</li>
<li><p>枚举类<br>特点：<br>一、 只有有限个实例化的对象</p>
</li>
</ol>
<p>–&gt;可以用==判断<br>  所有枚举类型都隐含继承（扩展）自java.lang.Enum，因此枚举类型不能再继承其他任何类<br>  枚举类型的构造方法必须是包内私有或者私有的。定义在枚举开头的常量会被自动创建，不能显式地调用枚举类的构造方法。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Planet &#123;</span><br><span class="line">MERCURY (3.303e+23, 2.4397e6),</span><br><span class="line">VENUS (4.869e+24, 6.0518e6),</span><br><span class="line">EARTH (5.976e+24, 6.37814e6),</span><br><span class="line">MARS (6.421e+23, 3.3972e6),</span><br><span class="line">JUPITER (1.9e+27, 7.1492e7),</span><br><span class="line">SATURN (5.688e+26, 6.0268e7),</span><br><span class="line">URANUS (8.686e+25, 2.5559e7),</span><br><span class="line">NEPTUNE (1.024e+26, 2.4746e7);</span><br><span class="line">private final double mass; &#x2F;&#x2F; in kilograms</span><br><span class="line">private final double radius; &#x2F;&#x2F; in meters</span><br><span class="line">Planet(double mass, double radius) &#123;</span><br><span class="line">this.mass &#x3D; mass;</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line">private double mass() &#123; return mass; &#125;</span><br><span class="line">private double radius() &#123; return radius; &#125;</span><br><span class="line">&#x2F;&#x2F; universal gravitational constant (m3 kg-1 s-2)</span><br><span class="line">public static final double G &#x3D; 6.67300E-11;</span><br><span class="line">double surfaceGravity() &#123;</span><br><span class="line">return G * mass &#x2F; (radius * radius);</span><br><span class="line">&#125;</span><br><span class="line">double surfaceWeight(double otherMass) &#123;</span><br><span class="line">return otherMass * surfaceGravity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举型变量可以带自己的操作方法，甚至构造方法，但是只能在声明时调用构造方法，从而只有有限个实例对象。</p>
<ol start="20">
<li><p>通配符泛型<br>•使用通配符 可以使程序更为通用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ShowType &#123;</span><br><span class="line">public void show (GeneralType&lt;?&gt; o)&#123;</span><br><span class="line">    System.out.println(o.getObj().getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有限制的泛型<br>•在参数“ Type” 后面使用“ extends” 关键字并加上类名或接口名，表明参数所代表的类型必须是该类的子类或者实现了该接口<br>▫注意，对于实现了某接口的有限制泛型，也是使用 extends 关键字，而不是 implements 关键字</p>
</li>
<li><p>构造方法中调用多态方法<br>•在构造方法内调用准备构造的那个对象的动态绑定方法<br>▫被调用方法要操纵的成员可能尚未得到正确的初始化<br>▫可能造成一些难于发现的程序错误<br>所以要注意<br>•用尽可能少的动作把对象的状态设置好；<br>•如果可以避免，不要调用任何方法；<br>•在构造方法内唯一能够安全调用的是在超类中具有 final 属性的那些方法（也适用于 private 方法，它们自动具有 final 属性）。这些方法不能被覆盖，所以不会出现前述的潜在问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title> unlink</title>
    <url>/2019/unlink/</url>
    <content><![CDATA[<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>程序里肯定会有指向堆块的地址. 而在我们的组织堆块的链表里面也是保存的堆块地址, 能否让堆块以为程序里这保存的地址是其他的堆块指向他的呢?</p>
<p>在双向链表里面, 堆块们通过链表的形式排队. 当有堆块要离开的时候, 他就要进行工作交接, 否则一走了之的话链表就断了.</p>
<p>工作交接具体是两个内容, 和前面的链表说, 你后面的兄弟不再是我了, 我要走了, 这是我后面的兄弟, 它以后才是你后面的兄弟了, 向后找的时候去找它.<br>同样和后面的兄弟说要照顾好原来自己前面的堆块<br>也就是让forword块保管好自己的back指针, 让back块保管好自己的forward指针.</p>
<p>由于堆块经常被骗, 他们只好长个心眼, 不能改了别人的指针.<br>让后面的堆块照顾好自己前面的堆块时, 需要修改的是后面的堆块的fd指针, 这个指针原来的值就是堆块自己. 让前面的堆块照顾好自己后面的堆块时, 需要修改的是前面的堆块的bk指针, 这个指针原来的值就是堆块自己. 如果不是自己, 就肯定是被骗了, 这时候堆块就报警了, 程序就报错了</p>
<p>这里先讲一个任意地址写的故事, 程序会分配堆块, 自己保存好堆块指针, 需要数据就根据堆块指针去找, 如果我们能够随意改写堆块指针, 不就可以达到想写(读)哪里就写哪里的效果了吗? 那怎么改写呢? 我们先放开这个问题</p>
<p>但是unlink, 并没有这么简单, 我们接下来仔细分析一下<br>程序里面指向堆块的指针和libc里用的不太一样, 程序里是指向堆块的内容, 而libc里则是堆块结构体的头部, 向前偏移了0x10字节.<br>另外就是一般利用的是前向合并时的unlink. 当free一个堆块, 会前后检查free的堆块, 合并起来, 这样就不会有相邻的free块. 而free的块肯定都是在bins里的, 而且不是fastbin, 因为fastbin的块没有标成free.<br>所以free一个堆块的时候, 前向合并前一个堆块的时候, 就要把前面的堆块从链表里拿出来, 合并完再放到合适的链表里.<br>利用unlink时, 我们利用堆溢出漏洞, 修改unlink块溢出到下一块, 去除previous in use bit, 并伪造prev size, 这里伪造的size要小0x10字节, 刚好是用户内容域, 伪造的堆块小10字节也是为了和程序内指向堆块内容的指针合作.<br>这样free后面的块的时候, 就会对前面的伪造的小一号的堆块进行unlink, 所以unlink时伪造堆块的fd和bk指针指向哪里?<br>回顾之前的知识, 可以知道,<br>fd 的bk(+0x18) = 自己(堆块指针)<br>bk 的fd(+0x10) = 自己(堆块指针)<br>反过来<br>fd = 自己指针 - 0x18<br>bk = 自己指针 - 0x10</p>
<p>效果就是把自己指针先改成自己的bk, 再改成自己的fd, 即自己的指针指向了 自己指针 - 0x18 这个地址可不得了, 不是堆段了, 而是程序数据域了, 旁边很可能就是其他堆块的指针, 去改他们就可以任意地址写了</p>
<p>作用: UAF-&gt;溢出<br>要求: 修改free的堆块, 知道另外一处指向堆块的指针</p>
<h1 id="虚假堆快"><a href="#虚假堆快" class="headerlink" title="虚假堆快"></a>虚假堆快</h1><p>需要能错位header, 再使用fastbin attack</p>
<p>错位到main_arena 改写top chunk地址, 达到任意分配堆块的目的</p>
]]></content>
  </entry>
  <entry>
    <title> main函数启动与POSIX-ABI</title>
    <url>/2019/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E4%B8%8EPOSIX-ABI/</url>
    <content><![CDATA[<h1 id="main函数启动与POSIX-ABI"><a href="#main函数启动与POSIX-ABI" class="headerlink" title="main函数启动与POSIX-ABI"></a>main函数启动与POSIX-ABI</h1><a id="more"></a>

<p><a href="https://0xax.gitbooks.io/linux-insides/content/Misc/linux-misc-4.html">https://0xax.gitbooks.io/linux-insides/content/Misc/linux-misc-4.html</a><br>这篇文章不错</p>
<p><a href="https://embeddedartistry.com/blog/2019/04/08/a-general-overview-of-what-happens-before-main/">https://embeddedartistry.com/blog/2019/04/08/a-general-overview-of-what-happens-before-main/</a><br>这篇文章的拓展阅读不少好东西：<br><a href="https://lwn.net/Articles/631631/">https://lwn.net/Articles/631631/</a></p>
<h2 id="初始时的栈布局"><a href="#初始时的栈布局" class="headerlink" title="初始时的栈布局"></a>初始时的栈布局</h2><p><a href="https://luomuxiaoxiao.com/?p=516">https://luomuxiaoxiao.com/?p=516</a><br>这篇文章也不错</p>
<blockquote>
<p>3.2.1 首先，_start是如何启动的？<br>当你执行一个程序的时候，shell或者GUI会调用execve()，它会执行linux系统调用execve()。如果你想了解关于execve()函数，你可以简单的在shell中输入man execve。这些帮助来自于man手册（包含了所有系统调用）的第二节。简而言之，系统会为你设置栈，并且将argc，argv和envp压入栈中。文件描述符0，1和2（stdin, stdout和stderr）保留shell之前的设置。加载器会帮你完成重定位，调用你设置的预初始化函数。当所有搞定之后，控制权会传递给_start()，下面是使用objdump -d prog1输出的_start函数的内容：</p>
</blockquote>
<p>所以程序的运行过程就是，系统把elf的规定好的几个段加载进去，然后从_start(entry_point)运行。但是这时候，难道栈上什么都没有吗？<br>为了探究在进入entry_point时候的栈上的数据，看x86-64-ps-ABI.pdf。<br>在Low Level Interface &gt; Process Initialization &gt; Initial Stack and Register State这里的图3-9就表示了初始化时的栈布局：<br>这里先提一下寄存器的布局，除了rsp和rdx其他的寄存器的内容都是未定义的。其中rbp被点明需要清零，rdx是需要注册到退出前的函数的（application should register it with atexit）(BA_OS).这里观察到是_dl_fini。r13寄存器的值观察到和rsp一样，r12和rip一样。r9指向0x400000,rsi指向一个ld.so的数据段下方的无名地址。rax我还以为是execve的系统调用号，很可惜不是，而是0x1c。由于最先接管程序的反而是ld.so，所以这里的数据是什么在于它最后做了什么。而且栈的低地址方向上还有不少各种各样的数据，估计也是它的。有大概0xd10 3344字节的脏数据。。。<br><img src="../imgs/psABIstack.png" alt="stack layout"><br>总之栈初始时是有东西的，而且还不少！随便找一个64位的程序用gdb打开，start自动停在入口点，就可以看到：<br>从低地址到高地址，首先rsp指向的是 argument count，接下来是对应数量的参数指针，接着是参数和环境变量之间的8字节空白分隔，<br>接下来是环境变量的指针数组，libc的全局变量environ就是指向这里。key和value没有分开，在同一个字符串里面用等于号连接。这样每一个指针就指向一个带等于号的字符串。然后又是一个8字节的0分隔。（可想而知如果程序简单，main函数的栈只有几十字节大小，环境变量数组很容易就被溢出了，导致调用system失败。。。）<br>接下来是一些不明意义的数据，叫做Auxiliary vector entries，每个16字节，前8字节是类型，后8字节是内容。这里接下来好像是0x18字节的分隔？<br><a href="https://lwn.net/Articles/519085/">https://lwn.net/Articles/519085/</a> 可以通过getauxval()这个libc的函数调用获得<br>我对照着表把这次运行的flag都标注了一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24:0120│          0x7fffffffe380 ◂— 0x21 &#x2F;* &#39;!&#39; *&#x2F; AT_SYSINFO_EHDR？</span><br><span class="line">25:0128│          0x7fffffffe388 —▸ 0x7ffff7ffa000 ◂— jg     0x7ffff7ffa047 # vdso 的地址。 link：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;071358f497ea</span><br><span class="line">26:0130│          0x7fffffffe390 ◂— 0x10 AT_HWCAP</span><br><span class="line">27:0138│          0x7fffffffe398 ◂— 0x78bfbff  an bitmask of CPU features. It mask to the value returned by CPUID 1.EDX.</span><br><span class="line">28:0140│          0x7fffffffe3a0 ◂— 0x6 AT_PAGESZ</span><br><span class="line">29:0148│          0x7fffffffe3a8 ◂— 0x1000 in bytes. 这就是为什么加载时最后三位都是0吧</span><br><span class="line">2a:0150│          0x7fffffffe3b0 ◂— 0x11 AT_CLKTCK</span><br><span class="line">2b:0158│          0x7fffffffe3b8 ◂— 0x64 &#x2F;* &#39;d&#39; *&#x2F;  contains the frequency at which times() increments.</span><br><span class="line">2c:0160│          0x7fffffffe3c0 ◂— 0x3 AT_PHDR</span><br><span class="line">2d:0168│          0x7fffffffe3c8 —▸ 0x400040 ◂— 0x500000006 给脚本文件开头的#!&#x2F;bin&#x2F;bash之类的用的， tells the interpreter where to find the program header table in the memory image.</span><br><span class="line">2e:0170│          0x7fffffffe3d0 ◂— 0x4 AT_PHENT </span><br><span class="line">2f:0178│          0x7fffffffe3d8 ◂— 0x38 &#x2F;* &#39;8&#39; *&#x2F;  the size, in bytes, of one entry in the program header table to which the AT_PHDR entry points.</span><br><span class="line">30:0180│          0x7fffffffe3e0 ◂— 0x5 AT_PHNUM</span><br><span class="line">31:0188│          0x7fffffffe3e8 ◂— 9 &#x2F;* &#39;\t&#39; *&#x2F; the number of entries in the program header table to which the AT_PHDR entry points.</span><br><span class="line">32:0190│          0x7fffffffe3f0 ◂— 0x7 AT_BASE</span><br><span class="line">33:0198│          0x7fffffffe3f8 —▸ 0x7ffff7dd5000 ◂— jg     0x7ffff7dd5047 holds the base address at which the interpreter program was loaded into memory. 这里是ld.so的地址</span><br><span class="line">34:01a0│          0x7fffffffe400 ◂— 0x8 AT_FLAGS</span><br><span class="line">35:01a8│          0x7fffffffe408 ◂— 0x0 一些flag位，但暂时没有用？？</span><br><span class="line">36:01b0│          0x7fffffffe410 ◂— 9 &#x2F;* &#39;\t&#39; *&#x2F; AT_ENTRY</span><br><span class="line">37:01b8│          0x7fffffffe418 —▸ 0x400470 (_start) ◂— xor    ebp, ebp # the entry point of the application program to which the interpreter program should transfer control.这就是entry_point的地址 </span><br><span class="line">38:01c0│          0x7fffffffe420 ◂— 0xb &#x2F;* &#39;\x0b&#39; *&#x2F; AT_UID </span><br><span class="line">39:01c8│          0x7fffffffe428 ◂— 0x3e8 the real user id of the process.</span><br><span class="line">3a:01d0│          0x7fffffffe430 ◂— 0xc &#x2F;* &#39;\x0c&#39; *&#x2F; AT_EUID</span><br><span class="line">3b:01d8│          0x7fffffffe438 ◂— 0x3e8 the effective user id of the process.</span><br><span class="line">3c:01e0│          0x7fffffffe440 ◂— 0xd &#x2F;* &#39;\r&#39; *&#x2F; AT_GID</span><br><span class="line">3d:01e8│          0x7fffffffe448 ◂— 0x3e8</span><br><span class="line">3e:01f0│          0x7fffffffe450 ◂— 0xe AT_EGID</span><br><span class="line">3f:01f8│          0x7fffffffe458 ◂— 0x3e8</span><br><span class="line">40:0200│          0x7fffffffe460 ◂— 0x17 AT_SECURE </span><br><span class="line">41:0208│          0x7fffffffe468 ◂— 0x0 if the program is in secure mode (for example started with suid). Otherwise zero.</span><br><span class="line">42:0210│          0x7fffffffe470 ◂— 0x19 AT_RANDOM</span><br><span class="line">43:0218│          0x7fffffffe478 —▸ 0x7fffffffe4c9 ◂— 0x3f2d4c26e658aa6f # 16 securely generated</span><br><span class="line">random bytes.</span><br><span class="line">44:0220│          0x7fffffffe480 ◂— 0x1a AT_HWCAP2</span><br><span class="line">45:0228│          0x7fffffffe488 ◂— 0x0 contains the extended hardware feature mask. Currently it is 0, but may contain additional feature bits in the future.</span><br><span class="line">46:0230│          0x7fffffffe490 ◂— 0x1f AT_EXECFN</span><br><span class="line">47:0238│          0x7fffffffe498 —▸ 0x7fffffffefbe ◂— 0x6667682f746e6d2f (&#39;&#x2F;mnt&#x2F;hgf&#39;) a pointer to the file name of the executed program.</span><br><span class="line">48:0240│          0x7fffffffe4a0 ◂— 0xf AT_PLATFORM</span><br><span class="line">49:0248│          0x7fffffffe4a8 —▸ 0x7fffffffe4d9 ◂— 0x34365f363878 &#x2F;* &#39;x86_64&#39; *&#x2F; a string containing the platform name.</span><br></pre></td></tr></table></figure>
<p>再往下就是一些数据了。比如保存环境变量的字符串，这里我居然看到了一个环境变量是SHELL=/bin/bash，如果能泄露到这个变量，那连输入/bin/sh也不用愁了，不知道部署到服务器会怎么样。可能到docker里环境变量就全没了吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; find 0x7fffffffe260, 0x7ffffffff000-1, &quot;sh&quot;</span><br><span class="line">0x7fffffffeda6</span><br><span class="line">1 pattern found.</span><br></pre></td></tr></table></figure>
<p>我随便打开了一个程序，初始时的栈离底部是3488字节。</p>
<h2 id="sysdeps-x86-64-start-S函数"><a href="#sysdeps-x86-64-start-S函数" class="headerlink" title="sysdeps/x86_64/start.S函数"></a>sysdeps/x86_64/start.S函数</h2><p>32位：<br>首先清空ebp<br>再调用__libc_start_main，然后就是hlt这个指令，opcode是f4。。。这个难道不是让cpu停止工作的指令吗。。。<br>_start的函数代码在sysdeps/x86_64/start.S<br>这个hlt处的代码的注释写道：/* Crash if somehow `exit’ does return.     */<br>也就是说libc_start_main是不会返回的。因为它调用了exit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STATIC int</span><br><span class="line">LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),</span><br><span class="line">		 int argc, char **argv,</span><br><span class="line">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span><br><span class="line">		 ElfW(auxv_t) *auxvec,</span><br><span class="line">#endif</span><br><span class="line">		 __typeof (main) init,</span><br><span class="line">		 void (*fini) (void),</span><br><span class="line">		 void (*rtld_fini) (void), void *stack_end)</span><br></pre></td></tr></table></figure>
<p>参数有main函数，argc，argv，[辅助向量数组]，init函数 finit函数，rtld_finit函数，栈末尾指针<br>所以，当我们在rop中违法调用_start的时候，栈上的第一个数当成了argc，argv也错位了，剩下的参数还好</p>
<h2 id="csu-libc-start-c"><a href="#csu-libc-start-c" class="headerlink" title="csu/libc-start.c"></a>csu/libc-start.c</h2><p>__libc_start_main的主要功能：<br>处理关于setuid、setgid程序的安全问题<br>启动线程<br>把fini函数和rtld_fini函数作为参数传递给at_exit调用，使它们在at_exit里被调用，从而完成用户程序和加载器的调用结束之后的清理工作<br>调用其init参数<br>调用main函数，并把argc和argv参数、环境变量传递给它<br>调用exit函数，并将main函数的返回值传递给它</p>
<p>但是这里发现_start函数有一个很诡异的动作就是push rax push rsp。不知道是不是有意为之。总之栈上在argc上面就多了这两个数据。<br>其实是因为之前栈进行了对齐，这里push的rax是没有用的数据。而push的rsp是第七个参数stack_end指针，它要被放在栈上。rax就是为了保证对齐的。<br>接下来call __libc_start_main 栈上多了第一个返回地址。在argc上面一点点的__start+41这样的地址就是第一个返回地址。然而其实它并不会返回。</p>
<p>接下来则是dl去延迟绑定__libc_start_main。这里push了序号2和linkmap。之后进入_dl_runtime_resolve_xsavec它建立起了第一个栈。也就是说，这里保存了一个为0的rbp。所以按照栈帧回溯，最终是要回溯到0的。。。</p>
<p>我调试时发现源码上方写道忽略了fini参数，让fini参数在__cxa_atexit注册</p>
<h2 id="csu-elf-init-c-libc-csu-init"><a href="#csu-elf-init-c-libc-csu-init" class="headerlink" title="csu/elf-init.c (libc_csu_init)"></a>csu/elf-init.c (libc_csu_init)</h2><p>libc_start_main函数的init参数被设置成了csu_init函数。csu函数先是调用了_init函数，再是循环调用init_array的函数指针，传入的参数和main函数一样<br>这里的init函数也在程序中<br><img src="../imgs/startmaincallgraph.png" alt="start main call graph"></p>
<p>在我的ida中，它也叫init_proc。程序极其短，就算是汇编也没有几行。调用完gmon函数就完了，所以它也就是一个设置profiling的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub     rsp, 8          ; _init</span><br><span class="line">mov     rax, cs:__gmon_start___ptr</span><br><span class="line">test    rax, rax</span><br><span class="line">jz      short loc_592</span><br><span class="line">call    rax ; __gmon_start__</span><br><span class="line"></span><br><span class="line">loc_592:</span><br><span class="line">add     rsp, 8</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gmon_start函数。如果它是空的，我们跳过它，不调用它。否则，调用它来设置profiling。该函数调用一个例程开始profiling，并且调用at_exit去调用另一个程序运行,并且在运行结束的时候生成gmon.out。</p>
</blockquote>
<p>回到csu_init，看来还是靠csu，它去调用每个init array</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push    r15</span><br><span class="line">push    r14</span><br><span class="line">mov     r15, rdx</span><br><span class="line">push    r13</span><br><span class="line">push    r12</span><br><span class="line">lea     r12, __frame_dummy_init_array_entry # init array</span><br><span class="line">push    rbp</span><br><span class="line">lea     rbp, __do_global_dtors_aux_fini_array_entry # finit array的开始地址就是init array 的结束地址！</span><br><span class="line">push    rbx</span><br><span class="line">mov     r13d, edi</span><br><span class="line">mov     r14, rsi</span><br><span class="line">sub     rbp, r12 把init array的结束地址减去开始地址再除以8得到数组大小</span><br><span class="line">sub     rsp, 8</span><br><span class="line">sar     rbp, 3</span><br><span class="line">call    _init_proc # 调用init</span><br><span class="line">test    rbp, rbp</span><br><span class="line">jz      short loc_7B6 # 如果数组大小是0就提前跳转结束</span><br></pre></td></tr></table></figure>
<p>也就是csu_init 就是负责调用每一个init数组的。<br>那init数组里到底有什么？一般是frame_dummy<br>为什么csu结尾有那么多的pop? 这是为什么? 难道csu是用汇编写的??<br>其实不是, csu的源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_csu_init (<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* For dynamically linked executables the preinit array is executed by</span></span><br><span class="line"><span class="comment">     the dynamic linker (before initializing any shared object).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="comment">/* For static executables, preinit happens right before init.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> size = __preinit_array_end - __preinit_array_start;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__preinit_array_start [i]) (argc, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _init ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> size = __init_array_end - __init_array_start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__init_array_start [i]) (argc, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有pop可能只是编译器用到了太多寄存器去实现这个函数, 所以先保存在栈上吧….</p>
<p>在x86-64-psABI.pdf的Program Loading and Dynamic Linking里面的Dynamic Linking的最后部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.2.2 Initialization and Termination Functions</span><br><span class="line">The implementation is responsible for executing the initialization functions specified</span><br><span class="line">by DT_INIT, DT_INIT_ARRAY, and DT_PREINIT_ARRAY entries in</span><br><span class="line">the executable file and shared object files for a process, and the termination (or</span><br><span class="line">finalization) functions specified by DT_FINI and DT_FINI_ARRAY, as specified</span><br><span class="line">by the System V ABI. The user program plays no further part in executing the</span><br><span class="line">initialization and termination functions specified by these dynamic tags.</span><br></pre></td></tr></table></figure>
<h2 id="frame-dummy"><a href="#frame-dummy" class="headerlink" title="frame_dummy"></a>frame_dummy</h2><blockquote>
<p>接下来frame_dummy函数会被调用。其目的是调用__register_frame_info函数，但是，调用frame_dummy是为了给上述函数设置参数。这么做的目的是为了在出错时设置unwinding stack frames。<br>但是在我这ida里，它调用的是register_tm_clones<br><a href="https://stackoverflow.com/questions/41274482/why-does-register-tm-clones-and-deregister-tm-clones-reference-an-address-past-t">https://stackoverflow.com/questions/41274482/why-does-register-tm-clones-and-deregister-tm-clones-reference-an-address-past-t</a><br>原来这两个函数是gcc的函数，其实不是libc的，<br><a href="https://stackoverflow.com/questions/34966097/what-functions-does-gcc-add-to-the-linux-elf">https://stackoverflow.com/questions/34966097/what-functions-does-gcc-add-to-the-linux-elf</a></p>
</blockquote>
<p>总之它们是为了提供多线程的原子类操作transaction memory的，在这里其实就是什么也不干，不会调用_ITM_registerTMCloneTable</p>
<h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><p>csu_init结束返回</p>
<h2 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Functions that were registered with the atexit or on_exit functions are called in the reverse order of their registration. This mechanism allows your application to specify its own “cleanup” actions to be performed at program termination. Typically, this is used to do things like saving program state information in a file, or unlocking locks in shared data bases.</span><br><span class="line"></span><br><span class="line">All open streams are closed, writing out any buffered output data. See Closing Streams. In addition, temporary files opened with the tmpfile function are removed; see Temporary Files.</span><br><span class="line"></span><br><span class="line">_exit is called, terminating the program. See Termination Internals.</span><br></pre></td></tr></table></figure>
<p>把fini函数和rtld_fini函数作为参数传递给at_exit调用，使它们在at_exit里被调用</p>
<h2 id="其他：栈调用规范"><a href="#其他：栈调用规范" class="headerlink" title="其他：栈调用规范"></a>其他：栈调用规范</h2><p>这个规范里面有关函数调用的部分值得好好读读，下面是之前探究system函数rop调用失败的情况。有机会再补充。</p>
<p>The x86-64 System V ABI guarantees 16-byte stack alignment before a call, so libc system is allowed to take advantage of that for 16-byte aligned loads/stores.</p>
<p>找这个标准<br><a href="https://stackoverflow.com/questions/18133812/where-is-the-x86-64-system-v-abi-documented">https://stackoverflow.com/questions/18133812/where-is-the-x86-64-system-v-abi-documented</a><br>找到了<br><a href="https://github.com/hjl-tools/x86-psABI/tree/hjl/master">https://github.com/hjl-tools/x86-psABI/tree/hjl/master</a></p>
<p>下载下来看第18页，里面的图显示了需要在调用函数时对齐16字节。<br>也就是call的时候的push rip占了8字节，然后函数开头保存ebp占用8字节，刚好16字节。<br>所以只要遵循了这个函数调用就可以正常使用system函数了.</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title> 天枢的新手入门指南 Q&amp;A</title>
    <url>/2019/%E5%A4%A9%E6%9E%A2%E7%9A%84%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%20Q&amp;A/</url>
    <content><![CDATA[<p>这篇文章是2019年7月31日从天枢新人群里复制来的。增加自己博客的文章数</p>
<h1 id="天枢的新手入门指南-Q-amp-A"><a href="#天枢的新手入门指南-Q-amp-A" class="headerlink" title="天枢的新手入门指南 Q&amp;A"></a>天枢的新手入门指南 Q&amp;A</h1><h2 id="什么是天枢"><a href="#什么是天枢" class="headerlink" title="什么是天枢"></a>什么是天枢</h2><h3 id="天枢战队"><a href="#天枢战队" class="headerlink" title="天枢战队"></a>天枢战队</h3><a id="more"></a>
<blockquote>
<p>​     天枢战队是来自北京邮电大学（BUPT）的一群小伙伴组成的安全团队。队名“天枢”是北斗七星的第一颗星，它代表了聪慧和才能。核心团队有十五人左右，活跃在国内外大大小小的赛事上。大家聚在一起，乐于学习、研究和交流各个方向的安全技术，提高北邮信息安全氛围。</p>
<p>​    队员们专精的技能千奇百怪：手捏网线就能发包，口算sha256比2080ti还快，盯着字节码即可逆向操作系统，双击Chrome就能v8逃逸，通过人眼扫描面部即可微信添加好友等。</p>
</blockquote>
<h3 id="天枢社团"><a href="#天枢社团" class="headerlink" title="天枢社团"></a>天枢社团</h3><blockquote>
<p>​    天枢社团的主要作用就是向天枢战队输送新生力量，提高北邮的民间信息安全能力与氛围。定期组织CTF交流，提高自身的信息安全技能</p>
</blockquote>
<h3 id="如何加入天枢战队"><a href="#如何加入天枢战队" class="headerlink" title="如何加入天枢战队"></a>如何加入天枢战队</h3><p>天枢战队在每年5月底6月初会举办<code>TSCTF</code>邀请赛，在线上赛取得突出成绩，或者在其他比赛中有优异成绩即可进入天枢战队</p>
<h3 id="天枢社团的预想组织架构"><a href="#天枢社团的预想组织架构" class="headerlink" title="天枢社团的预想组织架构"></a>天枢社团的预想组织架构</h3><ul>
<li>中心组<ul>
<li>活动（负责相关活动的宣传，组织，评定，场地，以及后期的报销等事宜）//这里可能可以细分？</li>
<li>技术（负责相关活动的技术维护）</li>
</ul>
</li>
<li>XX战队（负责参加各种比赛，包括但不限于国赛，XCTF联赛等，人数大概维持在20人-30人左右）</li>
</ul>
<h3 id="天枢社团预想学习模式"><a href="#天枢社团预想学习模式" class="headerlink" title="天枢社团预想学习模式"></a>天枢社团预想学习模式</h3><ol>
<li>在开学初进行战队的初级选拔(大概招30人吧，我也不清楚)，主要选拔一些有基础，或者说感兴趣并想坚持的人。</li>
<li>开学之后会进行1-2个月左右的学习，然后进行选拔，抽取前20(概率还是挺大的)</li>
<li>每周面向全校（主要是战队）进行沙龙，不同方向和领域可以分开进行活动。</li>
<li>每月进行一次战队的交流，比赛（评定），分享学习经验。提高合作水平</li>
<li>战队会进行定期考核，当无法完成相应任务，会从战队中移除。</li>
</ol>
<h2 id="什么是CTF"><a href="#什么是CTF" class="headerlink" title="什么是CTF"></a>什么是CTF</h2><blockquote>
<p>​    CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。(百度百科)</p>
</blockquote>
<p>CTF的几个方向 Web（网络安全）,Pwn（二进制安全）,Re（逆向工程）,Crypto（密码学）,Misc（流量分析，图片隐写，取证，等其他方向）</p>
<h2 id="方向介绍，入门书籍及练习网站"><a href="#方向介绍，入门书籍及练习网站" class="headerlink" title="方向介绍，入门书籍及练习网站"></a>方向介绍，入门书籍及练习网站</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><blockquote>
<p>网络安全，及负责各种数据库，网页，等网络产品的漏洞挖掘及其利用</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr>
<th>书名</th>
<th>网购链接（没有打广告）</th>
<th>电子书链接</th>
</tr>
</thead>
<tbody><tr>
<td>白帽子讲Web安全</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.16.6c384122VZ3uBX&id=596872157850&cm_id=140105335569ed55e27b&abbucket=3">白帽子讲Web安全</a></td>
<td>群文件自取</td>
</tr>
<tr>
<td>代码审计 企业级Web代码安全架构</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.9.396746e1Anlg9X&id=594217706164&cm_id=140105335569ed55e27b&abbucket=3">代码审计</a></td>
<td><a href="https://u1475340.ctfile.com/fs/1475340-228355356">下载</a></td>
</tr>
<tr>
<td>Sndav弱鸡的博客</td>
<td><a href="http://blog.boyblog.club/">博客</a></td>
<td></td>
</tr>
<tr>
<td>离别歌的博客</td>
<td><a href="https://www.leavesongs.com/">博客</a></td>
<td></td>
</tr>
<tr>
<td>郁离歌丶的博客</td>
<td><a href="http://yulige.top/">郁离歌丶的博客</a></td>
<td></td>
</tr>
<tr>
<td>SecWiki</td>
<td><a href="https://sec-wiki.com/">SecWiki</a></td>
<td></td>
</tr>
<tr>
<td>WooYun镜像站</td>
<td><a href="http://www.anquan.us/">WooYun镜像站</a></td>
<td></td>
</tr>
<tr>
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
</tbody></table>
<p><strong>练习网站</strong></p>
<table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn/">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr>
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr>
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody></table>
<h3 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h3><blockquote>
<p>二进制安全，负责各种二进制程序（ELF，EXE等）的漏洞挖掘及其利用</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr>
<th>书名</th>
<th>网购链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody><tr>
<td>0day安全:软件漏洞分析技术</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.33.47641d36xHPMdd&id=595379481437&ns=1&abbucket=3">0day安全:软件漏洞分析技术</a></td>
<td>群内自取</td>
</tr>
<tr>
<td>汇编语言</td>
<td><a href="https://item.jd.com/12259774.html">汇编语言</a></td>
<td></td>
</tr>
<tr>
<td>程序员的自我修养（装载，链接与库）</td>
<td>自己淘宝吧</td>
<td><a href="https://pan.baidu.com/s/1cALpx_D_9CR9hWWM9rIMwQ">百度网盘，提取码：73pe</a></td>
</tr>
<tr>
<td>深入理解计算机系统</td>
<td>同上</td>
<td><a href="https://pan.baidu.com/share/init?surl=gtB8fEUUtFj8blwJnajICQ">百度网盘，提取码：yx0s</a></td>
</tr>
<tr>
<td>glibc内存管理ptmalloc2源代码分析</td>
<td>同上</td>
<td><a href="https://pan.baidu.com/s/1-0odrFdV0Dn7xgehicuz0A">百度网盘，提取码：su8n</a></td>
</tr>
<tr>
<td>xxrw的blog</td>
<td><a href="https://xiaoxiaorenwu.top/">博客</a></td>
<td></td>
</tr>
<tr>
<td>天枢-p4nda的blog</td>
<td><a href="http://p4nda.top/">博客</a></td>
<td></td>
</tr>
<tr>
<td>天枢-YM的blog</td>
<td><a href="https://e3pem.github.io/">博客</a></td>
<td></td>
</tr>
<tr>
<td>天枢-17的blog</td>
<td><a href="https://sunichi.github.io/">博客</a></td>
<td></td>
</tr>
<tr>
<td>r3kapig-swing的blog</td>
<td><a href="https://bestwing.me/">博客</a></td>
<td></td>
</tr>
<tr>
<td>VidarTeam-Veritas501的blog</td>
<td><a href="https://veritas501.space/">博客</a></td>
<td></td>
</tr>
<tr>
<td><strong>资料</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>网站</td>
<td>地址</td>
<td></td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td></td>
</tr>
<tr>
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
<tr>
<td>CTF-ALL-In-One</td>
<td><a href="https://github.com/firmianay/CTF-All-In-One/">CTF-ALL-In-One</a></td>
<td></td>
</tr>
<tr>
<td>Shellcode网站1</td>
<td><a href="https://shell-storm.org/">Shell-Storm</a></td>
<td></td>
</tr>
<tr>
<td>Shellcode网站2</td>
<td><a href="https://www.exploit-db.com/shellcodes">shellcode</a></td>
<td></td>
</tr>
<tr>
<td>北京邮电大学瑶光战队学习资料</td>
<td><a href="https://github.com/xiaoxiaorenwu/-">北邮瑶光</a></td>
<td></td>
</tr>
<tr>
<td>i春秋的pwn基础教程</td>
<td><a href="https://bbs.ichunqiu.com/search.php?mod=portal&searchid=117&searchsubmit=yes&kw=pwn%E5%85%A5%E9%97%A8">i春秋搜索pwn入门</a></td>
<td></td>
</tr>
<tr>
<td>看学知识库</td>
<td><a href="https://www.kanxue.com/chm-search-pwn.htm">看雪知识库</a></td>
<td></td>
</tr>
<tr>
<td>libc搜索</td>
<td><a href="http://libcdb.com/">libc搜索</a></td>
<td></td>
</tr>
</tbody></table>
<p><strong>刷题网站</strong><br>| 网站 | 地址 | 难度 |<br>| —- | —- | —- |<br>| 攻防世界 | <a href="http://adworld.xctf.org.cn/">攻防世界</a> | 初级-困难 |<br>| 北京联合大学OJ | <a href="https://buuoj.cn/">BUUOJ</a> | 中等 |<br>| Github CTFTraining | <a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a> | 中级-困难 |<br>| PwnableKr | <a href="https://pwnable.kr/">PwnableKr</a> | 初级-中级 |<br>| PwnableTw  | <a href="https://pwnable.tw/">PwnableTw</a> | 中级-困难 |<br>| Jarvisoj | <a href="https://jarvisoj.com/">Jarvisoj</a> | 初级-中级|<br>| CTFWP | <a href="http://www.ctfwp.com/">CTFWP</a> | 中级 |</p>
<h3 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h3><blockquote>
<p>逆向工程，负责逆向程序算法，破解程序限制</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr>
<th>书名</th>
<th>网购链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody><tr>
<td>Re4b(Reverse Engineer For beginner)</td>
<td><a href="https://item.jd.com/12166962.html">Re4b</a></td>
<td>群内自取</td>
</tr>
<tr>
<td>加密与解密</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.189.1d8238f5fF5n7B&id=580607194609&ns=1&abbucket=3">加密与解密</a></td>
<td><a href="https://pan.baidu.com/s/18PhiF_STy4413w4rlfZKfQ">百度云</a> 提取码: hpdb</td>
</tr>
<tr>
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
<tr>
<td><strong>练习网站</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn/">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr>
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr>
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody></table>
<h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><blockquote>
<p>密码学，负责通过密码以及数学知识，破解相应密码</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr>
<th>书名</th>
<th>淘宝链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody><tr>
<td>现代密码学</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
</tbody></table>
<p><strong>练习网站</strong></p>
<table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn/">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr>
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr>
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody></table>
<h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><blockquote>
<p>杂项，负责各种其他安全相关，比如取证，隐写，区块链等</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr>
<th>书名</th>
<th>网购链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody><tr>
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
</tbody></table>
<p><strong>练习网站</strong></p>
<table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn/">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr>
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr>
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title> ucore lab2</title>
    <url>/os/ucore%20lab2/</url>
    <content><![CDATA[<h1 id="ucore-lab2"><a href="#ucore-lab2" class="headerlink" title="ucore lab2"></a>ucore lab2</h1><p>继续看Intel 80386 Programmer’s Reference Manual, 1987 (HTML)<br><a href="http://www.logix.cz/michal/doc/i386/">http://www.logix.cz/michal/doc/i386/</a><br>再看Intel® 64 and IA-32 Architectures Software Developer Manuals<br><a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a></p>
<a id="more"></a>

<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>分段机制启动、分页机制未启动：逻辑地址—&gt;段机制处理—&gt;线性地址=物理地址<br>分段机制和分页机制都启动：逻辑地址—&gt;段机制处理—&gt;线性地址—&gt;页机制处理—&gt;物理地址</p>
<p>2^32 = 2^10 * 2^10 * 4k<br>段机制的时候，limit域长20bit，如果以4k为单位，那么就是最大4g<br>页机制，一个页4k字节，4字节一个页，一个页可以放1k个页表，那就是1k × 4k = 4M的内存，页表目录则是保存1k个页表，正好4M × 1000 = 4G</p>
<p>内存分配有几个阶段<br><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_3_5_4_maping_relations.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_3_5_4_maping_relations.html</a></p>
<h3 id="lab2-宏观内存分配"><a href="#lab2-宏观内存分配" class="headerlink" title="lab2 宏观内存分配"></a>lab2 宏观内存分配</h3><p><img src="https://segmentfault.com/img/remote/1460000009450843"><br>图片来自<a href="https://segmentfault.com/a/1190000009450840">https://segmentfault.com/a/1190000009450840</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory: 0009fc00, [00000000, 0009fbff], type &#x3D; 1.</span><br><span class="line">memory: 00000400, [0009fc00, 0009ffff], type &#x3D; 2.</span><br><span class="line">memory: 00010000, [000f0000, 000fffff], type &#x3D; 2.</span><br><span class="line">memory: 07ee0000, [00100000, 07fdffff], type &#x3D; 1.</span><br><span class="line">memory: 00020000, [07fe0000, 07ffffff], type &#x3D; 2.</span><br><span class="line">memory: 00040000, [fffc0000, ffffffff], type &#x3D; 2.</span><br></pre></td></tr></table></figure>
<p>可用内存有两块，一个是从00000000 –&gt; 0009fc00 约1M字节<br>5个十六进制位是20bit，2^10 是1KB,那么2^20就是1M</p>
<p>bios加载bootloader<br>bootblock占512字节 = 0x200.占0x7c00 —&gt; 0x 7dff<br>bootloader探测的内存信息位于0x8000</p>
<p>内核加载到100000，恰好是第二块可用内存的起始地址<br>第二块内存有07ee0000，大概126MB多一点<br>在memlayout.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define KMEMSIZE            0x38000000                  &#x2F;&#x2F; the maximum amount of physical memory</span><br></pre></td></tr></table></figure>
<p>这里限制的物理内存接近1g</p>
<p>然后就是kernel的ELF一路加载下来<br>其中data段有页目录表（约0x0010b000）和第一个页表<br>映射0~4MB的首个页表已经填充好。</p>
<p>0x10e000之后就是Page结构体，有32736个，每一个管理4K内存，和内存总量相符。<br>每一个Page有20字节，所以Pages占了654720字节 = 0x9fd80。占了640K…比想象中大好多<br>page管理物理内存，数量固定，页表数量可能变化，按需创建。<br>0x1add80之后就是用来分配的内存了，我们的kernel总共用了0xadd80=712KB。</p>
<p>如果内存再大的话，如果想对应上整个4g空间，那么Page占的空间还可以大32倍。</p>
<h3 id="diff-lab2-with-lab1"><a href="#diff-lab2-with-lab1" class="headerlink" title="diff lab2 with lab1"></a>diff lab2 with lab1</h3><p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_2_2_phymemlab_files.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_2_2_phymemlab_files.html</a><br>简单来说变化不大，变化的部分除了一些不重要的库（cprintf，什么console的命令解析）其他的基本上都要在写lab2的时候碰到，指导书也讲得很详细。<br>可以先git commit lab1_result 之后再把lab2 覆盖进去看看变化。</p>
<h3 id="内存探测"><a href="#内存探测" class="headerlink" title="内存探测"></a>内存探测</h3><p>bootasm.S<br>添加了有关内存分布的汇编代码<br><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_5_probe_phymem_methods.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_5_probe_phymem_methods.html</a></p>
<h3 id="do-while-0"><a href="#do-while-0" class="headerlink" title="do while(0)"></a>do while(0)</h3><p>kern/sync/sync.h<br><a href="https://www.jianshu.com/p/99efda8dfec9">https://www.jianshu.com/p/99efda8dfec9</a></p>
<h3 id="kern-entry"><a href="#kern-entry" class="headerlink" title="kern_entry"></a>kern_entry</h3><p><a href="https://segmentfault.com/a/1190000009450840">https://segmentfault.com/a/1190000009450840</a><br><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_3_5_4_maping_relations.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_3_5_4_maping_relations.html</a></p>
<h3 id="gdb打印变量不对"><a href="#gdb打印变量不对" class="headerlink" title="gdb打印变量不对"></a>gdb打印变量不对</h3><p><a href="https://blog.csdn.net/jeff_/article/details/53333154">https://blog.csdn.net/jeff_/article/details/53333154</a><br><a href="http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html">http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html</a><br>CFLAGS    := -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)<br>修改成<br>CFLAGS    := -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gdwarf-4 -nostdinc $(DEFS)<br>目测没有什么其他问题<br>然而<br>造成了print_stackframe()不能打印出行数了</p>
<h3 id="页表映射到自己"><a href="#页表映射到自己" class="headerlink" title="页表映射到自己"></a>页表映射到自己</h3><p>页目录表地址意义： 这个地址开头的线性地址，管理它的页表在哪一个内存页（物理地址）？<br>页表地址意义： 你这个4M的地址范围空间，里面的这个地址页在哪个物理内存页？</p>
<p>如果把页目录表项当成页表项，也就是说，里面的每一个页，都是一个页表。<br>把0xFAC（10 bit）映射到自己，也就是说在0xFAC（10 bit），这4M的虚拟地址，之后加上10bit的页表的虚拟地址前10bit作为index，就可以直接访问到页表了。<br>这就相当于必须要解两次地址，消耗了一次，这样就可以达到只取一次地址的效果了。</p>
<h3 id="invlpg"><a href="#invlpg" class="headerlink" title="invlpg"></a>invlpg</h3><p><a href="https://blog.csdn.net/cinmyheart/article/details/39994769">https://blog.csdn.net/cinmyheart/article/details/39994769</a><br>TLB 页表缓冲，我还以为只是页目录表缓冲。。。</p>
<p>问： TLB里面有页目录表吗？<br>暂时答：因为缓冲一次就缓冲了整个页表，是否命中的判断就是根据对应的页目录表项对不对，所以可能命中缓冲时完全不需要访问页目录表。。。</p>
<blockquote>
<p>5.2.5 Page Translation Cache<br>For greatest efficiency in address translation, the processor stores the most recently used page-table data in an on-chip cache. Only if the necessary paging information is not in the cache must both levels of page tables be referenced.</p>
<p>The existence of the page-translation cache is invisible to applications programmers but not to systems programmers; operating-system programmers must flush the cache whenever the page tables are changed. The page-translation cache can be flushed by either of two methods:</p>
<ol>
<li><p>By reloading CR3 with a MOV instruction; for example:</p>
<p>MOV CR3, EAX</p>
</li>
<li><p>By performing a task switch to a TSS that has a different CR3 image<br>than the current TSS. (Refer to Chapter 7 for more information on<br>task switching.)</p>
</li>
</ol>
</blockquote>
<p>When to do or not do INVLPG, MOV to CR3 to minimize TLB flushing<br><a href="https://www.e-learn.cn/content/wangluowenzhang/626493">https://www.e-learn.cn/content/wangluowenzhang/626493</a><br>TLB的那些事儿<br><a href="https://blog.csdn.net/omnispace/article/details/61415935">https://blog.csdn.net/omnispace/article/details/61415935</a></p>
<h2 id="缺页？"><a href="#缺页？" class="headerlink" title="缺页？"></a>缺页？</h2><p>问题： 现在管理的只是物理内存，那谁管理页表的映设关系？如果某虚拟地址没有对应的页怎么办？<br>还是说lab2其实就没有管这一块？<br>暂时答：似乎确实不管这回事？虽然有一些维护页表项的函数，但是没怎么被调用。<br>先写写lab3吧。</p>
<h3 id="mark-收藏夹"><a href="#mark-收藏夹" class="headerlink" title="mark-收藏夹"></a>mark-收藏夹</h3><p><a href="https://www.jianshu.com/p/abbe81dfe016">https://www.jianshu.com/p/abbe81dfe016</a><br><a href="https://blog.csdn.net/hezxyz/article/details/95764158">https://blog.csdn.net/hezxyz/article/details/95764158</a></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title> ucore lab1</title>
    <url>/os/ucore%20lab1/</url>
    <content><![CDATA[<h1 id="ucore-lab1"><a href="#ucore-lab1" class="headerlink" title="ucore lab1"></a>ucore lab1</h1><p>上来先看看Intel 80386 Programmer’s Reference Manual, 1987 (HTML)吧。<br><a href="http://www.logix.cz/michal/doc/i386/">http://www.logix.cz/michal/doc/i386/</a></p>
<a id="more"></a>


<h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><blockquote>
<p><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_ref_ucore-resource.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_ref_ucore-resource.html</a></p>
</blockquote>
<p>跟我一起写makefile</p>
<blockquote>
<p><a href="https://seisman.github.io/how-to-write-makefile/functions.html">https://seisman.github.io/how-to-write-makefile/functions.html</a></p>
</blockquote>
<p>makefile这鬼东西真tm功能强，强得我什么都看不懂。原来在那个眼花缭乱的makefile里面全是各种各样的函数。。。。<br>但是实际上不需要全部读懂，稍微看看就好，这个不是重点，而且好像这个脚本比较通用。</p>
<blockquote>
<p><a href="https://blog.csdn.net/u013484370/article/details/50638353">https://blog.csdn.net/u013484370/article/details/50638353</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># add files to packet: (#files, cc[, flags, packet, dir])</span><br><span class="line">#此模板，就是真正在makefile中用来编译所有的目表文件，并生成makefile规则的模板。</span><br><span class="line">define do_add_files_to_packet</span><br><span class="line">#__temp_packet__用来记录所有的临时目标文件。</span><br><span class="line">__temp_packet__ :&#x3D; $(call packetname,$(4))</span><br><span class="line">ifeq ($$(origin $$(__temp_packet__)),undefined)</span><br><span class="line">$$(__temp_packet__) :&#x3D;</span><br><span class="line">endif</span><br><span class="line">__temp_objs__ :&#x3D; $(call toobj,$(1),$(5))</span><br><span class="line">$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(5))))</span><br><span class="line">$$(__temp_packet__) +&#x3D; $$(__temp_objs__)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<p>其他资料：</p>
<blockquote>
<p>How to make an Operating System<br><a href="https://samypesse.gitbook.io/how-to-create-an-operating-system/chapter-3">https://samypesse.gitbook.io/how-to-create-an-operating-system/chapter-3</a><br>别人的lab1实验报告:<br><a href="https://www.jianshu.com/p/2f95d38afa1d">https://www.jianshu.com/p/2f95d38afa1d</a><br><a href="https://www.cnblogs.com/maruixin/p/3175894.html">https://www.cnblogs.com/maruixin/p/3175894.html</a></p>
</blockquote>
<h2 id="硬盘读取"><a href="#硬盘读取" class="headerlink" title="硬盘读取"></a>硬盘读取</h2><blockquote>
<p>《读取磁盘：LBA方式》<br><a href="https://www.cnblogs.com/mlzrq/p/10223060.html">https://www.cnblogs.com/mlzrq/p/10223060.html</a></p>
</blockquote>
<p>这个写的比那个gitbook实验指导书讲得好一点</p>
<blockquote>
<p>LBA简介<br>磁盘读取发展</p>
<p>IO操作读取硬盘的三种方式：</p>
<p>chs方式 ：小于8G (8064MB)</p>
<p>LBA28方式：小于137GB</p>
<p>LBA48方式：小于144,000,000 GB</p>
<p>LBA方式访问使用了data寄存器，LBA寄存器（总共3个），device寄存器，command寄存器来完成的。</p>
<p>LBA28和LBA48方式：<br>LBA28方式使用28位来描述一个扇区地址，最大支持128GB的硬磁盘容量。</p>
<p>LBA28的寄存器</p>
</blockquote>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>端口</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>data寄存器</td>
<td>0x1F0    已经读取或写入的数据，大小为两个字节（16位数据)</td>
<td>每次读取1个word,反复循环，直到读完所有数据</td>
</tr>
<tr>
<td>features寄存器</td>
<td>0x1F1</td>
<td>读取时的错误信息，写入时的额外参数</td>
</tr>
<tr>
<td>sector count寄存器</td>
<td>0x1F2</td>
<td>指定读取或写入的扇区数</td>
</tr>
<tr>
<td>LBA low寄存器</td>
<td>0x1F3</td>
<td>lba地址的低8位</td>
</tr>
<tr>
<td>LBA mid寄存器</td>
<td>0x1F4</td>
<td>lba地址的中8位</td>
</tr>
<tr>
<td>LBA high寄存器</td>
<td>0x1F5</td>
<td>lba地址的高8位</td>
</tr>
<tr>
<td>device寄存器</td>
<td>0x1F6</td>
<td>lba地址的前4位（占用device寄存器的低4位）<br />主盘值为0（占用device寄存器的第5位）<br />第6位值为1<br />LBA模式为1，CHS模式为0（占用device寄存器的第7位）<br />第8位值为1</td>
</tr>
<tr>
<td>command寄存器</td>
<td>0x1F7</td>
<td>读取，写入的命令，返回磁盘状态。<br />1 读取扇区:0x20 写入扇区:0x30<br />磁盘识别:0xEC</td>
</tr>
<tr>
<td>IDE通道1，读写0x1f0-0x1f7号端口</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IDE通道2，读写0x170-0x17f号端口</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>Program header描述的是一个段在文件中的位置、大小以及它被放进内存后所在的位置和大小。<br>所以bootmain中的读取elf文件，需要把每一个段都按照指定的虚拟地址和size加载好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; is this a valid ELF?</span><br><span class="line">    if (ELFHDR-&gt;e_magic !&#x3D; ELF_MAGIC) &#123;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; load each program segment (ignores ph flags)</span><br><span class="line">    ph &#x3D; (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph &#x3D; ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; call the entry point from the ELF header</span><br><span class="line">    &#x2F;&#x2F; note: does not return</span><br><span class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br></pre></td></tr></table></figure>
<p>但是为什么是ph-&gt;p_va &amp; 0xFFFFFF？<br>去掉了前面一个字节。<br>答：应该不是因为硬盘的问题，可能是内存大小的限制</p>
<blockquote>
<p><a href="https://blog.csdn.net/u012418573/article/details/73823524">https://blog.csdn.net/u012418573/article/details/73823524</a><br>2、链接地址VS加载地址<br>（1）链接地址：是虚拟地址，代码中的绝对跳转地址和全局变量的地址都依赖于链接地址，链接地址改变时，这些地址也会改变，但相对跳转不依赖与链接地址。<br>（2）加载地址：程序被加载到的物理地址<br>（3）关系：链接地址经过地址转换要等于物理地址（加载地址）<br>（4）内核的加载地址：0x100000处，参加bootmain.c<br>（5）内核的链接地址：0xf0100000处，但是我们没有那么大的内存，故：ELFHDR-&gt;e_entry&amp;0xFFFFFF</p>
</blockquote>
<p>另外，这个问题好像不简单啊：</p>
<blockquote>
<p>ucore Lab2 调试时断点无效分析<br><a href="http://blog.sina.com.cn/s/blog_3dce1e7b0102x6t3.html">http://blog.sina.com.cn/s/blog_3dce1e7b0102x6t3.html</a></p>
</blockquote>
<p>就是说，lab2的bootloader加载完成之后，会加载一个新的gdt段表，让地址多了一个KERNBASE(0xC0000000)。而lab1没有这个功能，就直接通过这样与一下来解决。</p>
<h2 id="实模式到保护模式的切换"><a href="#实模式到保护模式的切换" class="headerlink" title="实模式到保护模式的切换"></a>实模式到保护模式的切换</h2><p>问：16位到32位的切换是瞬间完成的吗？</p>
<p>问：发现进入实模式之后的ljmp之后，cs自动变成8<br>答：代码段寄存器（CS）的内容不能由装载指令（如MOV）直接设置，而只能被那些会改变程序执行顺序的指令（如JMP、INT、CALL）间接地设置。<br>8代表序号为1的段描述符表。进入实模式之前就要设置好段描述符表。</p>
<blockquote>
<p>下面摘自《计算机启动流程分析–以JOS为例（从BIOS到刚进入boot loader）》<br><a href="https://blog.csdn.net/old_memory/article/details/79572498">https://blog.csdn.net/old_memory/article/details/79572498</a></p>
</blockquote>
<p>$CR0_PE_ON是CR0设置实模式或保护模式的开关，这里打开，表明接下来的地址都是32位的虚拟地址（必须注意，这里由于是刚开始，所有的虚拟地址和物理地址等价），然而，系统是怎样真正进入32位寻址的呢？以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"> </span><br><span class="line">  .code32                     # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br></pre></td></tr></table></figure>
<p>它的作用仅仅是跳转到下一行，但是ljmp有副作用：$PROT_MODE_CSEG的值会被加载，boot.S文件开头的宏表明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br></pre></td></tr></table></figure>
<p>它的值是0x8，这个值被存入CS寄存器，它会与GDT一起影响地址翻译。</p>
<p>摘录结束，另外在文件bootblock.asm中有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">7c2d:	ea                   	.byte 0xea</span><br><span class="line">7c2e:	32 7c 08 00          	xor    0x0(%eax,%ecx,1),%bh</span><br></pre></td></tr></table></figure>
<p>这说明反汇编失败了？所以ljmp实际上是32位才有的指令吧。<br>可是为什么在gdb里面却显示<br>0x7c2d &lt;seta20+25&gt;:    ljmp   $0xb866,$0x87c32<br>只是跳转到7c32，为什么有这么多一堆东西？<br>严重怀疑在jmp之前还是十六位的代码。</p>
<p>另外这篇文章说得特别好啊，说出了内幕：</p>
<blockquote>
<p><a href="https://blog.csdn.net/dog250/article/details/5303304">https://blog.csdn.net/dog250/article/details/5303304</a><br>ljmp的含义是长跳，长跳主要就是重新加载寄存器，32位保护模式主要体现在段寄存器，具有可以参考段选择子和段描述符的概念，如果不用长跳的话，那么段寄存器不会重新加载，后面的取指结果仍然是老段寄存器中的值，当然保护模式不会生效了，Intel手册上有讲可见寄存器和不可见寄存器的篇章，可以看一下，其实实模式就是保护模式的一种权限全开放的特殊情况，就是说段寄存器左移相当于右边添加0，而这添加的0可以看做保护模式的RPL，RPL为0代表Intel的0环，当然是全权限了。</p>
<p>不过Intel的实模式的概念实属不得已而为之，现在的意义已经不大了，从实模式启动然后跳转到保护模式纯粹是在绕圈子，没有实质的意义，商业上为了保护以前的投资不得不将技术做的没有意义的复杂…</p>
</blockquote>
<hr>
<blockquote>
<p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14 个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。目前所谓的64TB（2^(14+32) =2^46 ）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p>
</blockquote>
<p>没想到说32位系统最多有4gb内存不是假的啊。。。换页还能换着用超出4gb的内存吗？</p>
<p>另外为什么是2^13次方？<br>因为段寄存器占用了三个比特位用来干别的。参见<br><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_1_protection_mode.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_1_protection_mode.html</a><br>这实验指导书这次摘录得特别好啊！</p>
<hr>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>问： 如果某个段描述符要求的权限级别是3，那么我通过加载段寄存器，index选择这个描述符，但是权限级是0，那这样不就让当前权限变成0了？<br>答：对应的段因为权限是三，本来就没有对权限做限制。所以访问起来并没有什么区别。<br>但是如果再切换的话就会造成影响，使得能够切换到ring0的数据段。<br>难道是真正切换时，权限级不由自己加载的段寄存器的值确定，而是由选择出来的段描述符的权限级确定？</p>
<p>特权级和特权级转移<br><a href="https://www.jianshu.com/p/377f473dd0a9">https://www.jianshu.com/p/377f473dd0a9</a></p>
<p>这段描述符的结构很重要。<br><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1_figs/image003.png"></p>
<ul>
<li>段基地址：规定线性地址空间中段的起始地址。在80386保护模式下，段基地址长32位。因为基地址长度与寻址地址的长度相同，所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不象实方式下规定的边界必须被16整除。</li>
<li>段界限：规定段的大小。在80386保护模式下，段界限用20位表示，而且段界限可以是以字节为单位或以4K字节为单位。</li>
<li>段属性：确定段的各种性质。:<ul>
<li>段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。</li>
<li>类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。</li>
<li>描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。</li>
<li>段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。图5-4显示了当存在位为0时，描述符的格式。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。</li>
<li>已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。</li>
</ul>
</li>
</ul>
<p><a href="http://www.logix.cz/michal/doc/i386/chp06-03.htm#06-03-01">http://www.logix.cz/michal/doc/i386/chp06-03.htm#06-03-01</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Figure 6-1. Protection Fields of Segment Descriptors</span><br><span class="line">                           DATA SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+---------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     |  TYPE   |#################|</span><br><span class="line"> |###BASE 31..24###|G|B|0|V| 19..16  |P| DPL |         |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     |1|0|E|W|A|#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-+-+-+-+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|        SEGMENT LIMIT 15..0        | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                        EXECUTABLE SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+---------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     |  TYPE   |#################|</span><br><span class="line"> |###BASE 31..24###|G|D|0|V| 19..16  |P| DPL |         |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     |1|0|C|R|A|#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-+-+-+-+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|        SEGMENT LIMIT 15..0        | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                         SYSTEM SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+-+-------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     | |       |#################|</span><br><span class="line"> |###BASE 31..24###|G|X|0|V| 19..16  |P| DPL |0| TYPE  |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     | |       |#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-------+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|       SEGMENT LIMIT 15..0         | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line">        A   - ACCESSED                              E   - EXPAND-DOWN</span><br><span class="line">        AVL - AVAILABLE FOR PROGRAMMERS USE         G   - GRANULARITY</span><br><span class="line">        B   - BIG                                   P   - SEGMENT PRESENT</span><br><span class="line">        C   - CONFORMING                            R   - READABLE</span><br><span class="line">        D   - DEFAULT                               W   - WRITABLE</span><br><span class="line">        DPL - DESCRIPTOR PRIVILEGE LEVEL</span><br><span class="line"></span><br><span class="line">Table 6-1. System and Gate Descriptor Types</span><br><span class="line">Code      Type of Segment or Gate</span><br><span class="line"></span><br><span class="line">  0       -reserved</span><br><span class="line">  1       Available 286 TSS</span><br><span class="line">  2       LDT</span><br><span class="line">  3       Busy 286 TSS</span><br><span class="line">  4       Call Gate</span><br><span class="line">  5       Task Gate</span><br><span class="line">  6       286 Interrupt Gate</span><br><span class="line">  7       286 Trap Gate</span><br><span class="line">  8       -reserved</span><br><span class="line">  9       Available 386 TSS</span><br><span class="line">  A       -reserved</span><br><span class="line">  B       Busy 386 TSS</span><br><span class="line">  C       386 Call Gate</span><br><span class="line">  D       -reserved</span><br><span class="line">  E       386 Interrupt Gate</span><br><span class="line">  F       386 Trap Gate</span><br></pre></td></tr></table></figure>



<h2 id="IDT的结构"><a href="#IDT的结构" class="headerlink" title="IDT的结构"></a>IDT的结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Figure 9-1. IDT Register and Table</span><br><span class="line">                                              INTERRUPT DESCRIPTOR TABLE</span><br><span class="line">                                              +------+-----+-----+------+</span><br><span class="line">                                        +----&gt;|      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #N -|</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     +------+-----+-----+------+</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     +------+-----+-----+------+</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #2 -|</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     |------+-----+-----+------|</span><br><span class="line">            IDT REGISTER                |     |      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #1 -|</span><br><span class="line">                    15            0     |     |      |     |     |      |</span><br><span class="line">                   +---------------+    |     |------+-----+-----+------|</span><br><span class="line">                   |   IDT LIMIT   |----+     |      |     |     |      |</span><br><span class="line">  +----------------+---------------|          |- GATE FOR INTERRUPT #0 -|</span><br><span class="line">  |            IDT BASE            |---------&gt;|      |     |     |      |</span><br><span class="line">  +--------------------------------+          +------+-----+-----+------+</span><br><span class="line">   31                             0</span><br></pre></td></tr></table></figure>
<p>这里的idt limit是idt的长度减1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Figure 9-3. 80306 IDT Gate Descriptors</span><br><span class="line">                                80386 TASK GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----------------+</span><br><span class="line">  |#############(NOT USED)############| P |DPL|0 0 1 0 1|###(NOT USED)####|4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----------------|</span><br><span class="line">  |             SELECTOR              |#############(NOT USED)############|0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                                80386 INTERRUPT GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----+-----------+</span><br><span class="line">  |           OFFSET 31..16           | P |DPL|0 1 1 1 0|0 0 0|(NOT USED) |4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----+-----------|</span><br><span class="line">  |             SELECTOR              |           OFFSET 15..0            |0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                                80386 TRAP GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----+-----------+</span><br><span class="line">  |          OFFSET 31..16            | P |DPL|0 1 1 1 1|0 0 0|(NOT USED) |4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----+-----------|</span><br><span class="line">  |             SELECTOR              |           OFFSET 15..0            |0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br></pre></td></tr></table></figure>
<p>关于 Segment Present</p>
<blockquote>
<p>Segment-Present bit: If this bit is zero, the descriptor is not valid for use in address transformation; the processor will signal an exception when a selector for the descriptor is loaded into a segment register. Figure 5-4 shows the format of a descriptor when the present-bit is zero. The operating system is free to use the locations marked AVAILABLE. Operating systems that implement segment-based virtual memory clear the present bit in either of these cases:</p>
<p>When the linear space spanned by the segment is not mapped by the paging mechanism.<br>When the segment is not present in memory.</p>
</blockquote>
<h2 id="TSS-（Task-Status-Segment）"><a href="#TSS-（Task-Status-Segment）" class="headerlink" title="TSS （Task Status Segment）"></a>TSS （Task Status Segment）</h2><p>没想到在看似平常的GDT下面，居然出现了一个全新的没见过的概念。。。<br><a href="https://www.cnblogs.com/yasmi/articles/5198138.html">https://www.cnblogs.com/yasmi/articles/5198138.html</a></p>
<p>首先GDT里有TSS Descriptor，用来保存当前指令地址。<br>另外，在IDT里有Task Gate Discriptor，相当于是TSS的一个指针，不过在权限上可以单独设置<br>Task Gate Discriptor在LDT里居然也有！<br><a href="http://www.logix.cz/michal/doc/i386/chp07-04.htm">http://www.logix.cz/michal/doc/i386/chp07-04.htm</a></p>
<ol>
<li>加载task register<br>ltr 指令使用提供的 selector 在 GDT / LDT 里索引查找到 TSS descriptor 后，加载到 TR 寄存器里。初始的 TSS descriptor 必须设为 available 状态，否则不能加载到 TR。processor 加载 TSS descriptor 后，将 TSS descriptor 置为 busy 状态。</li>
<li>任务切换<br>当前进程要切换另一个进程时，可以使用 2 种 selector 进行：使用 TSS selector 以及 Task gate selector（任务门符）。<br>当前进程的执行环境被保存在当前进程的 TSS segment 中。<br>发生了 TSS selector 切换。新的 TSS selector 被加载到 TR.selector，而新的 TSS descriptor 也被加载到 TR 寄存的隐藏部分。<br>processor 从当前的 TSS segment 取出新进程的执行环境。经过相关的 selector &amp; descriptor  的常规检查以及权限检查。通过之后才真正加载。<br>将新进程的 TSS descriptor 置为 busy 状态。使得新进程不能重入。</li>
</ol>
<blockquote>
<p><a href="https://www.xuebuyuan.com/737019.html">https://www.xuebuyuan.com/737019.html</a><br>我们可以看到，只有用CALL指令+调用门方式跳转，且目标代码段是非一致代码段时，才会引起CPL的变化，即引起代码执行特权级的跃迁，这是目前得知的改变执行特权级的唯一办法</p>
</blockquote>
<p>mark 关于push esp pop esp<br><a href="https://blog.csdn.net/particleHorizon/article/details/78722683">https://blog.csdn.net/particleHorizon/article/details/78722683</a></p>
<h2 id="中断门调用过程"><a href="#中断门调用过程" class="headerlink" title="中断门调用过程"></a>中断门调用过程</h2><p>最早设置好idt表，通过汇编指令lidt。里面保存了表的大小和起始地址，地址指向的表的每一项都有地址，段寄存器，特权级这三个属性。特权级限制了访问，而地址加上段寄存器的组合就指向了中断服务程序。<br>于是当发生中断的时候，cpu就会找到指定的地址调用。<br>调用前，会依次把一些重要的寄存器压栈。<br>(特权级切换时还有的ss, esp)eflags, cs, eip, error code。<br>然后就像call调用一样，跳转到指定的地方继续运行。<br>这里，一般的操作系统会继续保存上下文，以方便恢复一切结束中断。被打断的有当前的各种寄存器，还有栈。结束的时候就恢复自己保存的栈和寄存器再iret就可以了。<br>当不切换栈的时候是直接保存在当前栈上，反正之后会回来清理，中断的时候cpu忙，旧的栈也没有人来用。<br>切换栈的时候，系统是会从tss段取出esp吗？保存的栈帧是在系统栈还是在用户栈？？</p>
<p><a href="https://www.cnblogs.com/chaozhu/p/6283495.html">https://www.cnblogs.com/chaozhu/p/6283495.html</a></p>
<ol>
<li>在发生中断、异常时前，程序运行在用户态，ESP指向的是Interrupted Procedure’s Stack，即用户栈。</li>
<li>运行下一条指令前，检测到中断（x86不会在指令执行没有指向完期间响应中断）。从TSS中取出esp0字段（esp0代表的是内核栈指针，特权级0）赋给ESP，所以此时ESP指向了Handler’s Stack，即内核栈。</li>
<li>cpu控制单元将用户堆栈指针（TSS中的ss，sp字段，这代表的是用户栈指针）压入栈，ESP已经指向内核栈，所以入栈指的的是入内核栈。</li>
<li>cpu控制单元依次压入EFLAGS、CS、EIP、Error Code（如果有的话）。此时内核栈指针ESP位置见图4中的ESP After Transfer to Handler。</li>
</ol>
<p><a href="https://www.xuebuyuan.com/915513.html">https://www.xuebuyuan.com/915513.html</a><br>也是讲堆栈切换的</p>
<p>为什么当前的tss保存的是内核的东西？虽然这和TSS的用法不符，但是应该没错吧。<br>为什么垃圾intel 80386 程序员手册没有在中断一节说清楚？是我瞎吗</p>
<p>那么当一个os初始化完成之后，它第一个用户态程序是怎么切换权限级的？直接加载一个更低的权限？<br>当系统解析ELF文件的时候，就要安排好各种数据，分段（有页吗？）设置好权限（读写执行）和权限级。然后跳转过去吗？这样不就直接转换</p>
<h2 id="8295A和8253-timer"><a href="#8295A和8253-timer" class="headerlink" title="8295A和8253 timer"></a>8295A和8253 timer</h2><p>详解8259A<br><a href="https://blog.csdn.net/longintchar/article/details/79439466">https://blog.csdn.net/longintchar/article/details/79439466</a><br><a href="https://baike.baidu.com/item/8253%E8%8A%AF%E7%89%87/3699917">https://baike.baidu.com/item/8253%E8%8A%AF%E7%89%87/3699917</a></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title> rcore学习笔记</title>
    <url>/os/rcore%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="rcore学习笔记"><a href="#rcore学习笔记" class="headerlink" title="rcore学习笔记"></a>rcore学习笔记</h1><p>这是我这几天学习rcore-Tutorial第三版时的笔记, 汇总到了一起.<br><a href="#lab1%E4%B8%AD%E6%96%AD">lab1</a> 学习了不少RISC-V的中断相关的基础知识, 之后补的中断相关的知识也补在这里了<br><a href="#lab3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">lab3</a>, <a href="#lab4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6">lab4</a> 对实现细节写得详细一些, 稍微看懂一点代码就写上去了, 很多函数的实现细节都写下来了.</p>
<p>有的地方还留下了一些疑问没有解决, 自己也查了资料但没有找到答案, 如果去掉感觉有可能产生误导, 所以就留着了.</p>
<h2 id="lab1中断"><a href="#lab1中断" class="headerlink" title="lab1中断"></a>lab1中断</h2><p>回顾ucore, ucore的lab1也主要讲了中断, lab2讲分页<br>ucore的进程管理分了好几个lab, 内核进程, 用户进程, 进程调度.</p>
<p>添加了interrupt/context.rs, 文件也是一个mod, interrupt文件夹也是一个新的mod, 现在rust2018, 既可以采用src/interrupt/mod.rs, 也可以用src/interrupt.rs来代表整个文件夹作为mod.</p>
<p>由于中断说起来比较顺口, 因此下文中部分地方说中断这个词的时候其实既包括中断又包括异常, 也就是包括那些会跳转到trap vector的事件.</p>
<h3 id="CSR-是什么"><a href="#CSR-是什么" class="headerlink" title="CSR 是什么"></a>CSR 是什么</h3><p>Control and status registers, 大部分是处理特权相关的寄存器. 为操作系统程序提供特权, 方便管理用户态程序.</p>
<p>操作这相关的寄存器的包装, riscv这个crate, 这是相关的文档.<br><a href="https://docs.rs/riscv/0.6.0/riscv/register/index.html">https://docs.rs/riscv/0.6.0/riscv/register/index.html</a><br>dependencies里写的居然是rcore自己的fork, 而且比官方的多了特别多的commit, 太神奇了. 因此可能有我们rcore自己的fork实现的东西, 而文档里没有.</p>
<h3 id="RISC-V中断"><a href="#RISC-V中断" class="headerlink" title="RISC-V中断"></a>RISC-V中断</h3><p>比较关键的一点是sbi做什么, 而操作系统做什么<br><a href="https://github.com/riscv/riscv-sbi-doc/blob/master/riscv-sbi.adoc">https://github.com/riscv/riscv-sbi-doc/blob/master/riscv-sbi.adoc</a><br>可以看看上面这个文档.<br>一个稍微比较重要的理念是supervisor态和user态都可能是虚拟化的, 只有m态不是虚拟化的. 因此一些对虚拟化有用的操作都不能直接从s态掌控. 包括时钟和ipc. 硬件线程间的通信.</p>
<h4 id="异常-中断委托"><a href="#异常-中断委托" class="headerlink" title="异常/中断委托"></a>异常/中断委托</h4><p>委托机制的使用: 默认是所有中断和异常都转到m模式的mtvec, 通过设置mideleg/medeleg寄存器可以设置把哪些中断和异常委托给s模式.</p>
<p>下面这段话是privileged isa手册中说的</p>
<blockquote>
<p>Some exceptions cannot occur at less privileged modes, and corresponding x edeleg bits should be hardwired to zero. In particular, <code>medeleg[11]</code> and <code>sedeleg[11:9]</code> are all hardwired to zero.</p>
</blockquote>
<p>最后一句的意思是m模式产生的ecall异常无法被委托, s模式下的ecall和m模式下的ecall在sedeleg中无法被委托给user模式.</p>
<p>所以在tutorial中具体哪些中断被委派了? 启动的时候opensbi会打印委派寄存器的值如下.<br>MIDELEG : 0x0000000000000222<br>MEDELEG : 0x000000000000b109<br>mideleg的bit为分布和mip和mie相同, medeleg的bit分布对应那张异常的编号的表.<br>分析一下得知:<br>地址对齐异常, 断点异常, 用户模式的ecall, 三种页异常(读写和指令) 被委派.<br>中断有: s态软件中断, s态时间中断, s态外部中断 被委派</p>
<p>TODO 为什么user态的三个中断没有被委派?? user态中断是m态先处理还是s态先处理??</p>
<h4 id="中断的屏蔽"><a href="#中断的屏蔽" class="headerlink" title="中断的屏蔽"></a>中断的屏蔽</h4><p>sstatus的SIE位是总开关, 每个单独的中断也可以针对性地屏蔽, 在sie寄存器有对应的屏蔽位. sie和sip这两个寄存器中, 只有被m态委派的对应位能够修改.</p>
<h4 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h4><p>中断寄存器stvec指向的是中断的入口. 不像x86有一长条的中断向量表. 有两种模式, 向量模式和直接模式, 直接模式用一个地址处理所有中断和异常, 向量模式则会让不同中断跳转到不同的位置, 在基地址的基础上加上一定的偏移量, 而异常还是直接跳转到基地址.<br>mtvec<a href="vec%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E5%AF%B9%E9%BD%90%E4%BD%BF%E5%BE%97%E6%9C%80%E4%BD%8E%E4%BD%8D%E6%97%A0%E6%95%88">0</a>设置为1可启用向量模式中断, 根据中断原因x将PC设置为(base + 4x), 也就是跳转到不同的地址.</p>
<p>产生中断时各种中断相关的位会被放到对应的previous位中, 之前的权限模式被放到sstatus的SPP.</p>
<p>执行相关的sRet指令的时候, 类似于产生异常的逆过程. 1是会把sepc恢复到pc, 2是sstatus中各种previous位都恢复到原来的位置. mret, uret类似.</p>
<h3 id="中断过程梳理"><a href="#中断过程梳理" class="headerlink" title="中断过程梳理"></a>中断过程梳理</h3><p>之前lab0完成了最小的启动, 通过sbi接口打印字符<br>本次lab1的代码主要完成的是中断相关. 接到控制权后转到了entry.asm 将bss段作为栈, 然后调用rust_main.</p>
<h4 id="中断准备"><a href="#中断准备" class="headerlink" title="中断准备"></a>中断准备</h4><p>正是因为rust_main被汇编调用, 因此声明的时候要加上extern “C”从而使用C的abi.<br>rust_main 作为初始化代码, 刚启动就执行的代码, 自然是调用各种初始化函数. 这里调用中断初始化, 这部分代码单独放到一个mod内了, 也就是interrupt文件夹. </p>
<p>具体来说, 使用global_asm宏引入了interrupt.asm, 在要用到的地方用extern “C” 声明函数, 最后使用write写入__interrupt地址到stvec.这里把写入stvec寄存器也放到unsafe内的原因是这个函数声明的作用域仅限unsafe作用域内.</p>
<p>main函数中调用interrupt模块的初始化, 完成中断的准备. 中断的初始化主要做两件事, 把准备好的中断处理函数加载到trap vector寄存器stvec, 和打开中断总开关和对应的分开关.</p>
<p>进入interrupt模块的初始化函数, 分别是handler的初始化和timer的初始化.handler的初始化函数设置了stvec寄存器为interrupt.asm中符号<code>__interrupt</code>的地址, 同时开启sie寄存器中s态外部中断的开关 TODO 外部中断有哪些??.<br>timer的初始化函数则打开了sie中的s态时钟中断, 和中断的总开关, 并且设置了第一次时钟中断.</p>
<p>那Sstatus寄存器的SIE位负责的是中断总开关, 而类似ebreak这样的是异常, 所以不设置这个位也能进入trap处理. 当lab1后半部分用到时钟中断的时候就要设置SIE位打开总开关了.</p>
<h4 id="中断发生"><a href="#中断发生" class="headerlink" title="中断发生"></a>中断发生</h4><p>中断随时可能来, 发生的时候, 可能程序执行到一半, 即使是一些临时寄存器也可能正在使用. 因此不能破坏任何现场.</p>
<p>断点异常和S态时钟中断都被opensbi在deleg系列寄存器中委托过了, 因此这两个中断产生时就会转到我们S态的中断向量处.</p>
<p>当有中断或者异常发生的时候就会跳转到之前设置好的<code>__interrupt</code>处, 硬件只是会修改sepc, scause, stval等寄存器的值, 而不像x86会直接保存到栈上. 保存到栈上全靠我们操作系统的指令. 而<code>__interrupt</code>主要做的就是保存现场并恢复.<br>首先是把各个寄存器压栈形成Context, Context的结构并不复杂, 32个通用寄存器, 加上sstatus, sepc. (riscv的pc不在32个通用寄存器里)<br>然后将栈上的Context地址放到a0, 把scause放到a1, 把stval放到a2, 最后jal(jump and link) 实现跳转. 因为函数调用约定就是用的jal调用函数, ret返回. link代表把下一个指令的地址放到link寄存器中.<br>当handle_interrupt函数返回的时候, 就回到了汇编代码interrupt.asm中, 到了__restore这个部分, 自动开始了恢复中断的过程.</p>
<p>sscratch是一个单纯用来存数据的寄存器, 在tutorial中, sscratch在用户态用来保存内核栈的地址, 内核态是0, 因为进入内核态(进入中断)的时候os把它清零.<br>之后为了支持用户态程序, 就需要用到sscratch, 先切换栈再保存Context, 而我们lab1还是一直内核态, 内核态发生中断, 就可以直接保存各种寄存器在当前栈上, 取出栈上的指针作为Context结构体的借用传入interrupt_handler.<br>sstatus里的带P(previous)的位会被设置好, 因此需要保存sstatus. 而scause和stval就直接看作局部于这次中断处理的临时变量(handle_interrupt的参数), 不保存, 在中断处理的过程中用寄存器传递.</p>
<p>os/src/interrupt.asm 内含中断保存现场__interrupt, 和恢复现场__restore<br>首先sp减34<em>8开辟空间, 保存时使用以sp为基地址的栈上偏移量寻址Context成员(类似栈上临时变量), 为了sp(x2)保持不变, 首先保存x1, 然后利用空闲出来的x1去计算原来的sp, 也就是把sp加34\</em>8保存到x1, 再保存x1(作为sp(x2)), 再依次保存各种寄存器.<br>恢复的时候最后恢复sp即可.</p>
<p>handle_interrupt函数直接根据cause来调用不同的函数处理. 如果是断点异常, 就打印出来, 将PC加2(看来使用了C拓展减少了指令长度), 时钟中断就调用tick函数, 默认就调用fault函数panic并且打印未解决的异常.</p>
<h4 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h4><p>现在RISC-V的timer一般都是内置在cpu内的, 不像x86是通过外部芯片产生时钟中断.</p>
<p>每次时钟中断的时候, 都会从中断处理程序那走一遭, 然后调用tick函数计数并继续设置下一次时钟. 目前设置的是每10 0000条指令产生一次时钟中断</p>
<blockquote>
<p>S模式不直接控制 时钟中断 和软件中断，而是使用 ecall指令请求 M模式设置定时器或代表它发送处理器间中断。该软件约定是监管者二进制接口 (Supervisor Binary Interface)的一部分。</p>
</blockquote>
<p>上面这句话来自那本中文的《riscv手册》. 虽然时钟的设置是通过sbi接口, 也就是ecall指令去使用m态程序(opensbi)提供的服务, 但时间到了的通知, 还是通过S态时钟中断. (猜测是opensbi设置时钟, 得到m态的时钟中断信号的时候, 传递下来, 产生S态的时钟中断信号.)</p>
<p>由于没有一个接口来设置固定重复的时间中断间隔，因此我们需要在每一次时钟中断时，设置再下一次的时钟中断.</p>
<h4 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h4><p>ebreak指令会产生断点异常. 无论是ebreak还是ecall, 产生异常时的sepc都是指向该指令, 而不是下一条指令.</p>
<p>??那其他异常呢? 是下一条指令吗?? TODO</p>
<h4 id="中断结束"><a href="#中断结束" class="headerlink" title="中断结束"></a>中断结束</h4><p>当handle_interrupt函数返回的时候, 返回到调用它的interrupt.asm中的jal指令之后, 开始恢复之前保存的现场. 直接把各个保存的寄存器恢复, 这样寄存器的状态就是发生中断时的状态. 恢复现场后, sstatus和sepc也恢复了, sret, 返回的时候将pc设置为sepc. 并且恢复sstatus寄存器, 把里面的previous位都还原. 如果中断之前是打开中断的状态, sret后也会回到打开中断状态. 最终恢复到中断前被打断的位置继续执行。</p>
<h3 id="interrupt-pending-寄存器"><a href="#interrupt-pending-寄存器" class="headerlink" title="interrupt pending 寄存器"></a>interrupt pending 寄存器</h3><p>machine/supervisor/user interrupt pending寄存器是提供有关正在等待的中断的信息.</p>
<p>这里我也没有彻底学懂, 不过rcore-tutorial没怎么用到.</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>当多个中断发生的时候, riscv首先处理特权级最高的, 特权级相同的时候按照 外部-&gt;软件-&gt;时钟的顺序处理(使得最差情况时的处理时间最小). 因此当很多中断同时发生的时候, 或者ISA中断服务例程执行的时候, 其他中断却来了, 此时产生了中断pending.<br>让当前的中断例程能感知到新中断的存在有一定的作用, 我临时搜索了一下发现, 在arm架构中好像就有相关的应用. 看到一个是应用是省略相继产生的中断间的重新弹栈压栈, 提升性能.</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>当从mip(xip)寄存器中获取值的时候, 得到的是对应寄存器和对应中断产生信号的OR之后的值. 也就是如果这个中断真正在等待, 对应的pending位就为1.</p>
<p>高特权级如果设置了低特权级的对应中断的pending位, (不知道是回到对应特权级的时候还是立刻?)就会产生对应的中断. 如, m态的程序就可以通过设置mip对应的supervisor的中断pending位, 从而让低特权级的程序产生中断. 各种m态的中断的pending位在mip寄存器中是只读的, mip中对应低特权级的pending位则既可读, 也可以写触发上述效果.<br>S态软件中断, U态软件中断(基本上)靠这种方式产生. </p>
<h2 id="lab2内存管理"><a href="#lab2内存管理" class="headerlink" title="lab2内存管理"></a>lab2内存管理</h2><p>包括临时堆内存管理, 物理内存管理.</p>
<h3 id="临时堆内存管理"><a href="#临时堆内存管理" class="headerlink" title="临时堆内存管理"></a>临时堆内存管理</h3><p>ucore中是先实现按页的物理内存管理, 再实现的任意大小的管理的. 而这里完全不一样, 先是bss段留了8M空间作为堆, 给操作系统动态内存分配用, 再去单独实现按页的物理内存管理.</p>
<p>这里我暂时使用临时堆内存管理这个新词, 表示为了使用rust提供的一些需要使用堆内存的数据结构而在bss段上划分出一块空间作为堆. rcore-tutorial这里我们直接使用现有的buddy system内存分配算法, 在代码中开辟8M大小的bss段空间(u8数组), 作为被分配的空间.</p>
<p>我们分配算法和rust的对接主要在于Trait GlobalAlloc, 实例化之后用 <code>#[global_allocator]</code>标记就可以使用动态内存分配了(可以使用一些需要动态内存分配的内置数据结构, 如Box, Vec等). 接口也是和C语言中malloc/free类似的接口: alloc和dealloc.</p>
<h4 id="bss-buddy-system实现细节"><a href="#bss-buddy-system实现细节" class="headerlink" title="bss+buddy system实现细节"></a>bss+buddy system实现细节</h4><p>直接分配u8 static数组,数组名字指向的就是对应的空间.<br>添加buddy system这个包. spin和lazy_static也顺便加上.<br>创建memory文件夹作为新的mod, 创建init函数被main调用. 创建一个HEAP全局变量作为分配器, 并在init函数里面把那个数组的内存初始化给它.<br>想把数组的名字作为指针, 只需要调用.as_str()然后as转换为usize就可以了.<br>这样, main函数调用完heap的init之后就可以分配堆空间了.</p>
<h4 id="使用自己的堆分配算法"><a href="#使用自己的堆分配算法" class="headerlink" title="使用自己的堆分配算法"></a>使用自己的堆分配算法</h4><p>也可以不使用buddy_system, 答案中的heap2使用自己的algorithm crate的bitmap_vector_allocator提供分配算法支持, 这里自己实现分配算法也可以很简单, 代码量挺少的.</p>
<p>堆分配算法和其他代码的接口一个是<code>#[global_allocator]</code>标注, 一个是init函数.<br>这里使用的是bitmap标记空闲, 以字节为单位, 查找时按照对齐要求的倍数顺序查找(作为内存的开头), 直到遇到了空闲处.<br>只标记4096字节, 最多只能管理4K的内存. 这里的实现也是对给定内存范围的对应内存的index(偏移)做分配, 每次分配得到的只是一个偏移, 需要去找到对应的内存地址.</p>
<p>不像buddy_system实现好了GlobalAlloc, 为了global_allocator要实现alloc::alloc::GlobalAlloc这个trait. 需要实现分配和回收两个函数, 传入的是core::alloc::Layout, 并且需要处理指针类型 *mut u8. 直接整个实现都是unsafe的. Heap全局变量也不再是简单的直接是一个实例, 而是在VectorAllocatorImpl的基础上包了一层Option, 再包UnsafeCell. UnsafeCell取内部的值需要get再as_mut, Option就直接unwarp, 就可以得到内部的VectorAllocatorImpl调用alloc/dealloc函数.</p>
<p>包一层Option有一个好处就是可以提供默认值. 初始化之前, Option里是None, 初始化函数使用replace函数替换成实例之后才能分配, 否则会在unwrap的时候panic</p>
<p>完成之后, 将main函数堆测试代码的两个循环数量从10000减少到100才能正常通过测试. 这个自己实现的算法毕竟管理的内存比较少.</p>
<h3 id="按页的物理内存管理"><a href="#按页的物理内存管理" class="headerlink" title="按页的物理内存管理"></a>按页的物理内存管理</h3><p>物理内存管理不像临时堆内存管理只是为了让我们操作系统自己用, 它是虚拟内存管理的基础. 否则的话只要直接把buddy_system的LockedHeap的init函数中传入的内存改成我们可用的所有内存范围, 就能让我们操作系统自己用上这些内存了.</p>
<h4 id="封装地址类型与frame-tracker"><a href="#封装地址类型与frame-tracker" class="headerlink" title="封装地址类型与frame tracker"></a>封装地址类型与frame tracker</h4><p>内存地址空间确实是非常常用的东西. 无论是分页内存管理还是mmio, 之后肯定会大量用到内存地址的. 因此这里封装出了地址类型.</p>
<ol>
<li>封装地址类和页号类</li>
<li>抽象实现From trait在地址和页号间相互转换</li>
<li>抽象实现地址转页号的向上/下取整</li>
<li>抽象实现和usize的加减输出操作.</li>
</ol>
<p>还要在memory中新建mod range. 提供对内存地址range的支持. 它在基础的core::ops::range基础上增加相互转换, 和len函数, 和迭代, 重叠检测, 虚拟物理相互转换, 取下标, 包含检测的功能.</p>
<p>frame tracker 作为物理页面的智能指针, 继承PhysicalPageNumber, 实现Drop.<br>frame模块除了frame_tracker的实现, 同时承载分配相关的实现: allocator.rs 对分配算法进行包装, 对接frame tracker和分配. 分配算法实现Allocator trait(一次分配回收一个元素的index), 包装后提供初始化创建(起始物理页号和页数量), 分配一个页(frame tracker), frame tracker析构的时候自动调用回收.<br>由于是简单的一次分配一个元素, 而且可以是离散的, 简单地使用一个栈进行分配. 创建StackedAllocator, 在allocator.rs中作为AllocImpl, 就会使用这个算法了.</p>
<p>frame tracker创建的时候不会自动申请页面, 因此想要获得frame tracker需要通过allocator分配, 不能自己构造.</p>
<h4 id="分配哪些内存"><a href="#分配哪些内存" class="headerlink" title="分配哪些内存"></a>分配哪些内存</h4><p>可以直接根据qemu内存映射, riscv从0x8000_0000开始到0x8800_0000这128M初始内存, 直接硬编码拿来. 硬编码在 MEMORY_END_ADDRESS, 另外还要设置这些全局变量KERNEL_END_ADDRESS, MEMORY_START_ADDRESS, KERNEL_HEAP_SIZE.</p>
<p>在ucore中, 一般以函数指针结构体作为接口, 让不同的分配算法提供相同的接口. 而且还花大量精力, 使用Page结构体, 链表组织空闲页面.(物理内存管理), 而我们这里实现的就简单得多, 对物理页的下标直接管理.</p>
<h4 id="FrameAllocator"><a href="#FrameAllocator" class="headerlink" title="FrameAllocator"></a>FrameAllocator</h4><p>实现单页单页的物理内存的分配和回收. 内部使用的算法是StackedAllocator, 非常简单, 一个Vec, 新建的时候把一段物理内存范围输入, 每次分配取栈顶的一页, 每次回收页就压入栈中. 按照单页的分配和回收使得实现起来非常简单, 时间空间复杂度也会很低.<br>接着在StackedAllocator基础上包装出FrameAllocator, 把对下标的分配转化成真正的内存地址, 并且返回时返回Frame Tracker.</p>
<p>物理内存的分配器目前只实现的单页单页的分配和回收, 这一点我之前其实觉得挺合理的, 因为现在离散式虚拟内存技术已经非常成熟, 我们操作系统用到的现在全都是虚拟地址, 需要”连续的内存”时也一般是需要连续的虚拟地址空间, 因此物理地址的分配完全可以是这样一页一页离散的.<br>但是之后的lab可以看到, DMA确实出现了需要连续的物理内存空间这种需求, 看来这里的实现确实值得改进…</p>
<h3 id="用到的其他小知识点"><a href="#用到的其他小知识点" class="headerlink" title="用到的其他小知识点"></a>用到的其他小知识点</h3><p>pub(super) 指只对父模块是public的<br><a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">https://doc.rust-lang.org/reference/visibility-and-privacy.html</a></p>
<p>KERNEL_END_ADDRESS是lazy_static, 因为不用会报错”pointer-to-integer cast” needs an rfc before being allowed inside constants</p>
<p>下面这个impl代表某种类型, 而且最终会被确定下来<br><a href="https://doc.rust-lang.org/std/keyword.impl.html">https://doc.rust-lang.org/std/keyword.impl.html</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">iter</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Iterator</span>&lt;Item = T&gt; &#123;</span><br><span class="line">    (<span class="keyword">self</span>.start.into()..<span class="keyword">self</span>.end.into()).map(T::from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这句话的下划线似乎代表让编译器推断类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> offset = ptr <span class="keyword">as</span> <span class="built_in">usize</span> - &amp;HEAP_SPACE <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br></pre></td></tr></table></figure>

<h2 id="lab3虚拟内存管理"><a href="#lab3虚拟内存管理" class="headerlink" title="lab3虚拟内存管理"></a>lab3虚拟内存管理</h2><h3 id="Sv39页内存管理"><a href="#Sv39页内存管理" class="headerlink" title="Sv39页内存管理"></a>Sv39页内存管理</h3><p>Sv39最大支持512G地址空间, 分为3级页表. 每级页表大小都是一页, 因为8B * 512 = 4K.<br>最高级的页表, 每一项表示1G的地址空间, 第二级页表每项表示2M地址空间, 最低级的页表每一项表示4K地址空间.<br>虚拟地址空间64位只有低39位有效, 63-39 位的值必须等于第 38 位的值. 也就是说, 根据最高位是不是1, 512G地址空间被分为低256G(高位都是0), 和高256G(高位都是F).</p>
<p>39位的划分: 页内12位 + 9 + 9 + 9<br>对应的内存大小: 每页4K, —(512页)—&gt; 2M -(512)-&gt; 1G -&gt; 512G<br>十六进制表示: 0x1000 -&gt; 0x20 0000 -&gt; 0x4000 0000 -&gt; 0x80 0000 0000<br>现在架构中最大可寻址的物理地址有56位. 也就是有56-12=44位标识页<br>而页表项中<code>[53-10]</code>这44位用来标识一个物理页. 也就是物理地址的过高位和低12位去掉之后还要右移两位才可以对应上页表项中. 页表项内低10位自然就是标志位. 页表项最低位(Valid位), 为0则表示该页表项无效.</p>
<p>然而三级和二级页表项不一定要指向下一级页表, 可以作为大页… 如果RWX位全0才是指向下一级页表, 否则作为大页, 项中指向映射的开始页, 向后自动映射2M/1G内存. 这方法厉害啊, 可以在线性映射的时候节约不少内存空间. 另外, 大页也需要按照自己的大小对齐.</p>
<p>satp寄存器指向页表. 要在修改 satp 的指令后面马上使用 sfence.vma 指令刷新整个 TLB。手动修改一个页表项之后可以通过在sfence.vma后面加上一个虚拟地址来刷新单独的页表项中这个虚拟地址的映射.</p>
<h4 id="页表工作方式"><a href="#页表工作方式" class="headerlink" title="页表工作方式"></a>页表工作方式</h4><ol>
<li>首先从 <code>satp</code> 中获取页表根节点的页号，找到根页表</li>
<li>对于虚拟地址中每一级 VPN（9 位），在对应的页表中找到对应的页表项</li>
<li>如果对应项 Valid 位为 0，则发生 Page Fault</li>
<li>如果对应项 Readable / Writable 位为 1，则表示这是一个叶子节点。<br>页表项中的值便是虚拟地址对应的物理页号<br>如果此时还没有达到最低级的页表，说明这是一个大页</li>
<li>将页表项中的页号作为下一级查询目标，查询直到达到最低级的页表，最终得到页号</li>
</ol>
<h3 id="内核启动"><a href="#内核启动" class="headerlink" title="内核启动"></a>内核启动</h3><h4 id="内核地址空间的变化"><a href="#内核地址空间的变化" class="headerlink" title="内核地址空间的变化"></a>内核地址空间的变化</h4><p>内核的地址空间要抬高, 在512G虚拟地址中不是平移256G. 数据段起始地址变成0xffff ffff 8020 0000, 在Sv39看来是0x7f_8020_0000 而原来是0x00 8020 0000,<br>多了0x7f 0000 0000, 也就是平移了508G.</p>
<p>另外观察到: 0x80200000 = 2G + 2M</p>
<h4 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h4><ol>
<li>0x80200000处(entry.asm)使用汇编开启分页模式</li>
<li>开启分页模式的一瞬间, 当前的PC还在原来的位置, 因此需要映射0x80200000附近的位置, 同时需要映射0xffffffff80200000 附近的位置 直接使用大页映射, 4K空间作为最高级页表, 映射两个1g, 简单方便省内存. (这里之后的lab会为了访问磁盘设备需要再映射1g的页).</li>
<li>跳转到rust内(rust_main)</li>
</ol>
<h3 id="代码变化梳理"><a href="#代码变化梳理" class="headerlink" title="代码变化梳理"></a>代码变化梳理</h3><p>内核启动之后, rust_main在之前的初始化的基础上, 我们还会新建一个kernel的MemorySet内存地址映射, 并激活它. 这里的MemorySet更多主要是为了之后的进程的地址空间映射准备的. 之后lab的main函数在初始化的时候就不会再激活这样的映射了.</p>
<p>需要修改的地方有:</p>
<ol>
<li>ld脚本需要修改链接的基址, 这个比较简单</li>
<li>启动的asm文件, 需要加上临时页表, 和装载临时页表的语句</li>
<li>加入虚拟地址结构体, 实现一些相关trait, 增加一个偏移量常量KERNEL_MAP_OFFSET</li>
</ol>
<p>修改完这几个, 内核依然能够正常运行进入rust_main.<br>接着修改, 下面这前两步的工作量最大</p>
<ol>
<li>封装页表项, 页表等</li>
<li>实现MemorySet, 和内部的Mapping和Segment </li>
<li>main函数中新建kernel类型的映射并激活</li>
</ol>
<h4 id="entry-asm"><a href="#entry-asm" class="headerlink" title="entry.asm"></a>entry.asm</h4><p>这里只说说这个页表项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.quad (0x80000 &lt;&lt; 10) | 0xcf</span><br></pre></td></tr></table></figure>
<p>由于取页号放到第10位开始的位置, 也就相当于0x8000 0000 &gt;&gt;12 &lt;&lt;10, 0xcf表示 VRWXAD这几个标志位均为 1, 表示这个页具有RWX属性.</p>
<h4 id="虚拟地址的封装-memory-address-rs"><a href="#虚拟地址的封装-memory-address-rs" class="headerlink" title="虚拟地址的封装 memory/address.rs"></a>虚拟地址的封装 memory/address.rs</h4><p>完善之前物理地址的封装, 加上虚拟地址</p>
<ol>
<li>指针转换为虚拟地址, 实现这个trait, 这样任何指针类型都可以直接转虚拟地址类型</li>
<li>deref_kernel和deref可以用地址类型转换成任意类型的指针, 而且生命周期是static的. pageNumber类型的deref使得可以直接获得页表大小的u8数组.</li>
<li>对VirtualPageNumber类型实现levels函数, 获得三级页号.</li>
<li>也为address类型实现page_offset函数, 取得页内偏移.</li>
</ol>
<h4 id="实现页表-memory-mapping"><a href="#实现页表-memory-mapping" class="headerlink" title="实现页表 memory/mapping"></a>实现页表 memory/mapping</h4><p>不仅封装了页表, 页表项, 还封装了mapping结构, 类似ucore的vma</p>
<ol>
<li>page_table_entry.rs 封装页表项. 实现了Flags类, 表示每个entry低8bit的标志位. 用implement_flags宏抽象标志位的读的实现. 提供了address函数, page_number函数用来找到页表项指向的页面, 实现了flags函数获取flags, 还有is_empty函数, has_next_level函数, 最后实现了Debug trait的打印</li>
<li>page_table.rs 封装了页表(页表项数组). 这里还需要把之前的frame_tracker增加了derefMut到u8数组的trait. 封装了PageTableTracker作为PageTable的智能指针. 内部包含一个FrameTracker, 实现自动释放内存的功能. 和PageTable只有一个Deref的距离. 创建页表时要申请物理页将FrameTracker包装为PageTable的智能指针类型再使用. FrameTracker管理一个页, 并且能转换为任何类型, 作为任何类型的智能指针. 而包装了FrameTracker的PageTableTracker则更加具体, 仅仅作为页表的智能指针. </li>
<li>segment.rs 封装了线性映射类型, 实现了遍历某个映射中每个页的功能. 映射有两种类型, 操作系统使用的线性映射, 和按帧分配的离散映射. 后者只能遍历虚拟页, 前者可以直接使用虚拟转物理的转换trait遍历物理页.</li>
<li>mapping.rs 负责管理各种页表. 使用vec保存PageTableTracker这个智能指针, 同时另外保存根页表的物理页号(对应页表寄存器). 实现了激活该页表activate函数, new函数新建页表同时分配根目录表, map函数映射一个segment, map_one函数映射一页, unmap移除映射, 会创建页表的find_entry函数(和ucore中那个函数类似), 虚拟地址查找物理地址的lookup函数.</li>
<li>memorySet总览全局, 包含了Mapping结构体和Segment数组, 实现添加和删除映射的总接口, 调用下部的mapping的添加和删除映射的接口. 另外还实现了让main函数调用的new_kernel新建memorySet和各种映射的函数, 之后的lab里还要实现读取ELF创建映射的函数</li>
</ol>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h4><p>mapping负责管理页表, 整个文件100多行, 非常重要. </p>
<ol>
<li>map_one函数, 映射一个页, 调用find_entry找到对应的entry, 为空则新建并填入Page: <code>*entry = PageTableEntry::new(ppn, flags);</code>由于page_table就是page_table_entry数组, 因此直接赋值由于实现了Copy, 就导致页表项写入.</li>
<li>lookup函数, 这个函数是静态的!! 首先拿出当前的页表寄存器内的值, 找到页目录表. 把参数的虚拟地址转为页号调用levels函数方便获取每级下标. 然后先取好最高级页表的下标, 再在循环中如果有下一级页表, 不断取下标, 直到页表项为空(判断valid???), 或者不再有下一level, 此时的entry就保存了base地址, 加上虚拟地址低位的offset(不一定只有12位)得到真正的地址.</li>
<li>find_entry函数, 这个函数和lookup有些类似, 但是是从自己的mapping实例的页表物理页号中找到页表, 找的过程中如果页表不存在就直接分配新的页作为页表, 总是能找到页表项, 而且找的总是代表4k一页大小的第三级页表项.</li>
<li>unmap函数, 调用find_entry函数并调用clear</li>
<li>map函数, map一整个segment. 如果是线性映射, 则遍历虚拟地址不断调用map_one填页表项, 有数据复制数据, 最重要的特点是不用分配物理页面. 如果是离散映射, 则遍历虚拟地址不断分配页面, 把分配到的页面填充0. 拷贝数据的时候映射还没建立, 需要从物理地址加offset这个通用的访问物理内存的映射来复制, 还要考虑区间与整页不对齐的情况, start变量指从页开头开始的偏移, 指向需要复制数据的开始位置. stop变量也是偏移. 每次循环只处理一页. 当开始位置大于当前页的起始位置, 说明是第一页, 需要从开始位置而不是页开头进行复制. 否则就从开始位置复制. 当结束位置减去页起始位置, 小于页的大小的时候, 就说明是最后一页, 需要复制到结束位置为止, 而不是页结束位置.</li>
</ol>
<h4 id="MemorySet"><a href="#MemorySet" class="headerlink" title="MemorySet"></a>MemorySet</h4><p>MemorySet 就是一个进程的所有内存空间管理的信息了. 内部包含Mapping, 负责管理页表, 用一个数组保存PageTableTracker(自己管理页表占用的物理页面), 并且另外保存页目录表. 包含segment数组, 内含每个映射, 和allocated_pairs数组, 保存虚拟页号到物理页智能指针(FrameTracker)的二元组, 拿着分配的物理页.<br>简而言之, MemorySet包含1页表2映射3物理页</p>
<p>添加新的映射的时候, 一方面要添加到页表里去, 一方面要加入映射vec保存, 如果申请了物理页要放到物理页vec中. 还检查是否和当前内存空间重叠.</p>
<p>由于内核换了位置(使用了虚拟地址), 需要在memory/config中加入MMIO 设备段内存区域起始地址: DEVICE_START_ADDRESS, 和DEVICE_END_ADDRESS, 另外还要将kernel_end_address 改成虚拟地址, config里的部分高位地址都要改改.<br>(MMIO表示memory mapped io. 访问这里的地址就是直接与外设交互)</p>
<h2 id="lab4线程与调度"><a href="#lab4线程与调度" class="headerlink" title="lab4线程与调度"></a>lab4线程与调度</h2><p>这个lab工作量非常大.</p>
<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>ucore中把初始化的执行包装成idleproc, 调用创建内核线程的函数创建init_main线程. 不过idleproc除了初始化外没有执行任何实质性的任务, 不存在也没有关系.<br>我们在rcore-tutorial中则直接切换到新来的线程. 而且切换后甚至原本我们使用的栈 bootstack也可以被回收.</p>
<p>当前的内核由于只用一个单核cpu, 只有一个内核栈, 并且不支持中断的嵌套. 而且现在中断的时候无论是内核态还是用户态都会交换sp和sscratch, 这就导致如果嵌套会导致交换两次出现问题. 需要改进为用户态切换栈, 内核态不切换栈才能为支持嵌套中断打基础.</p>
<p>进程和线程辨析: 线程是运行和调度的单位. 进程则包含了地址空间, 同一个进程的不同线程的地址空间是共享的.(意味着高位地址处会映射多块栈给不同的线程) 新建线程和Context都需要传入process结构体</p>
<p>切换则直接通过保存当前中断栈上的Context, 把下一个要执行的线程的Context放到栈顶实现.</p>
<h3 id="代码变化梳理-1"><a href="#代码变化梳理-1" class="headerlink" title="代码变化梳理"></a>代码变化梳理</h3><ol>
<li>interrupt/context.rs 完善之前的Context实现. Context结构体不变, 为Context实现了Default, 使用全零作为Default. 实现了获取/设置 栈指针/返回地址的四个简单函数. 实现了按照调用规则把参数写入Context内对应寄存器的函数, 和传入函数地址, 参数, process结构体新建Context的函数. </li>
<li>新建process文件夹作为mod</li>
<li>增加全局Processor用到的Lock, 原本使用的是unsafeWrapper, 在algorithm目录内.<ol>
<li>config.rs 包含了每个线程的运行栈大小, 和共用的内核栈大小, 目前都是512K</li>
<li>process.rs process结构体当前只有is_user标志位和memory_set内存空间. 有三个函数, 新建内核进程的new_kernel, 从elf创建进程的from_elf函数(之后的lab才会添加), 映射新的虚拟地址的alloc_page_range函数(类似mmap)</li>
<li>kernel_stack.rs 内核栈也就是作为一个大小为KERNEL_STACK_SIZE的u8数组. 此外实现了push_context函数, 能在栈顶减去Context大小的位置强转为Context指针, 然后赋值写进去, 最后把这个指针返回. 同时暴露出全局变量作为共用的全局内核栈.</li>
<li>thread.rs Thread结构体包含id, 栈(虚拟地址range), 所属进程(arc+读写锁包装的Process结构体), 和inner(用一个mutex包装一些可变数据结构). inner包含context和是否进入休眠的sleeping标志. 实现了Hash Eq这两个trait, Debug打印的trait. prepare函数用于准备执行该线程, 会激活页表, 清空并返回Context, park函数会暂停线程, 保存传入的Context. 新建线程的new函数需要传入Process, 要执行的entry_point, 和参数, 该函数会新分配一段空间(alloc_page_range)作为栈, 并构建新的Context, 最后打包新建thread并返回</li>
<li>processor.rs 包装调度器算法, 包装进程状态转移的操作.</li>
</ol>
</li>
<li>增加新的调度算法: 使用hrrn高响应比优先的调度算法, 放到process文件夹内. hrrnThread结构体对线程再次包装, 增加birth_time和service_count两个字段. 调度结构体HrrnScheduler则包含linkedList保存的hrrnThread和currenttime的二元组.</li>
<li>修改interrupt.asm支持切换线程, 加入交换sscratch的代码, 修改保存sp为保存sscratch. 恢复时保存弹出Context之后的栈到sscratch. 把a1放到sp使得<code>__restore</code>有返回值和参数这两种新的调用方法, 从而执行不同的线程.</li>
<li>修改interrupt_handler (init函数里面的增加各种中断使能的操作先不做, 后面的lab需要键盘输入的时候再加上), 修改时钟中断处, tick之后调用保存当前进程和准备下一个进程的函数, timer模块不变.</li>
<li>在interrupt/mod.rs中增加一个wait_for_interrupt函数. 给processor.rs中函数调用</li>
<li>修改timer模块init, 删除<code>sstatus::set_sie();</code> 这样main函数就不开中断, 执行内核线程的时候再接受中断</li>
<li>修改main.rs启动线程 main函数首先对各种东西进行初始化, 然后对线程的实现进行测试.</li>
</ol>
<h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="interrupt-context-rs"><a href="#interrupt-context-rs" class="headerlink" title="interrupt/context.rs"></a>interrupt/context.rs</h4><p>这里新建的时候Context中返回值寄存器设置为-1, 如果执行的函数返回了, 就会报错. 之后新版的代码似乎修改了这里, 能正常返回.</p>
<h4 id="process-process-rs"><a href="#process-process-rs" class="headerlink" title="process/process.rs"></a>process/process.rs</h4><p>process结构体也算是MemorySet的封装了, 新建的时候会新建MemorySet, 函数也是调用MemorySet的接口.</p>
<p>alloc_page_range函数类似于mmap吧, 基于memory_set提供的接口操作, 传入一个size, 返回分配好的地址范围. 首先把size向上取整到页倍数, 再用while循环从0x100_0000开始不断步进查找可用内存空间(memory_set的overlap_with), 可用则调用memory_set.add_segment增加映射.</p>
<h4 id="kernel-stack-rs"><a href="#kernel-stack-rs" class="headerlink" title="kernel_stack.rs"></a>kernel_stack.rs</h4><p>因为线程都有自己的栈映射在低地址区了, 函数调用关系的维护不靠内核栈, 内核栈只处理中断, 而且中断不会嵌套.<br>如果中断不嵌套, 那么Context总是在公用内核栈最顶上. 因此切换内核线程前可直接将Context放到栈顶上假装是正常的中断返回.</p>
<h4 id="thread-rs"><a href="#thread-rs" class="headerlink" title="thread.rs"></a>thread.rs</h4><p>prepare函数, 1激活了新线程的页表, 2把Context放到了公共内核栈的栈顶.<br>切换线程的时候都是这样假装是中断返回. 此时大概调用了park函数保存好了中断进入时那个线程的Context.</p>
<p>重点关注新建线程的函数.</p>
<ol>
<li>新建线程的时候用的栈, 是新映射分配的!!</li>
<li>新建的Context, 在切换的过程中还不会打开中断, 直到sret的时候中断才会打开.</li>
<li>是否是用户线程取决于Process的is_user.</li>
<li>返回的时候, is_sleeping是false. 这意味着一创建就开始执行? 不, 这只说明不是放到sleeping的队列而是放到scheduler的队列里</li>
</ol>
<h4 id="processor-rs"><a href="#processor-rs" class="headerlink" title="processor.rs"></a>processor.rs</h4><p>processor 主要是包装一下进程的状态转换操作, 调度靠每次prepare_next_thread中询问调度算法的操作, 主要靠timer_interrupt的时候的park+prepare组合拳. 当线程出现问题调用fault函数的时候, 就会调用kill/prepare组合拳</p>
<p>在这样单核的环境, 确实可以说调度器是局部于处理器的.</p>
<p>线程的组织上, 使用了hashbrown这个crate保存sleeping的thread, 需要调度的线程让调度算法去用自己的数据结构保存.</p>
<p>add thread会检查是否当前线程为None, 是则放入. 主要还是加入scheduler. 只有刚启动的时候, 和kill线程的时候会take当前的Option-thread 为none</p>
<p>确实, __restore作为函数调用只出现在processor的run里面, run函数只出现在rust_main里面. 只有刚开始的时候会刻意去调用__restore 毕竟,初始化的时候并不是调用的interrupt_handler, 不会返回到__restore. 而且使用的是boot_stack</p>
<p>执行的函数组合可以为 parl/kill [sleep] prepare_next_thread</p>
<h4 id="interrupt-rs"><a href="#interrupt-rs" class="headerlink" title="interrupt.rs"></a>interrupt.rs</h4><p>外部中断如果是键盘输入, 就会把字符push到STDIN里(fs/stdin.rs)TODO</p>
<h4 id="unsafeWrapper"><a href="#unsafeWrapper" class="headerlink" title="unsafeWrapper"></a>unsafeWrapper</h4><p>unsafe包装后能增加多少灵活性? 这里的unsafe一方面实现了&amp;self 转mut, 使得可以同时持有多个可变借用. 并且实现了(标记了)sync Trait, 使得可以多线程共享.</p>
<p>static unsafe wrapper 还增加了Phantom data成员, 表明该结构体确实拥有T类型的值的所有权, 让wrapper被drop的时候也能drop T.</p>
<h4 id="hrrn-scheduler-rs"><a href="#hrrn-scheduler-rs" class="headerlink" title="hrrn_scheduler.rs"></a>hrrn_scheduler.rs</h4><p>alloc::collections::LinkedList组织内部线程<br>对线程再增加了一层包装HrrnThread, 增加相关数据结构.<br>真正关键的只是一个.max_by()</p>
<h4 id="interrupt-asm"><a href="#interrupt-asm" class="headerlink" title="interrupt.asm"></a>interrupt.asm</h4><p>原来是直接把sp保存不切换栈, 现在是先交换sscratch再保存, 而且保存的时候是保存的原来的sp, 所以恢复的时候直接正常恢复就好. 只要把当前的栈放好到sscratch就行.</p>
<p>无论如何, 发生了中断就交换栈为sscratch. sscratch的值可能是什么?? 如果是单线程不嵌套中断的话, 一定是公共栈顶上?? 恐怕是的</p>
<p>riscv调用约定中, a0, a1既是第一个参数, 又是返回地址. 这设计强!!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    mv      sp, a0  # 加入这一行</span><br></pre></td></tr></table></figure>
<p>这样一方面可以调用__restore(context), 一方面也可以让interrupt_handler返回context指针. 也就是中断返回的时候, 如果不切换进程, 就返回当前的进程的context, 否则返回切换到的进程的context.<br>其次, 把第一个参数作为sp, 而sp不仅是当前Context的位置, 还是之后保存到sscratch的位置!!! 因此这个参数/返回值一定要放在作为栈的内存顶上</p>
<h4 id="interrupt-handler-rs"><a href="#interrupt-handler-rs" class="headerlink" title="interrupt/handler.rs"></a>interrupt/handler.rs</h4><p>这里打开了一些神奇的中断. <code>sie::set_sext();</code>这个应该只是使能sie寄存器的某个中断, 中断的总开关还是没有打开的.<br>在某些特殊地址写入数字就能在OpenSBI中打开中断?? 为什么??</p>
<p>handle_interrupt函数中, 每个单独的处理函数确实应该返回应该Result类型, 是错误则调用fault.</p>
<p>fault函数现在出现异常的时候会杀死当前的线程了, 传入的参数也变了<br>最重要的当然还是timer的时候调度一下</p>
<h4 id="lock-rs"><a href="#lock-rs" class="headerlink" title="lock.rs"></a>lock.rs</h4><p>为Mutex增加关中断的功能得到Lock类型. 则当获取其中内容的时候, 既关+保存了中断, 又独占了资源.</p>
<p>具体实现上, 上锁是在get函数中, 释放是在Drop的trait中.</p>
<p>同时实现了deref和deref mut, 可作为被包裹对象的智能指针使用.</p>
<p>另外实现了一个不上锁不关中断, 直接获得内部对象的unsafe_get函数, 用于PROCESSOR::run()的时候因为不会返回, 导致不会调用对应的析构函数</p>
<h3 id="线程的结束"><a href="#线程的结束" class="headerlink" title="线程的结束"></a>线程的结束</h3><p>目前, 内核线程的结束是靠设置自己线程的isDead变量, 然后触发中断的时候检查时结束的. 也就是说设置了这个变量后即使不使用ebreak, 用其他方式触发中断也会被结束.</p>
<h3 id="线程-进程的保存与组织"><a href="#线程-进程的保存与组织" class="headerlink" title="线程/进程的保存与组织"></a>线程/进程的保存与组织</h3><p>线程的组织上, 使用了hashbrown这个crate保存sleeping的thread, 需要调度的线程让调度算法去用自己的数据结构保存.</p>
<p>Arc RwLock包着进程, 创建新线程的时候会把Arc RwLock-进程的所有权要过来, 用clone可以多处持有. 似乎没有单独组织进程的地方, 父进程子进程之类的关系链接也似乎没有</p>
<h2 id="lab5-设备驱动与文件系统"><a href="#lab5-设备驱动与文件系统" class="headerlink" title="lab5 设备驱动与文件系统"></a>lab5 设备驱动与文件系统</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><ol>
<li>提供对ELF文件用户程序的解析</li>
<li>提供对磁盘映像的支持</li>
<li>实现系统调用支持</li>
<li>支持文件描述符</li>
</ol>
<h3 id="相关修改"><a href="#相关修改" class="headerlink" title="相关修改"></a>相关修改</h3><ol start="0">
<li>entry.asm 增加映射低位页表</li>
<li>main函数增加参数, 调用drivers的初始化函数</li>
<li>新建drivers文件夹, 在mod.rs中增加init函数, 调用设备树子模块的init函数</li>
<li>drivers/device_tree.rs 增加对device_tree这个库的依赖. init函数调用dtb遍历库, walk函数负责遍历生成的树.</li>
<li>修改makefile, 增加qemu的启动参数 增加TEST_IMG变量指向之后的磁盘镜像</li>
<li>增加drivers/bus文件夹并增加子模块virtio_mmio. </li>
</ol>
<h4 id="entry-asm-1"><a href="#entry-asm-1" class="headerlink" title="entry.asm"></a>entry.asm</h4><p>这里没想到增加了新的页表. 花了我差不多一个小时的时间去debug<br>当parse dtb, 得到磁盘的Header的时候, 这个header的位置在0x1000_8000, 位于低地址, 而我们此时还处于初始化的状态, 映射还是巨页映射, 只映射了0x8000 0000开头的1GB, (1GB是0x4000 0000).<br>更加恐怖的是, 此时的sscratch都没有值, 中断都无法正常进行.<br>当前的设计是中断一定切换栈, 每次中断的时候都是先交换sscratch和sp, 然后保存真正的原来的sp到栈上. 离开的时候先把sp弹出后的位置放到sscratch. 而第一次放入sscratch就是运行线程时假装中断返回的时候.<br>因此, 我在debug的时候, 第一次页访问异常, 进入中断的时候, 从sscratch中取来了(似乎是-1)未知的值, 作为内核栈放到sp, 然后在保存第一个寄存器的时候发生了第二次页访问异常. 这时又把sscratch和sp交换, 得到了正常的sp值, 反而正常处理了, 但是报错的地址好像是0xffff_ffff_ffff_ffec.<br>我在main函数加入了把kernel stack放到sscratch的汇编才正常得到了中断发生错误的地址.</p>
<h4 id="drivers模块"><a href="#drivers模块" class="headerlink" title="drivers模块"></a>drivers模块</h4><p>driver模块目前主要负责文件系统的driver. 对外暴露的接口是driver模块中的driver trait, 和DRIVERS这个组织各种驱动的数据结构.</p>
<p>模块的初始化函数在mod.rs中, 参数传入dtb地址, 负责调用解析设备树的device_tree::init, device_tree的walk函数则一边遍历, 一边判断是不是想要的设备, 这里单指对应磁盘的块设备, 找到则把这个节点传给对应的总线协议驱动程序, 这里是bus/virtio_mmio. 本次实验中找到块设备的节点后, 把节点里reg字段拿出, 转换为virtio_drivers(库)::VirtIOHeader类型, 就传给驱动程序的包装virtio_blk, virtio_blk::VirtIOBlkDriver内部包装的是mutex包装的virtio_drivers(库)::VirtIOBlk, 对外实现了driver的trait.</p>
<p>之后在fs中才会用到BlockDevice, 它包装driver, 实现rcore_fs的BlockDevice trait从而传入给SimpleFileSystem::open函数</p>
<p>层次关系:<br>virtio_drivers(库)::VirtIOBlk –包装–&gt; VirtIOBlkDriver(实现Driver) –包装–&gt; BlockDevice(实现rcore_fs的BlockDevice)</p>
<h4 id="driver-rs"><a href="#driver-rs" class="headerlink" title="driver.rs"></a>driver.rs</h4><p>这个模块包含了驱动接口driver trait, 描述驱动类型的DeviceType, 和lazy_static的DRIVERS.</p>
<p>Driver 这个trait, 使用时根据device_type返回的DeviceType, 来调用对应的方法, 现在这个trait中只有块设备相关的方法, 提供了用unimplemented宏表明没有实现这个方法的默认实现. 实现新的设备驱动的时候, 只需要加入新的方法即可.</p>
<p>DRIVERS保存所有驱动的数据结构, 方便获取驱动. 驱动是dyn Driver类型, 首先用Arc实现共享, 再通过Vec保存, 再加上读写锁保证多线程安全.</p>
<h4 id="device-tree-rs"><a href="#device-tree-rs" class="headerlink" title="device_tree.rs"></a>device_tree.rs</h4><p>device tree blob 确实是个标准. 其中头部的字段其实很多, 包括了dtb的版本等等. 我们现在只读取了前两个字段. 第二个字段size确实是包含整个dtb的大小的, 包括头部.<br><a href="https://www.devicetree.org/specifications/">https://www.devicetree.org/specifications/</a></p>
<p>这里init函数首先校验头部, 得到size, 再把整个dtb作为u8数组传入DeviceTree的crate中, 并且让遍历的walk函数递归遍历.<br>而walk函数则只是搜索compatiable字段为virtio,mmio的节点, 把节点传入virtio_probe进行初始化</p>
<h4 id="bus-virtio-mmio-rs"><a href="#bus-virtio-mmio-rs" class="headerlink" title="bus/virtio_mmio.rs"></a>bus/virtio_mmio.rs</h4><p>将传入的dtb节点的reg字段转为VirtIOHeader传入驱动程序进行初始化.</p>
<p>这里会遇到不少verify不对的设备, 因此如果verify函数调用失败或者没有reg字段就直接返回. 这里verify的时候就会访问1000_xxxx开头的低地址.</p>
<p>此外, 暴露了virtio_dma_dealloc, virtio_phys_to_virt, virtio_virt_to_phys这三个extern “C”且no_mangle的函数. 而且没有在我们代码中其他地方被调用. 这说明是库函数在C语言中或者汇编中调用了这两个函数. 根据名字看可能是virtio库.</p>
<h4 id="block模块和-block-virtio-blk-rs"><a href="#block模块和-block-virtio-blk-rs" class="headerlink" title="block模块和 block/virtio_blk.rs"></a>block模块和 block/virtio_blk.rs</h4><p>block模块的mod.rs里提供了对接驱动与文件系统的VirtIOBlkDriver包装. 而模块内部则是保存的块设备的Driver实现.</p>
<p>BlockDevice的实现主要是将Driver的返回bool值的read_block/write_block 函数转换成返回Result&lt;()&gt;的read_at/write_at函数, 另外实现假的sync函数</p>
<p>VirtIOBlkDriver的实现就是调用内部的Driver的read_block/write_block函数, 把返回的Result再用is_ok转成bool.</p>
<p>VirtIOBlkDriver则需要实现read_block/write_block的Driver接口, 另外给解析Node的virtio_mmio.rs:virtio_probe函数一个创建设备的add_driver函数. add_driver函数把header传给VirtIOBlk::new得到包装的内部驱动, 再把驱动包装上刚刚实现的VirtIOBlkDriver加入DRIVERS列表.</p>
<h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><p>模块的mod.rs 提供了lazy_static的全局变量ROOT_INODE, 初始化的时候获取第一个Block类型的driver, 用BlockDevice包装后传入SimpleFileSystem::open()函数, 返回值赋给ROOT_INODE. 也许是SimpleFileSystem实现了对INode的deref, 在ROOT_INODE上可以调用到inode_ext拓展INode实现的方法</p>
<p>还有init函数, 负责作为测试, main函数初始化的时候使用ls方法测试我们文件系统的功能.</p>
<h4 id="inode-ext-rs"><a href="#inode-ext-rs" class="headerlink" title="inode_ext.rs"></a>inode_ext.rs</h4><p>impl INodeExt for dyn INode 通过这种方法为已有的Inode类型增加功能. 额外实现了 ls这个直接打印而不返回值的函数, 和readall函数, 把所有内容读到<code>Vec&lt;u8&gt;</code>并返回.</p>
<h3 id="elf相关代码"><a href="#elf相关代码" class="headerlink" title="elf相关代码"></a>elf相关代码</h3><p>ELF文件也可以看作是一个地址空间. 因为它定义了各个段的映射关系.<br>MemorySet中增加根据ELF文件创建的from_elf函数, 它遍历elf文件的每个段, 根据大小和权限映射每个段.</p>
<p>首先在program_header中对每个为load类型的段, 读取开始地址和大小和数据和权限之后进行映射</p>
<p>process中也加入from_elf函数, 主要是调用MemorySet中的from_elf函数.</p>
<h3 id="sfs文件系统中的指向关系"><a href="#sfs文件系统中的指向关系" class="headerlink" title="sfs文件系统中的指向关系"></a>sfs文件系统中的指向关系</h3><p>文件夹inode -&gt; 文件entry -&gt; 文件inode -&gt; 文件数据</p>
<h2 id="lab6-用户程序-系统调用-文件描述符"><a href="#lab6-用户程序-系统调用-文件描述符" class="headerlink" title="lab6 用户程序, 系统调用, 文件描述符"></a>lab6 用户程序, 系统调用, 文件描述符</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>完全构建新的crate作为user程序的框架, 这里也要新建Makefile文件, 并且可以单独build</li>
<li>在外面新建makefile文件, 依次make两个子目录</li>
<li>中断处理中, 初始化时开启外部中断, 用户态的ecall异常时调用kernel模块的syscall_handler, 增加外部中断处理键盘输入</li>
<li>为线程增加打开的文件descriptor数组, 初始化创建的时候就放入STDIN, STDOUT.</li>
<li>fs中增加stdin和stdout全局变量</li>
<li>增加mod kernel<ol>
<li>condvar.rs 利用线程的睡眠实现条件变量</li>
<li>syscall.rs 系统调用的总入口.</li>
<li>process.rs 处理线程退出的系统调用</li>
<li>fs.rs 处理文件读取相关的系统调用</li>
</ol>
</li>
</ol>
<h3 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h3><p>类似于自己做一些rust标准库的事情.<br>首先是实现了ecall的包装,从而实现了sys_read, sys_write, sys_exit. 利用sys_write实现了print, println宏. 实现了对用户程序的输入输出的支持.</p>
<p>hello_world主要使用了输出.<br>nodebook可以把输入的字符回显.</p>
<h4 id="fs-stdout-rs-stdin-rs"><a href="#fs-stdout-rs-stdin-rs" class="headerlink" title="fs/stdout.rs stdin.rs"></a>fs/stdout.rs stdin.rs</h4><p>让标准输入和输出实现和文件一样的接口(INode)进行读写.</p>
<p>stdout没想到就是一个空结构体</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stdout</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后直接实现INode的方法, read和poll都返回不支持的错误, write不允许offset为非0.</p>
<p>标准输入stdin同理, 只允许offset为0, buf中没有值则等待一次条件变量, 否则进入读过程, 要么是stdin的buffer空了, 要么是buf不够长, 返回.</p>
<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><p>syscall_handler函数根据传入的系统调用号调用各个子函数, 重要的是子函数的返回值还代表了对当前进程的处理方式.</p>
<p>write: 根据fd在进程的descriptor内获取inode, 调用inode的write_at, 直接返回Proceed和返回值.</p>
<p>read: 调用inode的read_at, 然后根据返回值包装一下. 和write不同的地方在于, 如果返回值为0则park当前线程(阻塞), 此时已经在read_at内部等待了condvar, 调用等待时会把当前线程放入等待队列并sleep_current_thread. 之后syscall_handler在处理返回值的时候发现是Park类型会再切换线程.<br>直到之后external interrupt键盘输入-&gt;push到stdin中-&gt;条件变量notify-&gt;进程恢复调度.</p>
<h4 id="condvar"><a href="#condvar" class="headerlink" title="condvar"></a>condvar</h4><p>这里的条件变量利用的是线程的休眠, 等待条件变量时进入条件变量内部的队列, 线程休眠. 当notify时则唤醒进程.<br>只在fs/stdin.rs中被实例化并使用.</p>
<p>如果有多个线程同时等待标准输入?<br>因为现在的线程的标准输入标准输出都是公用的, 没有不同的tty终端的概念, 如果等待输入的线程去sleep了, 那新执行的线程如果还想读取输入的话, 那就会产生冲突了, 两个线程读取一个标准输入. 如果引入了不同的终端的概念, 能有多个标准输入相互区分开就不会冲突. 目前看来还是阻塞, 另外加入新的把线程放到后台的按键, 这样比较好.</p>
]]></content>
  </entry>
</search>
