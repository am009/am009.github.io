<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一句话的问题</title>
    <url>/%E4%B8%80%E5%8F%A5%E8%AF%9D/</url>
    <content><![CDATA[<h1 id="一句话的问题">一句话的问题</h1>
<p>很多问题的解决方案，虽然非常有用，但是概括起来不需要多少字，都汇总在这里。</p>
<span id="more"></span>
<p>[toc]</p>
<h3 id="windows下稳定的挂起执行">Windows下稳定的挂起执行</h3>
<p>https://github.com/winsw/winsw 不得不说比windows自带的task scheduler（任务计划程序）好太多。下面盘点一下task scheduler的坑点</p>
<ol type="1">
<li><p>启动失败后多久重新启动任务的选项，对于启动失败的定义完全不是返回值是否不为零，而是他有没有正常启动你的程序。也就是说完全不管你的返回值的。</p></li>
<li><p>从某个时间点后周期性重复的触发器，如果你设置无限重复，但是开始时间是过去，即使你选了那个错过了时间立刻启动也不管用。可以看到下次执行时间是几分钟后，但是几分钟后就是不给你执行。必须要把开始时间设置在几分钟后，正常触发一次。</p>
<p>https://superuser.com/questions/1676539/scheduled-task-does-not-run-after-being-re-enabled-again</p></li>
</ol>
<h2 id="稳定的给自己的推送接口">稳定的给自己的推送接口</h2>
<p>通过qq邮箱SMTP，发给自己（同一个邮箱），通过qq的QQ邮箱提醒接收</p>
<h2 id="方便地换硬盘重装系统">方便地换硬盘重装系统</h2>
<p>2022年9月13日 直接用DiskGenius的系统迁移功能，直接下免费版也能用。体验下来比<code>备份与恢复（win7）</code>好很多。但是<code>备份与恢复（win7）</code>用来给电脑做全盘备份还是不错的。</p>
<p><del>利用win10自带的 <code>备份与恢复（win7）</code> 借来一个大容量移动硬盘先备份，换硬盘之后恢复。</del></p>
<p>2021年12月19日 这个其实还是有很多槽点的。一旦你用usb安装盘进入恢复过程，它给你报个错，你就完全没有任何办法。。。之前成功过两次，但也遇到了几次没办法的情况。今天尝试DiskGenius的系统迁移功能，新硬盘通过硬盘盒，usb连接电脑，然后热迁移过去。</p>
<h2 id="将旧电脑系统连带硬盘迁移到新电脑">将旧电脑系统连带硬盘迁移到新电脑</h2>
<p>使用下面命令准备系统：然后直接移动硬盘过去。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="variable">%windir%</span>\system32\sysprep\sysprep.exe /generalize /oobe /shutdown</span><br></pre></td></tr></table></figure>
<p>出现问题：</p>
<ol type="1">
<li>为单个用户安装的appx会造成问题，先卸载</li>
<li>千万要先把微软账户退出改用本地账号啊！！！不然被微软联网登录卡得进不去账号</li>
<li>电脑真的第一次开机要保证不能换任何配件！才能激活。激活之后再换硬盘。</li>
</ol>
<h2 id="ida出现import-site-failed">ida出现import site failed</h2>
<p>清空自己的PYTHONHOME才行 或者通过bat启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PYTHONHOME=</span><br><span class="line">set PYTHONPATH=</span><br><span class="line">start C:\Users\warren\my_programs\IDA_Pro_v7.0_Portable\ida.exe</span><br></pre></td></tr></table></figure>
<h2 id="sd卡作为内部存储">SD卡作为内部存储</h2>
<p><a href="https://stackoverflow.com/questions/38044532/how-to-turn-a-portable-sd-card-into-internal-storage-via-adb-command">stackoverflow</a></p>
<p>不需要改initrd，或者什么vold.fstab了。现在的安卓系统内置支持了。害的我还折腾，root手机。 <code>sm set-force-adoptable true</code>大法， <code>sm partition disk:179,64 mixed 60</code>表示留下60%的空间，将SD卡40%的空间用作内部存储。<code>sm partition disk:179,64 private</code>表示将整个SD卡用作内部存储。</p>
<h2 id="magisk的通用安装方法">Magisk的通用安装方法</h2>
<p><code>system as root</code>可能指没有boot分区，直接将system作为根目录。而不是像通常的boot目录作为initramfs只读启动，再挂载system分区。这种情况要patch recovery分区，开机的时候用进入recovery的方式开机。</p>
<p>找到当前手机rom刷机包，提取boot.img打patch，解锁手机后fastboot刷入。</p>
<p>红米6这样操作后似乎没了基带。注意考虑基带问题。</p>
<p>三星手机似乎非常复杂。</p>
<h2 id="git从commit中提取patch">git从commit中提取patch</h2>
<p><a href="https://stackoverflow.com/questions/6658313/how-to-generate-a-git-patch-for-a-specific-commit">这里</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git format-patch -1 HEAD</span><br></pre></td></tr></table></figure>
<p>想要把多个commit放到一个patch里，就先check out新branch，然后squash成一个，最后提取patch。</p>
<h2 id="screen让ssh退出还能运行命令">screen让ssh退出还能运行命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure>
<p>启动screen然后运行自己的命令，然后Ctrl-a, d就可以detach，安全离开ssh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -r</span><br></pre></td></tr></table></figure>
<p>恢复之前的screen</p>
<p>如果报错<code>Cannot make directory '/run/screen': Permission denied</code>执行<code>sudo /etc/init.d/screen-cleanup start</code> 。</p>
<h2 id="移动硬盘被占用">移动硬盘被占用</h2>
<ol type="1">
<li>任务管理器-资源监视器-CPU-句柄-搜索盘符</li>
<li>弹出失败时去事件查看器<code>eventvwr.msc</code>找Windows日志-系统-来源是Kernel-PnP的事件，会显示哪个进程拒绝了弹出</li>
</ol>
<h2 id="cmd启动uwp程序">cmd启动UWP程序</h2>
<p>例如<code>Microsoft.WindowsTerminal_8wekyb3d8bbwe!App</code></p>
<p>用管理员cmd，cd到<code>C:\ProgramData\Microsoft\Windows\AppRepository\Packages</code> 然后dir看目录名字就可以了。或者everything搜。或者先pin到开始菜单再拖到桌面得到快捷方式，在看属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explorer shell:appsFolder\Microsoft.WindowsTerminal_8wekyb3d8bbwe!App</span><br></pre></td></tr></table></figure>
<h2 id="diff导出单个文件的patch">diff导出单个文件的patch</h2>
<p><a href="https://unix.stackexchange.com/questions/162131/is-this-a-good-way-to-create-a-patch">单个文件或文件夹</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&quot;diff.exe&quot; -Naru --strip-trailing-cr orig-file-<span class="built_in">path</span> new-file-<span class="built_in">path</span> &gt; result.patch</span><br></pre></td></tr></table></figure>
<h2 id="visual-studio-字符集-character-set">Visual Studio 字符集 Character Set</h2>
<p>https://stackoverflow.com/questions/9349342/about-the-character-set-option-in-visual-studio</p>
<p>https://stackoverflow.com/questions/3298569/difference-between-mbcs-and-utf-8-on-windows</p>
<p>听说tchar不太好，Multi byte在GBK环境下可能不是指utf-8. 推荐处理windows API时全用wchar的版本。</p>
<p>输出方面，直接使用wchar版本输出函数，可能导致每个字符带一个空字符。使用 <code>setmode(_fileno(stdout), _O_U16TEXT);</code> 启用UTF-16输出。</p>
<p><code>system("chcp 65001")</code> 可以配合在不带L的字符串常量，使用不带w的输出函数输出中文正常。（这可能和源代码的编码有关？）</p>
<p>猜测：codepage决定了multibyte的解码。</p>
<p>TODO: locale和chcp 、code page和setmode什么关系。</p>
<p>：涉及 <code>setlocale(LC_ALL, "chinese");</code> <code>_setmode(_fileno(stdout), _O_U16TEXT);</code> 等操作</p>
<p>https://stackoverflow.com/questions/2492077/output-unicode-strings-in-windows-console-app</p>
<h2 id="gdb如何断点自动执行命令并继续">gdb如何断点自动执行命令并继续？</h2>
<p>在使用hook-stop里使用continue会出现问题。但是使用<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Break-Commands.html"><code>break command</code></a>就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def hook-stop</span><br><span class="line">end</span><br><span class="line">b usb_packet_copy</span><br><span class="line">commands</span><br><span class="line">  print $rdx</span><br><span class="line">  continue</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="linux-目录的可执行权限">Linux 目录的可执行权限</h2>
<p>https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work</p>
<p>有点复杂，有机会再总结吧。</p>
<h2 id="life-tips">Life Tips</h2>
<ol type="1">
<li>熬夜后头痛很可能是缺钾，可以通过香蕉和土豆补充。</li>
<li>刷牙重在时长，不需要追求刷得特别干净。因为主要是氟元素的化学反应。所以不如刷着牙做点别的。另外晚上睡前刷牙最重要。</li>
<li>和近视相关度最大的是自然光时间。多晒晒太阳吧。</li>
<li>合理的饮食应当以淀粉为主，淀粉在肚子里慢慢水解，为身体提供持续的能量。</li>
<li>剧烈运动能促进肠胃活动。如果肠胃有溃疡，应当尽早除幽门螺杆菌，虽然不会治疗溃疡，但是会没那么难受一些。</li>
<li>便秘考虑吃些纤维素补充剂。似乎木耳主要成分都是纤维素？但是木耳含水有90%，吃起来效率太低。</li>
</ol>
<h2 id="chroot-环境下debug">chroot 环境下Debug</h2>
<p>主要问题是在chroot的环境下debug，没有proc文件系统。网上下了一个静态编译的gdb放进去。结果启动gdb 的时候出现了unable to disable address ramdonmization和不能跟随fork，set folllow-fork-mode child解决。gdb最开始调的时候还没有符号信息，好像是开了PIE而不能读取到mapping，关闭PIE好像就行了。。。。</p>
<p>最后发现是DNS的问题。。。在chroot的文件夹里新建etc，里面新建resolv.conf，里面写nameserver 8.8.8.8就可以了。</p>
<p>以后考虑看看chroot环境下能不能搞出procfs，这样可能就方便很多。</p>
<p>https://superuser.com/questions/165116/mount-dev-proc-sys-in-a-chroot-environment</p>
<h2 id="影响程序堆布局的因素">影响程序堆布局的因素</h2>
<ol type="1">
<li>程序自身的输入，如标准输入，打开的socket等等。</li>
<li>程序文件名，参数，<strong>环境变量</strong>。</li>
</ol>
<h2 id="如何带库移植elf文件">如何带库移植ELF文件</h2>
<ol type="1">
<li><p>ldd copy dependencies脚本复制所有用到的依赖</p></li>
<li><p>patchelf修改rpath</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> ./*; <span class="keyword">do</span></span><br><span class="line">	patchelf --set-rpath /home/wjk/raw/reallib2 <span class="variable">$f</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>比较坑的一点是，<code>patchelf $f --set-rpath /home/wjk/raw/reallib2</code>这样不行，文件一定要放到set-rpath后面。。。有时间去patchelf看看是不是确实有这个问题，提个PR。</p></li>
<li><p>拿出<code>libc</code>，<code>ld</code>，<code>libpthread</code> <code>librt.so</code>，<code>libdl</code>。不要忘了<code>libdl</code>。这次就是因为没有使用系统的<code>libdl</code>而执行<code>dlopen</code>函数的时候崩了。这些库都用目标系统的。如果还是崩就用下面这条检查检查文件访问，看看缺了什么文件，用gdb debug看看是不是加载什么库的时候崩的。</p></li>
</ol>
<h2 id="如何strace脚本的文件访问">如何strace脚本的文件访问</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -f bash ./run.sh 2&gt;&amp;1 | grep bios</span><br></pre></td></tr></table></figure>
<p>strace 的<code>-f</code>能够trace fork。一般访问文件的时候是<code>openat</code>系统调用，或者<code>access</code>。</p>
<h2 id="codimd-slide放映模式-调整格式">Codimd slide放映模式 调整格式</h2>
<p>图片：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://xxx.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 60%; width: 60%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其他： 注意在列表和html标签前后留空行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 80%&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">- A</span><br><span class="line">- B</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>换行使用<code>&lt;br&gt;</code>。</p>
<h2 id="快速解决编译的exe的闪退问题">快速解决编译的exe的闪退问题</h2>
<p>首先按住alt，拖动exe到当前目录，从而创建快捷方式。</p>
<p>然后编辑快捷方式的目标，在前面加上<code>cmd[空格]/k[空格]</code> 执行完exe就会回到cmd了，不会闪退了。</p>
<h2 id="在ubuntu中找到文件属于什么包">在Ubuntu中找到文件属于什么包</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -S &quot;*/libclangBasic.a&quot;</span><br></pre></td></tr></table></figure>
<h2 id="手机电脑传文件">手机电脑传文件</h2>
<p>MT管理器的远程管理可以选择目录（局域网FTP）。</p>
<p>电脑可以开启一个https://github.com/filebrowser/filebrowser</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>烽火HG6201M交叉编译transmission</title>
    <url>/2019/HG6201m%E5%85%89%E7%8C%AB%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="烽火hg6201m交叉编译transmission成功">烽火HG6201M交叉编译transmission成功!!</h1>
<p>我家本来wifi是靠二楼的路由器的，后来发现光猫可以发射wifi，没想到三楼的光猫信号比二楼的wifi还好！！ 自从看到了这个光猫的账号密码，而且光猫带usb接口，登进去发现内存和cpu都很不错，而且自带samba文件共享！！顿时我对这款光猫就陷入了无尽的崇拜,甚至想再买一块来当开发板玩。</p>
<span id="more"></span>
<p>最近用惯了samba共享硬盘做nas，而且手头刚好有一个功率更大的和光猫电源相同dc头的12v电源，也不用怕硬盘供电不足了哈哈哈。正好硬盘盒有多，直接一个usb接上去。</p>
<p>bt做种本来有很多大文件，我用fat32的文件系统被4g的限制卡住肯定不行，我直接接我的硬盘，NTFS分区不能识别，我就想着编译一个ntfs-3g进去，但是后来没想到这光猫居然支持ntfs！！只不过不支持GPT的分区表，我改成MBR的分区表就成了，插上去自动识别！！连接后自动挂载到/mnt下，usb1_n这种格式！！不过没想到它似乎不支持ext系列文件系统。</p>
<p>接下来就是编译transmission了，为了transmission，还要编译各种它的依赖，curl，openssl什么的。openssl的动态库在光猫里有，但是因为没有头文件不能用在transmission里。。。我只能从头开始，先想办法安装旧版本的gcc，然后还不能直接上最新版本，各种挑选合适的旧版本，编译zlib，openssl，curl，libevent，百度解决各种报错，最后终于编译出来了transmission。而且我想着有了curl就可以自己写脚本搞ddns了！最近光猫有了ipv6，这样我无论在哪里都可以访问我的NAS了哈哈哈（后来发现这个ipv6虽然是公网的，但经常ping不通，无语。不知道为什么，可能移动的ipv6的路由没做好？） 然而我高兴得太早了，一运行curl就说invalid instruction。依赖curl的transmission也是，会报错不能运行。现在看感觉可能和openssl没选好架构，没加-mtune 34kc这个编译选项有关系。 最简单的交叉编译还是GO语言的，windows下一个环境变量就搞定了，可以直接放过去跑。</p>
<p>最后我还是失去了兴趣，入了openwrt的设备做nas。</p>
<p>之前了解到buildroot这个东西，听说它先要编译一个gcc，再用新的gcc去编译libc，整个linux系统等等东西，感觉它编译的太多了会很麻烦，没想到这才是真正方便的方法啊！！！这几天搞了一下，很容易就成功了。然而我已经买了其他设备做nas了。只能希望能帮到其他想拿这个光猫做NAS的人吧。</p>
<p>这光猫的web端用的是java，印象里java是很大一个，很占内存的，它居然能跑起来，虽然不知道是不是标准版的。而且这光猫的cpu使用率感觉从来都是20%以下，一般只有个位数。内存好像也挺大的。我之前网有一段时间很卡，而且光猫的samba也，就一直在怀疑是不是光猫，后来发现是蓝牙</p>
<p>------------光猫相关信息------ https://www.right.com.cn/forum/thread-783839-1-1.html 光猫各个挂载点都满了，几M的空间都没有，除了/osgi目录，大概有50M的空间？不记得了。编译好的东西可以放在这里或者直接放在挂载的硬盘或者优盘上面。</p>
<p>在根目录下面到处翻，还是能找到很多他们开发系统的信息的，要是没找到他们用的buildroot和linux内核版本，我可能就不会搞这个编译了。</p>
<p>好像是MTK的什么CPU，没有什么路由器用同款。 光猫是MIPS架构 大端序 mips32v2 34kc架构</p>
<p>下面是翻到的一些关键信息： 2017108-SmartHG_MTK7526_Engineering_CMCC-coverity Linux (none) 2.6.36-svn159641 #15 SMP Thu Nov 2 10:18:12 CST 2017 mips unknown mips-linux-glibc-4.9.3 proj/mtk04854/glibc-4.9.3/buildroot-2015.08.1/output/build/glibc-2.20/build/csu/start.o</p>
<p>--------编译过程------------ 我顺便上传下我的build-root的.config文件。 用别人的二进制文件确实不好，万一被下了毒呢。不过我还是把我编译好的上传一下，毕竟自己之前也想下载别人编译好的。 总之用ubuntu，去buildroot官网下载2015.08.1的版本，然后解压，把.config文件覆盖进去，就可以编译了。主要是选择对mips32，再选v2架构，toolchain里选2.6.36内核头文件 如果选glibc-4.9.3，它要求动态编译，我想了想还是选了静态编译，用uglibc，反正静态编译不需要加载库，这个版本不一样没关系。 gcc里面我勾选了c++支持和宽字符支持（不选宽字符可以少一个报错），nano需要宽字符。然后再勾选想要的包。直接选transmission，我还选了nano，vi一直懒得学用得不习惯。然后看什么顺眼就选了什么。我瞎选了很多包，导致要下载很多东西。 还有一个地方选并行数，根据cpu线程数选吧，我选了8。类似于make -j8吧。 buildroot真是强啊，想要什么包选什么包 或者把我上传的.config文件放到目录下，相当于使用我的配置了，可以看着上面的图片在配置里删。然后直接make。 接下来就是解决下载国外网站的网速问题了。可以考虑先全部下载好放到dl文件夹里面。省的卡在那里。不过这些源码包都挺小的。 或者有条件的直接proxychains -q make</p>
<p>这里会遇到几个报错，直接按顺序给出对应的解决网址：大家见招拆招吧</p>
<ol type="1">
<li>一开头就遇到的host-m4什么的错误 https://blog.csdn.net/Jun626/article/details/104870430</li>
<li>uclibc的宽字符的报错（不选宽字符就不会有吧）： https://dev.archive.openwrt.org/ticket/13095.html 这个需要下载patch打patch -p1</li>
<li>gcc-final的 https://unix.stackexchange.com/questions/335717/how-to-handle-error-compiling-gcc-4-7-0-using-gcc-6-2-1</li>
</ol>
<p>我编译了算是2.5次，一次是编译的动态库，顺便也发出来吧，后面又觉得要选宽字符。大概率不会遇到什么其他的报错了。 跑起来挺快的。不包括解决报错的时间只花了半小时不到。</p>
<p>--------光猫的samba------- ps一下就可以看到运行的smbd的路径，也可以找到改密码的smbpasswd。这里的用户好像要和linux系统中的用户对应，但是不好创建用户，所以推荐使用root用户，好像是smbpasswd-aroot然后就可以设置密码。然后在配置文件里面允许下root登录。因为感觉不设密码还是不安全</p>
<p>下面贴出我光猫samba的配置文件。之前配的时候看日志发现不能设置charset，因为编译的时候就不支持其他charset。我也不记得改了哪里了，应该能用吧 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">smbpasswdfile=/flash/cfg/app_conf/samba/smbpasswd</span><br><span class="line">workgroup=WORKGROUP</span><br><span class="line">guestaccount=root</span><br><span class="line">netbiosname=Fiberhome-samba_test</span><br><span class="line">serverstring=SambaServer</span><br><span class="line">dnsproxy=no</span><br><span class="line">#displaycharset=cp936</span><br><span class="line">#unixcharset=UTF-8</span><br><span class="line">#doscharset=cp936</span><br><span class="line">loglevel=0</span><br><span class="line">logfile=/dev/null</span><br><span class="line">interfaces=0.0.0.0/0[::]/0</span><br><span class="line">loadprinters=no</span><br><span class="line">security=user</span><br><span class="line">socketoptions=TCP_NODELAYSO_RCVBUF=65536SO_SNDBUF=65536</span><br><span class="line">usesendfile=yes</span><br><span class="line">deadtime=5</span><br><span class="line">[usbshare]</span><br><span class="line">comment=AllStoragedevices</span><br><span class="line">forceuser=root</span><br><span class="line">forcegroup=root</span><br><span class="line">public=no</span><br><span class="line">writable=yes</span><br><span class="line">browseable=yes</span><br></pre></td></tr></table></figure></p>
<hr />
<p>其实这些编译的东西我没有全部测试，毕竟已经买了openwrt做NAS，我就用了下curl是正常的，使用https需要设置-cacert到旁边的etc/ssl/certs/ca-certificates.crt。感觉应该能用，不会真的打脸翻车，又报invalid instruction吧，不过跑transmission需要自己搞一个配置文件，启动的时候设置好配置文件夹的路径。 顺便还编译了nginx 建议使用前做好备份，万一误删了什么就不好了。 这里都是静态编译的，直接把想要的复制出来放到优盘里，再插上光猫，开启telnet进去启动。比如transmission-daemon复制出来，在旁边的文件夹放好配置文件，启动的时候加上参数。 可以加上自己的开机启动脚本。开机自动启动一下transmission，然后再自己写个ddns脚本更新ipv6地址。参考：https://hotfeel.me/?p=119</p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Embedded</tag>
      </tags>
  </entry>
  <entry>
    <title>堆块Unlink的理解</title>
    <url>/2019/%E5%A0%86%E5%9D%97Unlink%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="unlink">unlink</h1>
<p>程序里肯定会有指向堆块的地址. 而在我们的组织堆块的链表里面也是保存的堆块地址, 能否让堆块以为程序里这保存的地址是其他的堆块指向他的呢?</p>
<span id="more"></span>
<p>在双向链表里面, 堆块们通过链表的形式排队. 当有堆块要离开的时候, 他就要进行工作交接, 否则一走了之的话链表就断了.</p>
<p>工作交接具体是两个内容, 和前面的链表说, 你后面的兄弟不再是我了, 我要走了, 这是我后面的兄弟, 它以后才是你后面的兄弟了, 向后找的时候去找它. 同样和后面的兄弟说要照顾好原来自己前面的堆块 也就是让forword块保管好自己的back指针, 让back块保管好自己的forward指针.</p>
<p>由于堆块经常被骗, 他们只好长个心眼, 不能改了别人的指针. 让后面的堆块照顾好自己前面的堆块时, 需要修改的是后面的堆块的fd指针, 这个指针原来的值就是堆块自己. 让前面的堆块照顾好自己后面的堆块时, 需要修改的是前面的堆块的bk指针, 这个指针原来的值就是堆块自己. 如果不是自己, 就肯定是被骗了, 这时候堆块就报警了, 程序就报错了</p>
<p>这里先讲一个任意地址写的故事, 程序会分配堆块, 自己保存好堆块指针, 需要数据就根据堆块指针去找, 如果我们能够随意改写堆块指针, 不就可以达到想写(读)哪里就写哪里的效果了吗? 那怎么改写呢? 我们先放开这个问题</p>
<p>但是unlink, 并没有这么简单, 我们接下来仔细分析一下 程序里面指向堆块的指针和libc里用的不太一样, 程序里是指向堆块的内容, 而libc里则是堆块结构体的头部, 向前偏移了0x10字节. 另外就是一般利用的是前向合并时的unlink. 当free一个堆块, 会前后检查free的堆块, 合并起来, 这样就不会有相邻的free块. 而free的块肯定都是在bins里的, 而且不是fastbin, 因为fastbin的块没有标成free. 所以free一个堆块的时候, 前向合并前一个堆块的时候, 就要把前面的堆块从链表里拿出来, 合并完再放到合适的链表里. 利用unlink时, 我们利用堆溢出漏洞, 修改unlink块溢出到下一块, 去除previous in use bit, 并伪造prev size, 这里伪造的size要小0x10字节, 刚好是用户内容域, 伪造的堆块小10字节也是为了和程序内指向堆块内容的指针合作. 这样free后面的块的时候, 就会对前面的伪造的小一号的堆块进行unlink, 所以unlink时伪造堆块的fd和bk指针指向哪里? 回顾之前的知识, 可以知道, fd 的bk(+0x18) = 自己(堆块指针) bk 的fd(+0x10) = 自己(堆块指针) 反过来 fd = 自己指针 - 0x18 bk = 自己指针 - 0x10</p>
<p>效果就是把自己指针先改成自己的bk, 再改成自己的fd, 即自己的指针指向了 自己指针 - 0x18 这个地址可不得了, 不是堆段了, 而是程序数据域了, 旁边很可能就是其他堆块的指针, 去改他们就可以任意地址写了</p>
<p>作用: UAF-&gt;溢出 要求: 修改free的堆块, 知道另外一处指向堆块的指针</p>
<h1 id="虚假堆快">虚假堆快</h1>
<p>需要能错位header, 再使用fastbin attack</p>
<p>错位到main_arena 改写top chunk地址, 达到任意分配堆块的目的</p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Java复习笔记</title>
    <url>/2019/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="java复习笔记">Java复习笔记</h1>
<ol type="1">
<li>各种数据类型的存储范围 <span id="more"></span></li>
</ol>
<h3 id="下面摘自清华的java慕课课件">下面摘自清华的java慕课课件</h3>
<ol start="2" type="1">
<li><p>标识符 ▫ 标识符是一个名称，与内存中的某个位置（地址） 相对应 ▫ 标识符的第一个字符必须是下列字符之一：  大写字母 (A-Z)  小写字母 (a-z)  下划线(_)  美元符号 ($) ▫ 标识符的第二个字符及后继字符必须是：  上述列表中的任意字符  数字字符 (0-9)</p></li>
<li><p>数值型文字量 数据类型 文字量 byte,short,int 十进制数，开头不为0；0X跟十六进制数，如0XF1C4； 0跟八进制数，如0726 long 同上，但后面跟l或L，如：84l，0X1F39L float 数字后跟f或F，如1.23456F，1.893E2F double 后面可选d或D做后缀，如：1.23D boolean true或false</p></li>
<li><p>扩展转换 ▫ byte, char, short, int, long, float, double ▫ 从一种整数类型到另一种整数类型，或者从 float到double的转换不损失任何信息 ▫ 从整数类形向float或double转换，会损失精度 • 窄化转换 ▫ double, float, long, int, short, byte,char ▫ 窄化转换可能会丢失信息</p></li>
<li><p>隐含转换 ▫ 赋值转换  将表达式类型转换为制定变量的类型 ▫ 方法调用转换  适用于方法或构造方法调用中的每一个参数 ▫ 字符串转换  任何类型（包括null类型）都可以转换为字符串类型  只当一个操作数是String类型时， 适用于+运算符的操作数</p></li>
<li><p>数组是对象 ▫ 动态初始化 ▫ 可以赋值给Object类型的变量 ▫ 在数组中可以调用类Object 的所有方法 ▫ 每个数组都有一个由 public final 修饰的成员变量： length ，即数组含有元素的个数（length可以是正 数或零）</p></li>
</ol>
<p>注：声明新数组时的new也一样说明了数组是一个Object <code>arrayName=new Type[componets number];</code> 这里数组也像其他类一样做了自己的初始化（给自己分配空间）。</p>
<ol start="7" type="1">
<li>两种数组 基本类型数组的每个元素都是一个基本类型的变 量；引用类型数组的每个元素都是对象的的引用</li>
</ol>
<p>创建数组的时，如果没有指定初始值，数组 便被赋予默认值初始值。 ▫ 基本类型数值数据，默认的初始值为0； ▫ boolean类型数据，默认值为false; ▫ 引用类型元素的默认值为null。</p>
<ol start="8" type="1">
<li><p>复制数组 <code>public static void arraycopy(Object source , int srcIndex ,Object dest , int destIndex , int length )</code></p></li>
<li><p>数组的数组 <code>int[ ][ ] myArray = new int[3][5] ;</code> 我之前错误的理解方式是int[3]作为一个类型，int[3][5]就是5个长3的数组。 但是还是python的理解方式对 <code>myArray = [int[5],int[5],int[5]]</code> 所以无论是new后面的int[3][5],还是取值时的myArray[2][4],都表示取出。int[3]表示第一次可以取三个，从0到2，myArray[2][4]表示先取第三个再取第五个。 现在回首发现好像所有的语言数组都是这样的，行优先</p></li>
<li><p>switch switch-expression、常量值value1到valueN必须是整形或字符型 但是最近好像增加了对string的支持</p></li>
<li><p>逗号 java里不用逗号符，但是可以用于for语句里面的分隔</p></li>
<li><p>可变长参数 • 可变长参数使用省略号表示，其实质是数组。 • 例如，“String … s”表示“String[] s” 。 • 对于具有可变长参数的方法，传递给可变长参数的实际参数可以是 零个到多个对象。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double maxArea(Circle c, Rectangle... varRec) &#123;</span><br><span class="line">Rectangle[] rec = varRec;</span><br><span class="line">for (Rectangle r : rec) &#123;</span><br><span class="line">//…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>包 一个包可以包含若干个类文件，还可包含若干个包</p></li>
<li><p>编译单元 • 一个Java源代码文件称为一个编译单元，由三部分组成： ▫ 所属包的声明（省略，则属于默认包）； ▫ Import （引入）包的声明，用于导入外部的类； ▫ 类和接口的声明。 • 一个编译单元中只能有一个public类，该类名与文件名相同，编译 单元中的其他类往往是public类的辅助类，经过编译，每个类都会 产一个class文件。</p></li>
</ol>
<p>注：所以并不是一个文件只存一个类，而是只让存一个public类</p>
<ol start="15" type="1">
<li><p>类的成员访问权限控制 公有(public) ▫ 可以被其他任何方法访问(前提是对类成员所属的类有访问权限) • 保护(protected) ▫ 只可被同一类及其子类的方法访问 • 私有(private) ▫ 只可被同一类的方法访问 • 默认(default)(无修饰) ▫ 仅允许同一个包内的访问；又被称为“包（package)访问权限” 注：主要不记得最后的默认</p></li>
<li><p>构造方法内的this关键字 • 可以使用this关键字在一个构造方法中调用另外的构造方法； • 代码更简洁，维护起来也更容易； • 通常用参数个数比较少的构造方法调用参数个数最多的构造方法。</p></li>
<li><p>对象的自动回收 • 无用对象 ▫ 离开了作用域的对象； ▫ 无引用指向对象。 • Java运行时系统通过垃圾收集器周期性地释放无用对象所使用的内存。 • Java运行时系统会在对对象进行自动垃圾回收前，自动调用对象的finalize()方法。</p></li>
<li><p>finalize()方法 • 在类java.lang.Object中声明，因此 Java中的每一 个类都有该方法： protected void finalize() throws throwable • 用于释放资源。 • 类可以覆盖（重写）finalize()方法。 • finalize()方法有可能在任何时机以任何次序执行。</p></li>
<li><p>枚举类 特点： 一、 只有有限个实例化的对象 --&gt;可以用==判断 所有枚举类型都隐含继承（扩展）自java.lang.Enum，因此枚举类型不能再继承其他任何类 枚举类型的构造方法必须是包内私有或者私有的。定义在枚举开头的常量会被自动创建，不能显式地调用枚举类的构造方法。 例子： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Planet &#123;</span><br><span class="line">MERCURY (3.303e+23, 2.4397e6),</span><br><span class="line">VENUS (4.869e+24, 6.0518e6),</span><br><span class="line">EARTH (5.976e+24, 6.37814e6),</span><br><span class="line">MARS (6.421e+23, 3.3972e6),</span><br><span class="line">JUPITER (1.9e+27, 7.1492e7),</span><br><span class="line">SATURN (5.688e+26, 6.0268e7),</span><br><span class="line">URANUS (8.686e+25, 2.5559e7),</span><br><span class="line">NEPTUNE (1.024e+26, 2.4746e7);</span><br><span class="line">private final double mass; // in kilograms</span><br><span class="line">private final double radius; // in meters</span><br><span class="line">Planet(double mass, double radius) &#123;</span><br><span class="line">this.mass = mass;</span><br><span class="line">this.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">private double mass() &#123; return mass; &#125;</span><br><span class="line">private double radius() &#123; return radius; &#125;</span><br><span class="line">// universal gravitational constant (m3 kg-1 s-2)</span><br><span class="line">public static final double G = 6.67300E-11;</span><br><span class="line">double surfaceGravity() &#123;</span><br><span class="line">return G * mass / (radius * radius);</span><br><span class="line">&#125;</span><br><span class="line">double surfaceWeight(double otherMass) &#123;</span><br><span class="line">return otherMass * surfaceGravity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 枚举型变量可以带自己的操作方法，甚至构造方法，但是只能在声明时调用构造方法，从而只有有限个实例对象。</p></li>
<li><p>通配符泛型 •使用通配符 可以使程序更为通用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ShowType &#123;</span><br><span class="line">public void show (GeneralType&lt;?&gt; o)&#123;</span><br><span class="line">    System.out.println(o.getObj().getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>有限制的泛型 •在参数“ Type” 后面使用“ extends” 关键字并加上类名或接口名，表明参数所代表的类型必须是该类的子类或者实现了该接口 ▫注意，对于实现了某接口的有限制泛型，也是使用 extends 关键字，而不是 implements 关键字</p></li>
<li><p>构造方法中调用多态方法 •在构造方法内调用准备构造的那个对象的动态绑定方法 ▫被调用方法要操纵的成员可能尚未得到正确的初始化 ▫可能造成一些难于发现的程序错误 所以要注意 •用尽可能少的动作把对象的状态设置好； •如果可以避免，不要调用任何方法； •在构造方法内唯一能够安全调用的是在超类中具有 final 属性的那些方法（也适用于 private 方法，它们自动具有 final 属性）。这些方法不能被覆盖，所以不会出现前述的潜在问题。</p></li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派与resbian</title>
    <url>/2019/%E6%A0%91%E8%8E%93%E6%B4%BEresbian/</url>
    <content><![CDATA[<h1 id="树莓派与resbian">树莓派与resbian</h1>
<span id="more"></span>
<h2 id="上手系统安装">上手系统安装</h2>
<p>下载系统镜像，解压。。。 一般发行版下载的系统的iso，但是树莓派系统是img的压缩包，要先解压。</p>
<p>刷镜像一般用win32diskimager。linux用dd命令。 也就是说，如果你经常刷系统，拿到树莓派如果先不急着拓展文件系统空间，安装完一些软件，就可以拿回来用win32diskimager读img镜像出来留着。 刷完反射性地在boot的根目录下新建ssh空文件。 然后就是启动，一句sudo raspi-config打开vnc。 树莓派还是对桌面玩家友好😭，图形界面比命令行调乱七八糟的参数好得多。</p>
<p>一些闲话： 回忆起很久以前ubuntu等桌面版还不知道用什么刷到优盘的时候，有个opensusu的小工具也是刷优盘镜像的。主要需要对磁盘的二进制读写能力，才能写出启动盘。 最近装了一次win10，以前装win7还会用用ultraISO的写入硬盘镜像到优盘，现在它已经落后变得垃圾了，写入不是卡死就是不能启动，现在用rufus-3.6p.exe这个小巧的程序特别强。装系统的时候才了解到难道uefi已经支持ntfs了吗 已经是第二次不能从sd卡启动了。。。是不是uefi歧视sd卡。。。只能用优盘，也不知道是不是驱动不一样。</p>
<h2 id="journalctl">journalctl</h2>
<p>直接执行，进行日志的查看 参数： -n 3 查看最近三条记录 -perr 查看错误日志 -overbose 查看日志的详细参数 --since 查看从什么时候开始的日志 --until 查看什么时候截止的日志</p>
<p>这条命令主要是因为我之前用手机充电器，这里会报低电压警告 最近买了新电源，用这个命令来看看还会不会警告。果然换了电源就看不到了</p>
<h2 id="电源管理">电源管理</h2>
<p>sudo iw dev wlan0 set power_save on|off 这条命令关闭wifi的电源管理，否则wifi不稳，我以前通过wifi进行ssh不可靠就是因为这个和电源</p>
<h2 id="安装无线网卡驱动">安装无线网卡驱动</h2>
<p>手头有一块垃圾的tenda U6，是rtl8192eu的，还有一张rtl8812au https://github.com/Mange/rtl8192eu-linux-driver https://github.com/aircrack-ng/rtl8812au 按照github的readme进行设置， 我有一次只是安装rtl8192eu的dkms模块，没有进行教程接下来的设置操作，就开不了机，只能重刷系统😭。 开机就可以执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git raspberrypi-kernel-headers build-essential dkms;</span><br></pre></td></tr></table></figure> 让它慢慢下载</p>
<h2 id="networkmanager">networkManager</h2>
<p>这里我需要给树莓派固定的ip，但是发现这次树莓派每次启动wifi网卡mac地址都随机化，每次一个新ip，还查不出这个网卡是哪个厂商的。。。 但是图形化界面没有设置的地方，还是ubuntu的network-manager-gnome友好，里面有这个选项。 于是试图使用network-manager-gnome管理无线网 本来以为network-manager-gnome是gnome桌面专用的东西，后来装了才发现lxde照用不误，有桌面环境就行。 sudo apt-get install network-manager-gnome 这里安装后菜单就出现了advanced network Configuration 修改配置文件 sudo nano /etc/NetworkManager/NetworkManager.conf <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">plugins=ifupdown,keyfile</span><br><span class="line"></span><br><span class="line">[ifupdown]</span><br><span class="line">managed=false</span><br></pre></td></tr></table></figure> 把false改成true #注：managed这里表示是否管理/etc/network/interfaces里配置了的网络接口 修改/etc/network/interfaces，在末尾加上如下内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">        hwaddress b8:27:eb:00:00:00</span><br></pre></td></tr></table></figure> 相关原理： 下面基于2019年7月31日下载的raspbian系统 树莓派的这个发行版的网络组件和其他发行版不一样。一般linux首先读取/etc/network/interfaces，剩下没有被管理的网络接口被network-manager管理。 树莓派的网络也使用了networkmanager，而不使用interfaces文件，下面是树莓派默认的/etc/network/interfaces <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line"></span><br><span class="line"># Please note that this file is written to be used with dhcpcd</span><br><span class="line"># For static IP, consult /etc/dhcpcd.conf and &#x27;man dhcpcd.conf&#x27;</span><br><span class="line"></span><br><span class="line"># Include files from /etc/network/interfaces.d:</span><br><span class="line">source-directory /etc/network/interfaces.d</span><br><span class="line"></span><br></pre></td></tr></table></figure> 而它include的/etc/network/interfaces.d是一个空文件夹，所以raspbian是不用interfaces的。 任何修改/etc/network/interfaces的教程现在都已经过时了，修改该文件会造成兼容性问题，具体表现在桌面右上角的图标失灵，不能正常管理网络。 桌面右上角的网络管理的图标比较简陋，软件包名称是lxplug-network，根据名字可以知道，这个应该是lxde的插件，不过肯定是用在raspbian的pixel桌面上的，而且lxplug- 还是一个系列，还包括蓝牙什么的，它在github上的链接是 https://github.com/raspberrypi-ui/lxplug-network 听说原开发者已经退休了。。。 当右上角的图标失灵时，显示Connection to dhcpcd lost. 点击显示No wireless interface found. 这里可以看出它管理网络使用的是dhcpcd，c代表client，d是deamon守护进程。 下面这个帖子在小白互助的时候，一位大神出来说了一句技术内幕。看来有关树莓派的问题还是到官方论坛搜索比较好，接触全球的帖子。 https://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;t=242721&amp;p=1482723&amp;hilit=%2Fetc%2Fnetwork%2Finterfaces+mac+random#p1482723 其中关键的一句： dhcpcd has a wpa_supplicant hook in Stretch. Stretch是Debian9的代号现在都到debian10 buster了。 也就是说，这个管理程序还是用的是wpasupplicant，不是让你去interfaces里点名用wpasupplicant，而是它在dhcpcd里面它自己调用！用wpagui也可以管理到！ 至于静态ip，树莓派的桌面环境可以设置。而且如果想在配置文件配置也是在dhcpcd.conf里配置。 https://www.jianshu.com/p/bd918ef98a4d</p>
<p>其他相关页面 https://wiki.lxde.org/en/LXNM https://wiki.lxde.org/en/LXDE-Qt</p>
<h2 id="换tuna源">换tuna源</h2>
<p>虽然树莓派基金会的镜像也能用，但是还是清华的快一些。 https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</p>
<h2 id="dump镜像">dump镜像</h2>
<p>树莓派还是不要用太大的sd卡，完全没必要。现在因为不想以后换系统的时候重新配置文件，现在打算直接把整个sd卡做个镜像压缩一下。8g其实完全足够了。我用的32g的卡，为了省空间，打算先压缩分区大小再dump出来。</p>
<ol type="1">
<li>fsck磁盘检查 要把树莓派关机，把卡拿下来，去别的linux系统上检查 sudo fsck /dev/sda2 -f 使用-f强制检查但是我检查了，还是后面报有node不对，忘了之前是怎么搞的了</li>
<li>使用diskgenius压缩分区。 gparted还真的不容易做压缩分区，看来还是diskgenius好啊</li>
</ol>
<p>一不小心用了这个感觉挺危险的办法： https://access.redhat.com/articles/1196333 https://askubuntu.com/questions/780284/shrinking-ext4-partition-on-command-line 还要删除分区再建立。。。</p>
<p>之后构建img文件还是使用win32diskimager，没办法，没什么其他好软件。 不过可以勾选只备份已有分区，挺好，没想到小工具能做到这么实用，我要是也能写出这样的工具就好了。</p>
<h2 id="samba">samba</h2>
<p>windows 清除登录密码 加上选项 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min protocol = SMB3</span><br><span class="line">security = user</span><br></pre></td></tr></table></figure></p>
<p>debug samba <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service smbd stop</span><br><span class="line">sudo smbd -F -S -d=10</span><br></pre></td></tr></table></figure> 此时再连接, 就可以看到debug信息了.</p>
<p>关键配置1 要加密或者签名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server signing = mandatory</span><br><span class="line">smb encrypt = mandatory</span><br></pre></td></tr></table></figure> 关键配置2 guest account 要手动设置</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>天枢的新手入门指南 Q&amp;A</title>
    <url>/2019/%E5%A4%A9%E6%9E%A2%E7%9A%84%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%20Q&amp;A/</url>
    <content><![CDATA[<p>这篇文章是2019年7月31日从天枢新人群里复制来的。增加自己博客的文章数</p>
<h1 id="天枢的新手入门指南-qa">天枢的新手入门指南 Q&amp;A</h1>
<h2 id="什么是天枢">什么是天枢</h2>
<h3 id="天枢战队">天枢战队</h3>
<span id="more"></span>
<blockquote>
<p>​ 天枢战队是来自北京邮电大学（BUPT）的一群小伙伴组成的安全团队。队名“天枢”是北斗七星的第一颗星，它代表了聪慧和才能。核心团队有十五人左右，活跃在国内外大大小小的赛事上。大家聚在一起，乐于学习、研究和交流各个方向的安全技术，提高北邮信息安全氛围。</p>
<p>​ 队员们专精的技能千奇百怪：手捏网线就能发包，口算sha256比2080ti还快，盯着字节码即可逆向操作系统，双击Chrome就能v8逃逸，通过人眼扫描面部即可微信添加好友等。</p>
</blockquote>
<h3 id="天枢社团">天枢社团</h3>
<blockquote>
<p>​ 天枢社团的主要作用就是向天枢战队输送新生力量，提高北邮的民间信息安全能力与氛围。定期组织CTF交流，提高自身的信息安全技能</p>
</blockquote>
<h3 id="如何加入天枢战队">如何加入天枢战队</h3>
<p>天枢战队在每年5月底6月初会举办<code>TSCTF</code>邀请赛，在线上赛取得突出成绩，或者在其他比赛中有优异成绩即可进入天枢战队</p>
<h3 id="天枢社团的预想组织架构">天枢社团的预想组织架构</h3>
<ul>
<li>中心组
<ul>
<li>活动（负责相关活动的宣传，组织，评定，场地，以及后期的报销等事宜）//这里可能可以细分？</li>
<li>技术（负责相关活动的技术维护）</li>
</ul></li>
<li>XX战队（负责参加各种比赛，包括但不限于国赛，XCTF联赛等，人数大概维持在20人-30人左右）</li>
</ul>
<h3 id="天枢社团预想学习模式">天枢社团预想学习模式</h3>
<ol type="1">
<li>在开学初进行战队的初级选拔(大概招30人吧，我也不清楚)，主要选拔一些有基础，或者说感兴趣并想坚持的人。</li>
<li>开学之后会进行1-2个月左右的学习，然后进行选拔，抽取前20(概率还是挺大的)</li>
<li>每周面向全校（主要是战队）进行沙龙，不同方向和领域可以分开进行活动。</li>
<li>每月进行一次战队的交流，比赛（评定），分享学习经验。提高合作水平</li>
<li>战队会进行定期考核，当无法完成相应任务，会从战队中移除。</li>
</ol>
<h2 id="什么是ctf">什么是CTF</h2>
<blockquote>
<p>​ CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。(百度百科)</p>
</blockquote>
<p>CTF的几个方向 Web（网络安全）,Pwn（二进制安全）,Re（逆向工程）,Crypto（密码学）,Misc（流量分析，图片隐写，取证，等其他方向）</p>
<h2 id="方向介绍入门书籍及练习网站">方向介绍，入门书籍及练习网站</h2>
<h3 id="web">Web</h3>
<blockquote>
<p>网络安全，及负责各种数据库，网页，等网络产品的漏洞挖掘及其利用</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr class="header">
<th>书名</th>
<th>网购链接（没有打广告）</th>
<th>电子书链接</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>白帽子讲Web安全</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.16.6c384122VZ3uBX&amp;id=596872157850&amp;cm_id=140105335569ed55e27b&amp;abbucket=3">白帽子讲Web安全</a></td>
<td>群文件自取</td>
</tr>
<tr class="even">
<td>代码审计 企业级Web代码安全架构</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.9.396746e1Anlg9X&amp;id=594217706164&amp;cm_id=140105335569ed55e27b&amp;abbucket=3">代码审计</a></td>
<td><a href="https://u1475340.ctfile.com/fs/1475340-228355356">下载</a></td>
</tr>
<tr class="odd">
<td>Sndav弱鸡的博客</td>
<td><a href="http://blog.boyblog.club">博客</a></td>
<td></td>
</tr>
<tr class="even">
<td>离别歌的博客</td>
<td><a href="https://www.leavesongs.com/">博客</a></td>
<td></td>
</tr>
<tr class="odd">
<td>郁离歌丶的博客</td>
<td><a href="http://yulige.top/">郁离歌丶的博客</a></td>
<td></td>
</tr>
<tr class="even">
<td>SecWiki</td>
<td><a href="https://sec-wiki.com/">SecWiki</a></td>
<td></td>
</tr>
<tr class="odd">
<td>WooYun镜像站</td>
<td><a href="http://www.anquan.us/">WooYun镜像站</a></td>
<td></td>
</tr>
<tr class="even">
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>练习网站</strong></p>
<table>
<thead>
<tr class="header">
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr class="even">
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr class="odd">
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody>
</table>
<h3 id="pwn">Pwn</h3>
<blockquote>
<p>二进制安全，负责各种二进制程序（ELF，EXE等）的漏洞挖掘及其利用</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr class="header">
<th>书名</th>
<th>网购链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0day安全:软件漏洞分析技术</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.33.47641d36xHPMdd&amp;id=595379481437&amp;ns=1&amp;abbucket=3">0day安全:软件漏洞分析技术</a></td>
<td>群内自取</td>
</tr>
<tr class="even">
<td>汇编语言</td>
<td><a href="https://item.jd.com/12259774.html">汇编语言</a></td>
<td></td>
</tr>
<tr class="odd">
<td>程序员的自我修养（装载，链接与库）</td>
<td>自己淘宝吧</td>
<td><a href="https://pan.baidu.com/s/1cALpx_D_9CR9hWWM9rIMwQ">百度网盘，提取码：73pe</a></td>
</tr>
<tr class="even">
<td>深入理解计算机系统</td>
<td>同上</td>
<td><a href="https://pan.baidu.com/share/init?surl=gtB8fEUUtFj8blwJnajICQ">百度网盘，提取码：yx0s</a></td>
</tr>
<tr class="odd">
<td>glibc内存管理ptmalloc2源代码分析</td>
<td>同上</td>
<td><a href="https://pan.baidu.com/s/1-0odrFdV0Dn7xgehicuz0A">百度网盘，提取码：su8n</a></td>
</tr>
<tr class="even">
<td>xxrw的blog</td>
<td><a href="https://xiaoxiaorenwu.top">博客</a></td>
<td></td>
</tr>
<tr class="odd">
<td>天枢-p4nda的blog</td>
<td><a href="http://p4nda.top/">博客</a></td>
<td></td>
</tr>
<tr class="even">
<td>天枢-YM的blog</td>
<td><a href="https://e3pem.github.io">博客</a></td>
<td></td>
</tr>
<tr class="odd">
<td>天枢-17的blog</td>
<td><a href="https://sunichi.github.io/">博客</a></td>
<td></td>
</tr>
<tr class="even">
<td>r3kapig-swing的blog</td>
<td><a href="https://bestwing.me/">博客</a></td>
<td></td>
</tr>
<tr class="odd">
<td>VidarTeam-Veritas501的blog</td>
<td><a href="https://veritas501.space/">博客</a></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>资料</strong> | 网站 | 地址 | | ---- | ---- | | CTF-Wiki | <a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a> | | CTF-ALL-In-One | <a href="https://github.com/firmianay/CTF-All-In-One/">CTF-ALL-In-One</a> | | Shellcode网站1 | <a href="https://shell-storm.org/">Shell-Storm</a> | |Shellcode网站2|<a href="https://www.exploit-db.com/shellcodes">shellcode</a>| |北京邮电大学瑶光战队学习资料|<a href="https://github.com/xiaoxiaorenwu/-">北邮瑶光</a>| |i春秋的pwn基础教程|<a href="https://bbs.ichunqiu.com/search.php?mod=portal&amp;searchid=117&amp;searchsubmit=yes&amp;kw=pwn%E5%85%A5%E9%97%A8">i春秋搜索pwn入门</a>| |看学知识库|<a href="https://www.kanxue.com/chm-search-pwn.htm">看雪知识库</a>| |libc搜索|<a href="http://libcdb.com/">libc搜索</a>|</p>
<p><strong>刷题网站</strong> | 网站 | 地址 | 难度 | | ---- | ---- | ---- | | 攻防世界 | <a href="http://adworld.xctf.org.cn">攻防世界</a> | 初级-困难 | | 北京联合大学OJ | <a href="https://buuoj.cn/">BUUOJ</a> | 中等 | | Github CTFTraining | <a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a> | 中级-困难 | | PwnableKr | <a href="https://pwnable.kr">PwnableKr</a> | 初级-中级 | | PwnableTw | <a href="https://pwnable.tw/">PwnableTw</a> | 中级-困难 | | Jarvisoj | <a href="https://Jarvisoj.com">Jarvisoj</a> | 初级-中级| | CTFWP | <a href="http://www.ctfwp.com">CTFWP</a> | 中级 |</p>
<h3 id="re">Re</h3>
<blockquote>
<p>逆向工程，负责逆向程序算法，破解程序限制</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr class="header">
<th>书名</th>
<th>网购链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Re4b(Reverse Engineer For beginner)</td>
<td><a href="https://item.jd.com/12166962.html">Re4b</a></td>
<td>群内自取</td>
</tr>
<tr class="even">
<td>加密与解密</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.189.1d8238f5fF5n7B&amp;id=580607194609&amp;ns=1&amp;abbucket=3">加密与解密</a></td>
<td><a href="https://pan.baidu.com/s/18PhiF_STy4413w4rlfZKfQ">百度云</a> 提取码: hpdb</td>
</tr>
<tr class="odd">
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>练习网站</strong></p>
<table>
<thead>
<tr class="header">
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr class="even">
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr class="odd">
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody>
</table>
<h3 id="crypto">Crypto</h3>
<blockquote>
<p>密码学，负责通过密码以及数学知识，破解相应密码</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr class="header">
<th>书名</th>
<th>淘宝链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>现代密码学</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>练习网站</strong></p>
<table>
<thead>
<tr class="header">
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr class="even">
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr class="odd">
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody>
</table>
<h3 id="misc">Misc</h3>
<blockquote>
<p>杂项，负责各种其他安全相关，比如取证，隐写，区块链等</p>
</blockquote>
<p><strong>书单</strong></p>
<table>
<thead>
<tr class="header">
<th>书名</th>
<th>网购链接</th>
<th>电子书地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CTF-Wiki</td>
<td><a href="https://ctf-wiki.github.io/ctf-wiki/">Wiki</a></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>练习网站</strong></p>
<table>
<thead>
<tr class="header">
<th>网站</th>
<th>地址</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>攻防世界</td>
<td><a href="http://adworld.xctf.org.cn">攻防世界</a></td>
<td>初级-困难</td>
</tr>
<tr class="even">
<td>北京联合大学OJ</td>
<td><a href="https://buuoj.cn/">BUUOJ</a></td>
<td>中等</td>
</tr>
<tr class="odd">
<td>Github CTFTraining</td>
<td><a href="https://github.com/CTFTraining/CTFTraining">CTFTraining</a></td>
<td>中级-困难</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>COM与RPC</title>
    <url>/2020/COM%E4%B8%8ERPC/</url>
    <content><![CDATA[<h1 id="com与rpc">COM与RPC</h1>
<p>研究windows安全的过程中对COM非常不熟。于是找资料学习了一会。</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>COM，组件对象模型，它解决的问题是二进制间兼容性问题，并在此基础上实现了RPC。</p>
<p>主要学习资料： <a href="https://zhuanlan.zhihu.com/c_1234485736897552384">COM编程攻略</a></p>
<p>它的兼容思想是通过只暴露接口，不得出现跨边界的编译器相关行为，从而实现二进制的兼容。即不依赖结构体的布局，不依赖类型转换和new、delete的实现。</p>
<p>AddRef()：返回之后的引用计数。</p>
<p>Release()：一旦引用计数为0，实现者必须要释放此对象。</p>
<p>QueryInterface()</p>
<h2 id="接口转换的实现原则">接口转换的实现原则</h2>
<p><code>HRESULT QueryInterface(REFIID iid, void** ppvObject);</code></p>
<p>1、如果可以成功拿出接口，返回S_OK。如果ppvObject为空，返回E_POINTER。如果不能拿出接口，那么返回E_NOINTERFACE。</p>
<p>2、QueryInterface(下面简称QI)是静态的，不是动态的。这说明，一个对象QI能否成功，和时间没有关系。如果某个特定的类的实例QI(A)-&gt;B（执行QueryInterface拿到B），那么任何时候都应该能拿到B。</p>
<p>3、QI是自反的（如果QI(A)-&gt;B，那么QI(B)-&gt;A。</p>
<p>4、QI是对称的。</p>
<p>5、QI是可传递的。</p>
<p>6、如果需要取的是IUnknown(IID_IUnknown)，那么必须要返回相同的指针。</p>
<h2 id="iunknown-继承模型-聚合模型">IUnknown 继承模型 聚合模型</h2>
<p>继承模型：一个接口继承IUnknown，要用的时候转换成自己。</p>
<p>聚合模型：实现IUnknown的是套壳接口，QI的时候返回不同的接口。</p>
<p>结合聚合模型的特点和接口转换的实现原则，进行推理：用不同的地址代表不同接口的具体实现：</p>
<ol type="1">
<li>根据自反性，必须能够一次任意转换。因此所有的聚合在同一个套壳接口的类型调用QI的时候必须调用套壳接口的QI。</li>
<li>根据</li>
</ol>
<h2 id="atl实现的三层模型">ATL实现的三层模型</h2>
<p><code>Wrapper -&gt; YourClass -&gt; Internal</code></p>
<figure>
<img src="COM.jpg" alt="COM" /><figcaption aria-hidden="true">COM</figcaption>
</figure>
<p><code>CComObject</code> 对应继承模型，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Base</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CComObject</span> : </span><br><span class="line">	<span class="keyword">public</span> Base</span><br></pre></td></tr></table></figure>
<p><code>CComAggObject</code> 则对应的是聚合模型，不再直接继承。</p>
<p>YourClass需要继承internal和各种需要的interface，并用宏指明转换规则。从而创建<code>_QueryInterface</code> 函数和静态与 <code>_GetEntries</code> 的Entries。由 <code>InternalQueryInterface</code> 来调用API遍历这个表。YourClass不只是一个分发器，而是把接口的实现都作为自己的成员函数。</p>
<p>Interface是带有很多虚函数的基类罢了。虚函数是父类声明时，用来告知编译器，希望即使把子类作为父类，调用同名方法的时候要调用子类的方法。</p>
<ol type="1">
<li>调用QI（wrapper的）会调用到内部的YourClass分发器的QI。</li>
<li>成功分发，转换类型后，再调用QI得调用回Wrapper的QI。</li>
</ol>
<p><code>CComObjectRootBase</code> 类型自身就有m_pOuterUnknown成员，和<code>OuterAddRef</code> 、 <code>OuterRelease</code> 函数，用来对聚合模型实现支持。它的QI就是总的QI，之后转换出去的COM接口都要调用回来这里的QI。</p>
<p>其实是COM手动实现了对与Interface类型的转换？YourClass注册Interface的时候，通过一个方法的静态数组成员来记录每个IID和对应的指针相对于this的偏移，转换的时候用到。但实际上，外围的CComAggObject持有的是通过模板生成的CComContainedObject。它通过模板继承上面写的类，重写了QueryInterface。通过CComAggObject拿到的都是继承自己的类之后的CComContainedObject了，此时构建的时候传入了原来的IUnokown的指针，通过继承和重新实现QI，把QI导向到了总的QI。导向方法是转调OuterQueryInterface，它调用了CComObjectRootBase的m_pOuterUnknown-&gt;QueryInterface</p>
<p>由于拿到的总是被<code>CComContainedObject</code> 包围的QI，这里是调用<code>CComContainedObject</code> 的QI。此时则调用的之前保存的OuterUnknown的QI。</p>
<p>QI，的时候，是把</p>
<h2 id="example">Example</h2>
<ol type="1">
<li><p>首先vs2019选ATL项目模板，创建ATLMessageBox项目，选择服务exe</p>
<p>此时的解决方案里面有ATLMessgaeBox和ATLMessageBoxPS项目，后者是ProxyStub代理桩，给享受服务的客户端用的，客户端调用对应服务的时候由它来处理序列化，通讯等事情。</p></li>
<li><p><strong>uuidgen /i /ohello.idl</strong> 创建带有UUID的IDL文件</p></li>
<li><p>IDL 文件描述接口，填写创建</p></li>
<li><p>rgs注册表消息，填写创建</p></li>
<li><p>创建MessageBox.cpp MessageBox.h</p></li>
<li><p>注册：C:.exe /RegServer</p></li>
</ol>
<h2 id="rpc">RPC</h2>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page">Remote Procedure Call</a></p>
<p>主要分析的是 <a href="https://github.com/microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/netds/rpc/hello/Hellop.c">这个微软的例子RPCHello</a></p>
<p>TODO rpc的跨平台，是否支持linux或者Unix / Apple</p>
<p>RPC的环境内置在windows中，而RPC的开发环境在windows sdk中。</p>
<p>Microsoft Interface Definition Language MIDL，用来描述调用的接口。</p>
<p>客户端程序调用的服务端的函数，实际上不是真正的实现函数，而是一个stub函数，负责把参数转换成标准的NDR格式，通过网络传输请求。</p>
<p>服务器的运行时函数接受请求，转换参数，最后再调用服务端的stub函数，返回值数据的时候也是类似的方法传输回去。</p>
<p>RPC有如下组件：MIDL编译器，运行时的lib和头文件，Name service provider和Endpoint mapper。还有uuidgen工具。</p>
<p>承载RPC的dll有通过命名管道的、tcp/ip、NetBIOS、SPX、IPX、UDP的等等。</p>
<p>开发的过程包括：开发接口-&gt;开发服务端-&gt;开发客户端。</p>
<p>接口的定义主要包括的是IDL文件和ACF文件。编写后用MIDL编译器得到服务端和客户端的stub。VS1029中idl文件属于源文件，而acf文件属于资源文件。编译时的选项在项目的属性中多出来的MIDL项里面配置。</p>
<ul>
<li><p>Hello_c.c 客户端stub</p></li>
<li><p>Hello.h 两边都包括的头文件</p></li>
<li><p>Hello_s.c 服务端的stub</p></li>
</ul>
<p>Hellop.c 这个文件不是生成的，（example里面的）包含对server的procedure的实现。</p>
<p>Hellos.c和Helloc.c里面就是真正的RPC代码了。这一块才是重点关注的部分。</p>
<h3 id="midl">MIDL</h3>
<p>服务端和客户端代码容易混在一起，在同一个项目里建立两个文件夹。</p>
<p>默认情况下，客户端和服务端的stub函数名字相同，导致不能同时链接服务端和客户端的stub，编译的时候加上 <code>/prefix</code> 参数可以避免这种情况。</p>
<p>如果编译的时候不加上 <a href="https://docs.microsoft.com/en-us/windows/win32/midl/-osf"><code>/osf</code></a> (Open Software Foundation compatibility mode)，就需要提供一个函数分配和回收内存。开启这个模式会失去很多功能特性。</p>
<h3 id="server">server</h3>
<p>API调用序列大致如下</p>
<p>RpcServerUseProtseqEp</p>
<p>RpcServerRegisterAuthInfo (增加安全机制)</p>
<p>RpcServerRegisterIfEx</p>
<p>RpcServerListen</p>
<p>RpcMgmtWaitServerListen 循环等待</p>
<p>RpcMgmtStopServerListening</p>
<p>RpcServerUnregisterIf</p>
<p>applications must specify a string that represents a combination of</p>
<ol type="1">
<li><p>an RPC protocol,</p>
<ol type="1">
<li>Network Computing Architecture connection-oriented protocol (NCACN)</li>
<li>Network Computing Architecture datagram protocol (NCADG)</li>
<li>Network Computing Architecture local remote procedure call (NCALRPC)</li>
</ol>
<p>一般都选这个NCALRPC ？</p></li>
<li><p>a transport protocol and a network protocol. TCP/IP. IPX/SPX, NetBIOS, AppleTalk DSP什么的。肯定选tcp/ip</p></li>
</ol>
<p><strong>ncalrpc</strong> for local communications and <strong>ncacn_ip_tcp</strong> or <strong>ncacn_http</strong> for remote communications are recommended</p>
<p>选好了就可以通过the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose"><strong>RpcStringBindingCompose</strong></a> and <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding"><strong>RpcBindingFromStringBinding</strong></a> functions创建binding的handle了。</p>
<p>另外需要实现 the <a href="https://docs.microsoft.com/en-us/windows/desktop/Rpc/the-midl-user-allocate-function"><strong>midl_user_allocate</strong></a> and <a href="https://docs.microsoft.com/en-us/windows/desktop/Rpc/the-midl-user-free-function"><strong>midl_user_free</strong></a> 这两个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __RPC_FAR * __RPC_USER <span class="title function_">midl_user_allocate</span><span class="params">(<span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">malloc</span>(len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __RPC_USER <span class="title function_">midl_user_free</span><span class="params">(<span class="type">void</span> __RPC_FAR * ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client">client</h3>
<p>源文件添加上生成的 _c.c后缀的文件。此外要加上任何可能需要的lib文件</p>
<p>API调用序列如下</p>
<p>RpcStringBindingCompose</p>
<p>RpcBindingFromStringBinding</p>
<p>RpcBindingSetAuthInfoEx (增加安全机制)</p>
<p>HelloProc</p>
<p>RpcStringFree</p>
<p>RpcBindingFree</p>
<h4 id="spn">spn</h4>
<p><em>Service Principal Name</em> is a concept from Kerberos</p>
<p>实现安全机制的时候用的，所以目前可以暂时不管。</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>K210开发板相关外设学习</title>
    <url>/2020/K210%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9B%B8%E5%85%B3%E5%A4%96%E8%AE%BE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="k210开发板相关外设学习">K210开发板相关外设学习</h1>
<p>这篇文章是我买了<code>Widora AIRV R3</code>这个<code>K210</code>芯片的开发板。这时候刚好看了一些Python内部实现的书，并且Maixpy（一个移植Micropython到K210开发板上的项目）对这块开发版支持还不完善，于是就克隆下来，试图修改移植。</p>
<span id="more"></span>
<p>这只是最初的想法，希望能做成一个项目。虽然确实群里很多人也都需要这样的固件，但是一方面群主不太待见这种使用python的行为，另一方面，我发现我做的一些工作都是非常浅层的，真的就是修改一下引脚号，而且随着Maixpy的发展，现在已经支持配置文件修改引脚号了，导致完全不需要代码上的修改就可以适配这个开发板。</p>
<p>中间曾经出现了python导致摄像头刷新率太低的问题，rebase到最新的Maixpy就解决了。</p>
<h2 id="前言">前言</h2>
<p>看到推荐就买了, 毕竟板载的传感器太全了, 一个小板子就什么都有了, 而且便宜. 导致我走上了这条路. 希望能静下心来. 学到什么. 我经常为了像这样做到些什么而学习, 但往往走偏, 后期只想着想要做到的事情, 完全抛弃了学习, 瞎试, 就是不去继续学.</p>
<h2 id="spi总线">spi总线</h2>
<p>maixpy支持其他板子, 经测试, 无法驱动本板子屏幕. 怀疑是接线有问题. 找来板子的接线图, 和各种硬件资料.</p>
<p>中景园1.14寸屏幕用的是TODO的芯片. 支持各种SPI通讯方式. 主要看屏幕控制芯片的手册.</p>
<p>SPI总线可以只靠一条线(3线接口), 或者控制/数据的电平信号线 + 真正的数据线(4线接口). 控制/数据的电平信号线为(高/低)的时候表示发送的这个字节是命令, 否则表示是数据(命令的参数). 另外, 这些传输都有时钟信号的同步.</p>
<p>片选信号变低, 选择芯片, 芯片准备接受数据. 不带(控制/数据的电平信号线)的时候传输9个bit, 第一个bit表示是控制还是数据. 带的时候连续传输8个bit, 传输第8个bit结束的时候对控制/数据信号进行采样, 判断是控制还是数据.</p>
<p>k210芯片带有fpio, 能够软件控制输出引脚和对应芯片内真正引脚的映射关系!! 可能类似fpga, 这个功能真是绝了, 可能是我见识太浅. 接spi线的时候, 一般spi接口的数据线还是直连, 其他复位, 控制/数据选择, 片选都可以直接在GPIO或者高速GPIO里面随便选一个. 因此不同板子要调整这些映射.</p>
<p>SPI总线也可以多条线, 4条,8条甚至16条等并行连接, 这个屏幕是典型的4线. 该板子可以外接的另外那个大屏幕似乎就是8数据线的spi.</p>
<p>4-line serial interface Ⅱ</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Pin Name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CSX/CS</td>
<td>Chip selection signal</td>
</tr>
<tr class="even">
<td>SCL</td>
<td>Clock signal</td>
</tr>
<tr class="odd">
<td>SDA</td>
<td>Serial data input data</td>
</tr>
<tr class="even">
<td>WRX/RS</td>
<td>Data is regarded as a command when WRX is low. Data is regarded as a parameter or data when WRX is high</td>
</tr>
<tr class="odd">
<td>DCX</td>
<td>Clock signal</td>
</tr>
<tr class="even">
<td>SDO</td>
<td>serial output data</td>
</tr>
</tbody>
</table>
<p>3 line interface Ⅰ spi 只有片选CSX, DCX时钟, SDA 输入输出 3 line interface Ⅱ 多了 SDO, 输入和输出引脚分开了. 4 line interface Ⅰ 只有片选CSX, WRX控制/数据(参数)选择, DCX时钟, SDA 输入输出 . 4 line interface Ⅱ同理.</p>
<p>DCX有时说是WRX一样的控制/数据选择. 可能是叫法的问题还是理解的问题???TODO</p>
<p>SCL --&gt; LCD_WR WRX/RS --&gt; LCD_DC</p>
<p>LCD_WR是时钟 GPIOHS30在maixpy代表LCD复位 GPIOHS31代表控制/数据选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fm.unregister(36, fm.fpioa.SPI0_SS3)</span><br><span class="line">fm.register(37, fm.fpioa.SPI0_SS3)</span><br><span class="line"></span><br><span class="line">fm.unregister(37, fm.fpioa.SPI0_SCLK)</span><br><span class="line">fm.register(39, fm.fpioa.SPI0_SCLK)</span><br><span class="line"></span><br><span class="line">fm.unregister(38, fm.fpioa.GPIOHS30)</span><br><span class="line">fm.unregister(39, fm.fpioa.GPIOHS31)</span><br><span class="line">fm.register(38, fm.fpioa.GPIOHS31)</span><br></pre></td></tr></table></figure>
<p>LCD是片选3 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------|-----------------------+</span><br><span class="line">|   36     |     LCD_CS            |</span><br><span class="line">+----------|-----------------------+</span><br><span class="line">|   37     |     LCD_RST           |</span><br><span class="line">+----------|-----------------------+</span><br><span class="line">|   38     |     LCD_DC            |</span><br><span class="line">+----------|-----------------------+</span><br><span class="line">|   39     |     LCD_WR            |</span><br><span class="line">+----------|-----------------------+</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fm.unregister(36, fm.fpioa.SPI0_SS3)</span><br><span class="line">fm.unregister(37, fm.fpioa.SPI0_SCLK)</span><br><span class="line"></span><br><span class="line">fm.register(37, fm.fpioa.SPI0_SS3)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fpioa_set_function(37, FUNC_GPIOHS0 + RST_GPIONUM);</span><br><span class="line">fpioa_set_function(38, FUNC_GPIOHS0 + DCX_GPIONUM);</span><br><span class="line">fpioa_set_function(36, FUNC_SPI0_SS0+LCD_SPI_SLAVE_SELECT);</span><br><span class="line">fpioa_set_function(39, FUNC_SPI0_SCLK);</span><br></pre></td></tr></table></figure>
<p>SPI_FF_STANDARD： 标准 ​ SPI_FF_DUAL： 双线 ​ SPI_FF_QUAD： 四线 ​ SPI_FF_OCTAL： 八线（SPI3 不支持）</p>
<h2 id="屏幕控制芯片todo">屏幕控制芯片TODO</h2>
<p>和芯片的交互基于SPI之后, 就是发送各种控制和数据. 芯片一般有nt35310和我现在的这个st7789. 首先是各种初始化的命令, 后面就是发送数据了. 显示的数据是一个个像素传送的, 有RGB565和SUV等颜色模式.</p>
<p>初始化首先发送SOFTWARE_RESET -(睡100ms 后面同理)-&gt; SLEEP_OFF --&gt; PIXEL_FORMAT_SET= 0x55 (表示是TODO模式) --&gt; DISPALY_ON</p>
<h2 id="屏幕定位">屏幕定位</h2>
<p>横着是x, 竖着是y方向</p>
<p>控制芯片的大小是<code>320x240</code>, 当设置屏幕大小是这个值的时候. 屏幕的大小是<code>240x135</code>, 刚好在中间. 左右空出40, 上下空出53/52左右 左上角大概在(40, 52), 右下角在(280, 187)左右. 发现代码中可以设置偏移, 把偏移设置成50 40(横屏模式), 和 40 52(竖屏模式) 就好了. 基本完美. 而且反色了... 和代码中写的颜色是反的, 代码中初始化是背景色红色, 白色的字. 不知道是不是有意为之, 或者有的屏幕就是这样. 反色之后的背景白里透蓝, 黑色的字. 那我就默认反色吧, 就和代码里的颜色一致了.</p>
<p>可以设置默认的屏幕大小. 按照保证允许软件传参更改的同时, 设置好能用的默认值的这个方针.</p>
<h2 id="摄像头">摄像头</h2>
<p>引脚接的都是对的. 可以直接用, 但是不稳. 不知道为什么例程很稳, 而当前的maixpy经常会报错</p>
<h2 id="ov2640-摄像头模块">ov2640 摄像头模块</h2>
<p>关键在于学习如何操作寄存器 k210的dvp datasheet:</p>
<blockquote>
<p>3.9 数字视频接口(DVP) DVP 是摄像头接口模块，特性如下： * 支持DVP接口的摄像头 * 支持SCCB协议配置摄像头寄存器 * 最大支持640X480 及以下分辨率，每帧大小可配置 * 支持YUV422 和RGB565 格式的图像输入 * 支持图像同时输出到KPU和显示屏: * 输出到KPU 的格式可选RGB888，或YUV422输入时的Y分量 * 输出到显示屏的格式为RGB565 * 检测到一帧开始或一帧图像传输完成时可向CPU发送中断</p>
</blockquote>
<h3 id="接口">接口</h3>
<p>PCLK,即像素时钟,一个PCLK时钟,输出一个(或半个)像素。</p>
<p>VSYNC,即帧同步信号。</p>
<p>HREF/ HSYNC,即行同步信号。</p>
<h3 id="颜色格式-rgb-yuv-ycbcr">颜色格式 RGB, YUV, YCbCr</h3>
<h4 id="sccb">sccb</h4>
<p>SCCB 特性都与 I2C 无区别, 可以直接用I2C控制器去通信</p>
<h3 id="dvp">dvp</h3>
<p>各种大大小小的时钟, 最终形成了同步的信号. 一个帧同步信号的有效时间内有很多个行同步信号, 每个行同步信号的有效时间内有很多像素时钟.</p>
<h3 id="输出格式">输出格式</h3>
<p>SVGA: 800 x 600 摄像头也可以配置缩放. 没写怎么配置的缩放的.</p>
<h3 id="图形翻转">图形翻转</h3>
<p>0xFF=1的时候, 04寄存器最高两位分别是水平镜像和垂直翻转. widora的ov2640例程中, 注释了airv r3 back的地方是 d8 也就是这两位都有. maixpy则是只有水平镜像(0xa8). 在去掉水平镜像之后, 也就是两个bit都不设置的时候(0x28), 后置摄像头显示刚好正常. (怀疑是)两边lcd的方向设置不一致, maixpy暂时调整摄像头这边.</p>
<h3 id="代码对比阅读">代码对比阅读</h3>
<p>linux的ov2640代码可能是发源地, 也是最完善的吧. 接着是openmv的代码, 比maixpy的整齐很多, 不乱. 接着就是kendryte的代码, 也许是参照openmv的,对比一下widora的例程. 最后是maixpy的代码.</p>
<h3 id="widora对比kentryte">widora对比kentryte</h3>
<p>代码的对比最好先format后diff. 这样即使widora他们声明数组是好几个一行, 也能迅速展平方便对比</p>
<p>经过对比发现, 除了多设置了一个翻转bit之外, 只有这两个不同. 官方是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0x5a, 0xc8&#125;,</span><br><span class="line">&#123;0x5b, 0x96&#125;,</span><br></pre></td></tr></table></figure> widora是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0x5a, 0x50&#125;,</span><br><span class="line">&#123;0x5b, 0x3C&#125;,</span><br></pre></td></tr></table></figure> 搜索ov2640和zmow, 找到了Android的相关驱动代码!!! Android它们相关驱动可能比linux还完善.</p>
<p>#define ZMOW 0x5A /* Zoom: Out Width OUTW[7:0] (real/4) <em>/ #define ZMOW_OUTW_SET(x) VAL_SET(x, 0xFF, 2, 0) #define ZMOH 0x5B /</em> Zoom: Out Height OUTH[7:0] (real/4) */</p>
<p>这样看的话, widora是: 320*240分辨率. 官方是800*600, 修改这里确实说得过去, 不过也不注释一下...</p>
<p>没想到这样的例程都用到了ai加速器? <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置允许导流到AI模型</span></span><br><span class="line">dvp_set_output_enable(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">//enable to ai</span></span><br><span class="line"><span class="comment">// DVP不直接导流到LCD</span></span><br><span class="line">dvp_set_output_enable(<span class="number">1</span>, <span class="number">1</span>);    <span class="comment">//disable to lcd</span></span><br></pre></td></tr></table></figure> dvp_set_ai_addr设置AI 存放图像的地址，供AI 模块进行算法处理。 void dvp_set_ai_addr(uint32_tr_addr, uint32_tg_addr, uint32_tb_addr)设置采集图像在内存中的存放地址，可以用来显示。 dvp_clear_interrupt(DVP_STS_FRAME_START | DVP_STS_FRAME_FINISH); 一般表示当前的这种中断处理完了, 可以来新的中断了. 算是是中断的pending位?. dvp_config_interrupt(DVP_CFG_START_INT_ENABLE | DVP_CFG_FINISH_INT_ENABLE, 1); 打开中断开关 dvp_start_convert() 在开始采集图像的时候调用 表示开始采集图像 dvp_disable_auto() 禁用自动接收图像模式。</p>
<p>总结起来, 就是开启dvp中断. k210的dvp会提供开始采集和停止采集的两种中断. 开始采集的时候, 在中断处理中调用start_convert. 结束采集的时候, 设置标志位. 当中断退出的时候, 忙等的处理器就会注意到标志位, 清零并设置切换buffer的标志, 向屏幕发送数据. 另外就是中断处理的时候根据buffer标志设置buffer. 根据需要切换buffer是在结束采集的时候?? 不应该啊, 切换buffer不是为了让采集和输出不在同一个buffer吗.</p>
<p>根据LCD的需求来切换dvp数据放到哪个缓存，目的是保证把图像传给LCD的时候, dvp不是正好输出到这个buf。</p>
<p>buf大小上, ai为什么要给三个RGB的buf? 我修改了zoom出来的大小是否相关的buf大小也需要变化? 查看发现widora和官方的main函数一直, buf大小相同. RGB565是2字节一个像素. 这里是320*240*2 = 38400个uint32 (widora的dvp buffer大小.) 而AI的buffer大小是3*12c00 = 38400 这是怎么回事? RGB怎么可能均分呢? 这可是RGB565.</p>
<p>set_framesize在设置QVGA的时候不仅设置了dvp_set_image_size, 也设置了摄像头那边的zoom寄存器.</p>
<h3 id="ov2640-帧率">ov2640 帧率</h3>
<p>分析software application notes的帧率设置案例. 下面的寄存器都在0xff=1的情况下 首先是0x11寄存器, 最低4位为clock dividor. 寄存器的值高帧率的时候为0, 低的时候为1, 可能divide了就帧率减半吗? 0x12寄存器的(低到高)第三位, zoom mode. svga的时候设为1, uxga的时候为0 0x2a寄存器, 大家都设置为0 line interval adjust value的高四位, Hsync start/end point adjustment MSB. 0x2b也为0, line interval adjust value的低8位. 帧率会被这个12bit的值微调. 0x46为低位, 0x47为高位, 组成了frame length adjustment. 这个值每多1, 就在帧中增加了1个水平线的时间. 0x47大家也都设置为0. 这个值是调整帧率的关键. 0x3d寄存器很神秘, 在手册的保留寄存器的范围内. svga设置为了0x38, uxga设置成了0x34</p>
<p>SVGA 800×600来看的话, 高度是600. frame length adjustment为0时的刷新率是30fps. 而增加了clock dividor, 帧率减半得到15fps. 如果只frame length adjustment设置为了0x87=135, 那么帧率就乘上了缩放倍数(600/600+135), 得到25fps.</p>
<p>总之关键在于寄存器0x11和寄存器0x46 0x47.</p>
<table>
<thead>
<tr class="header">
<th>type</th>
<th>clock dividor</th>
<th>frame length adjustment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>widora/kendryte</td>
<td>0</td>
<td>0x22</td>
</tr>
<tr class="even">
<td>maixpy</td>
<td>0</td>
<td>0x22</td>
</tr>
</tbody>
</table>
<p>当前maixpy的帧率, 30fps * (600/600+34) = 28.4帧... 为什么是这种奇怪的帧数? 难道是我哪里理解错了? 或者为了凑什么倍数??</p>
<h3 id="ov2460-颜色">ov2460 颜色</h3>
<p>0xff= CTRL0 = 0xC2寄存器 最低四位由低到高依次为RAW_EN, RGB_EN, YUV_EN, YUV422. 默认和maixpy的配置都是0x0C=1100 0xDA寄存器的名字是IMAGE_MODE, bit0 byte swap for DVP(low/high byte first), bit[3:2] 00-&gt;yuv422, 01-&gt;raw10, 10-&gt; RGB565, 11-&gt;Reserved kendryte是0x08, 也就是RGB565, maixpy是0x01, 也就是YUV422+byte swap</p>
<p>这边寄存器的设置要和那边dvp的接收设置匹配起来. 而调用picformat只是设置dvp的接收的格式.</p>
<h3 id="maixpy和openmv的代码解析">maixpy和openmv的代码解析</h3>
<p>openmv的代码更大型一些, 功能更多. 对摄像头相关的寄存器使用得更灵活. 前面的配置一般还是svga, 但是最后zoom出来分辨率不会那么大.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sensor    </span><br><span class="line">import lcd</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.run(1)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    lcd.display(img)</span><br></pre></td></tr></table></figure>
<p>先在这个典型的例程里, 依次分析一下各个函数. 代码结构依次是py_sensor.c -&gt; sensor.c -&gt; ov2460.c 首先是探测过程, 读取厂家和型号id. ov2460_init函数会填写sensor结构体, 暴露出内部函数. 设置frame_size的时候, 也会设置摄像头的zoom相关寄存器. set_pixformat似乎没有用了, 而且似乎是yuv. 设置成其他的格式会花屏. 也许是方便直接输入模型吧. set_framerate也无法设置, ov2460.c中直接返回-1了.</p>
<p>sensor和lcd没有直接的关联或者相互调用, snapshot函数则是传过去的关键. snapshot函数甚至还对buf做了什么jpeg压缩处理, 考虑了连接ide的情况.</p>
<p>超时不一定是摄像头配置问题. 也可能是中断处理问题. 试了下去掉双buf选项编译还是不行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    #ifdef CONFIG_BOARD_AIRVR3</span><br><span class="line">	&#123;0x5a, 0x50&#125;,</span><br><span class="line">	&#123;0x5b, 0x3c&#125;,</span><br><span class="line">    #else</span><br><span class="line">	&#123;0x5a, 0xc8&#125;,</span><br><span class="line">	&#123;0x5b, 0x96&#125;,</span><br><span class="line">    #endif</span><br><span class="line">	&#123;0x5c, 0x00&#125;,</span><br><span class="line">	&#123;0xc3, 0xed&#125;,</span><br><span class="line">	&#123;0x7f, 0x00&#125;,</span><br><span class="line">	&#123;0xe5, 0x1f&#125;,</span><br><span class="line">	&#123;0xdd, 0x7f&#125;,</span><br><span class="line">	&#123;0x05, 0x00&#125;,</span><br><span class="line">#if 1	//color bar</span><br><span class="line">	&#123;0xff, 0x01&#125;,</span><br><span class="line">	&#123;0x12, 0x02&#125;,</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="尝试log">尝试log</h3>
<p>reduced the clock to 11MHz, 似乎能提高帧率</p>
<p>图像格式的问题, 搞清楚是怎么设置的. 八成不是中断的问题... 把RGB关掉试试, 用YUV也是好的</p>
<p>测试情况: 使用airv配置 不注释svga, 有时花屏有时正常显示, 图像也上下左右反了 使用maixpy配置有时无法显示, 有时正常</p>
<p>不会显示异常的关键是选对dvp的颜色格式和摄像头配置的颜色格式</p>
<p>maixpy的摄像头相关还是不太行, 可能有bug. 这里如果不设置framesize就直接snapshot, 会报错Not init. 之后居然就崩了...</p>
<p>这就是软件工程的困境吗?</p>
<p>等一波新版本发布, github watch了</p>
<p>不会是供电问题吧... 只有程序小的时候才能正常显示</p>
<h3 id="总结">总结</h3>
<p>今天添加散热片发现, k210在dvp2lcd的时候发热还是非常大的. 而当我把k210吹冷了之后, 摄像头就又能用了. 可能摄像头本身就是好的吧, 一个是摄像头的参数不如官方的例程调教得好, 有一些彩色条纹. 看电脑屏幕有波纹(可能是正常现象.) 另外就是Back的时候, 需要额外设置hmirror(1)的时候才是正确的, 之后可以把这个设置搞成默认.</p>
<p>也可能是摄像头发热严重(更可能了, 因为我CPU降频了还是不太稳.) 这个还不好贴散热片 降频试试, 改代码增加了个clock devidor, 帧率减半, 看看会不会好一点</p>
<p>最后发现帧率减半确实稳定了一些, 没有显示的时候手动按下reset也容易来显示. 另外修改main.py, 利用time的计时器, 计算了一下调用sensor.snapshot和lcd.display消耗的时间 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while True:</span><br><span class="line">    img=sensor.snapshot()</span><br><span class="line">    print(&#x27;sensor time consume:&#x27;)</span><br><span class="line">    print(time.ticks_diff(time.ticks_us(), last))</span><br><span class="line">    last = time.ticks_us()</span><br><span class="line">    lcd.display(img)</span><br><span class="line">    print(&#x27;display time consume:&#x27;)</span><br><span class="line">    print(time.ticks_diff(time.ticks_us(), last))</span><br><span class="line">    last = time.ticks_us()</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sensor time consume:</span><br><span class="line">64081</span><br><span class="line">display time consume:</span><br><span class="line">158648</span><br><span class="line">sensor time consume:</span><br><span class="line">64122</span><br><span class="line">display time consume:</span><br><span class="line">158715</span><br><span class="line">sensor time consume:</span><br><span class="line">64022</span><br><span class="line">display time consume:</span><br><span class="line">158769</span><br><span class="line">sensor time consume:</span><br><span class="line">63994</span><br><span class="line">display time consume:</span><br><span class="line">158708</span><br><span class="line">sensor time consume:</span><br><span class="line">64098</span><br><span class="line">display time consume:</span><br><span class="line">158698</span><br></pre></td></tr></table></figure> 可能拖后腿的还是这个小屏吧? 毕竟只有一根线的spi? 或者说是maixpy的display太消耗时间了?</p>
<p>看了看那边widora例程的频率确实高一些, 设置<code>lcd.freq(20000000)</code>和那边相同之后帧率感觉高了一些, 不知道是不是错觉 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sensor time consume:</span><br><span class="line">73897</span><br><span class="line">display time consume:</span><br><span class="line">148786</span><br><span class="line">sensor time consume:</span><br><span class="line">74002</span><br><span class="line">display time consume:</span><br><span class="line">148886</span><br><span class="line">sensor time consume:</span><br><span class="line">73860</span><br><span class="line">display time consume:</span><br><span class="line">148909</span><br><span class="line">sensor time consume:</span><br><span class="line">73860</span><br><span class="line">display time consume:</span><br><span class="line">148867</span><br></pre></td></tr></table></figure> 把这个帧率也搞成默认吧. 直接在makefile里面设置就可以. 帧率就先不考虑, 主要考虑摄像头的稳定性, 不会重启用不了就好</p>
<p>我以为freq.conf是自己改的, 没想到是设置之后自动保存的, 我们不用改...</p>
<p>希望maixpy越来越好.</p>
<h2 id="i2s学习与maixpy麦克风">i2s学习与maixpy麦克风</h2>
<p>看怎么用上面的麦克风.</p>
<p>https://www.allaboutcircuits.com/technical-articles/introduction-to-the-i2s-interface/</p>
<p>https://hackaday.com/2019/04/18/all-you-need-to-know-about-i2s/</p>
<p>https://www.jianshu.com/p/e4f07bcd9df4</p>
<p>https://www.cnblogs.com/schips/p/12305649.html</p>
<table>
<thead>
<tr class="header">
<th>引脚</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SCK/BLCK/SLCK</td>
<td>clock</td>
</tr>
<tr class="even">
<td>WS/LRCK</td>
<td>word select</td>
</tr>
<tr class="odd">
<td>SD/SDATA</td>
<td>data</td>
</tr>
<tr class="even">
<td>NC</td>
<td>(悬空)</td>
</tr>
<tr class="odd">
<td>EN</td>
<td>片选/启用? 直接接到了3v3</td>
</tr>
<tr class="even">
<td>LR</td>
<td>左右选择</td>
</tr>
</tbody>
</table>
<p>I2S就是被设计来传送音频数据的, 其他的数据都是之后的hacky玩法. 它用一条线区分左右声道, 一条时钟线同步信号, 和一条真正的线传送数据. 在我们板子的receiver=master的情况下, 时钟和WS是接收方发送给麦克风的, 发送方通过SD发送数据给接收方.</p>
<p>I2S允许两个声道的数据在一条线上传送. 因此有了左右声道的选择线. 采样的时候要交替左右轮流读一个字, 导致这个选择线的信号也类似于时钟. 麦克风的规格书里推荐的就是两个麦克风的三条I2S线相连, 一个L/R接地, 一个L/R接电源, 这样就成为了一个立体麦克风.</p>
<p>板子的L/R是接地的, 因此音频要在左声道接受, 需要给出WS为低的时候才有数据, 否则为0. 这是使用的左对齐标准, 24bit的采样数据包装在32位中. 最右边8bit固定为0. Phillips标准则在WS高的时候发送左声道数据.</p>
<p>MSB优先发送. 变化WS之后要等一个时钟周期再开始接受数据. SCLK的频率=2×采样频率×采样位数, LRCK的频率等于采样频率, 这样就刚好能完整收集左右声道的采样数据了.</p>
<p>下面这段来自麦克风的规格书 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I²S DATA INTERFACE</span><br><span class="line">  The serial data is in slave mode I²S format, which has 24‐bit depth in a 32 bit word. In a stereo frame there are 64 SCK cycles, or 32 SCK cycles per data‐word. When L/R=0, the output data in the left channel, while L/R=Vdd, data in the right channel. The output data pin (SD) is tristated after the LSB is output so that another microphone can drive the common data line.</span><br><span class="line">Data Word Length</span><br><span class="line">  The output data‐word length is 24 bits per channel. The Mic must always have 64 clock cycles for every stereo data‐word (fSCK = 64 × fWS).</span><br><span class="line">Data‐Word Format</span><br><span class="line">  The default data format is I²S, MSB‐first. In this format, the MSB of each word is delayed by one SCK cycle from the start of each half‐frame.</span><br></pre></td></tr></table></figure></p>
<h2 id="k210的i2s">k210的I2S</h2>
<p>k210有3个I2S, 因此说它能接6麦克风阵列.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其中I²S0 支持可配置连接语音处理模块，实现语音增强和声源定向的功能。</span><br><span class="line">• 总线宽度可配置为8，16，和32 位</span><br><span class="line">• 每个接口最多支持4个立体声通道</span><br><span class="line">• 由于发送器和接收器的独立性，所以支持全双工通讯</span><br><span class="line">• APB 总线和I²S SCLK 的异步时钟</span><br><span class="line">• 音频数据分辨率为12,16,20,24 和32 位</span><br><span class="line">• I²S0 发送FIFO 深度为64 字节, 接收为8 字节，I²S1 和I²S2 的发送和接收FIFO 深度都为8字节</span><br><span class="line">• 支持DMA 传输</span><br><span class="line">• 可编程FIFO 阈值</span><br></pre></td></tr></table></figure>
<p>k210使用的是4通道的I2S.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[MAIXPY]: numchannels = 2</span><br><span class="line">[MAIXPY]: samplerate = 22050</span><br><span class="line">[MAIXPY]: byterate = 88200</span><br><span class="line">[MAIXPY]: blockalign = 4</span><br><span class="line">[MAIXPY]: bitspersample = 16</span><br></pre></td></tr></table></figure>
<p>目前还是没声音, 需要学习I2S的FIFO是什么意思. 深度是什么意思, 然后就是怎么处理ws的, 为什么每个I2S有4个输入,4个输出引脚, 采样率怎么设置</p>
<p>4个输入和4个输出应该是对应4个channel, 可能方便切换吧?? 接受数据的时候, 一个每次传送数据的cycle. 每次传送的数据的bit数</p>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>word_length/RESOLUTION</td>
<td>每个word的长度. 12/16/20/24/32选24</td>
</tr>
<tr class="even">
<td>word_select_size/SCLK_CYCLES</td>
<td>16/24/32选32. 大概是指在WS不变化的时候的cycle数, 也就是WS周期的一半.</td>
</tr>
<tr class="odd">
<td>word_mode</td>
<td>选左对齐.</td>
</tr>
</tbody>
</table>
<p>有声音了, 关键是上面列举的参数选择. I2S学习先告一段落.</p>
<p>i2s_set_dma_divide_16 函数能设置让DMA的时候自动把32 比特INT32 数据分成两个16 比特的左右声道数据。 那么这32bit的数据从哪来的?</p>
<p>I2S要不要设置时钟周期??</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Embedded</tag>
      </tags>
  </entry>
  <entry>
    <title>UAC-bypass 笔记</title>
    <url>/2020/UAC-bypass%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="uac-bypass-笔记">UAC-bypass 笔记</h1>
<p>这是之前课程中调研UAC bypass时自己一些零散的记录。</p>
<span id="more"></span>
<p>[toc]</p>
<h3 id="uac的防御">UAC的防御</h3>
<p>越考虑UAC如何防御，越感觉应该直接把UAC slide拉到最上面</p>
<p>但是确实有几个能绕过Always Notify的方法，这方面确实要防御防御</p>
<ol type="1">
<li>做攻击demo绕WD, 但是我们能检测</li>
<li>dismcore.dll 劫持，直接利用win defender</li>
<li>做一些定向的提前防御手段。做成一个程序。这样反而不用监测了。</li>
</ol>
<p>能讲的：</p>
<ol type="1">
<li><p>比Windows Defender能做得更好的地方。因为讲Win Defender的也就那一篇文章，研究防御的人还是少的，而我们就是研究了Windows defender的检测的人。搞搞花式绕过。目前有注册表跟随符号链接和.local的DLL劫持方面能检测绕过WD的攻击。</p></li>
<li><p>FIleless attack 只留在注册表的那个攻击。 这就可能会避开windows defender的扫描</p>
<p>https://github.com/bytecode77/living-off-the-land</p>
<p>https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</p>
<p>https://www.cybereason.com/blog/fileless-malware 现在的不少最新恶意软件在用</p></li>
<li><p>Living off the land 相关攻击</p></li>
<li><p>搞一些新的攻击检测，Process reimage attack？</p></li>
<li><p>锁屏界面下的键盘启动cmd的后门的检测 <a href="https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Attacking-Windows-At-The-Logon-Screen,---Gaining-Access-To-CMD-With-System-Privileges.">here</a></p></li>
</ol>
<p>有些部分windows用这种方法修复了，但类似的部分却没修复。</p>
<h3 id="值得讲的大块内容">值得讲的大块内容：</h3>
<p>注册表劫持的提权攻击-一系列。</p>
<p>COM组件提权 新博客内容。 COM组件提权的历史与修复</p>
<p>winsxs和.local机制 https://www.kernelmode.info/forum/viewtopicb857.html?t=3643&amp;start=90#p28579 ，高权限移动文件的基础方法，sysprep.exe系列的dll劫持，UAC攻击的起源</p>
<p>wow64log机制, .net的profiling dll</p>
<p>UIAccess的消息注入</p>
<p>Manifest的路径漏洞</p>
<h3 id="资源">资源</h3>
<p>https://www.kernelmode.info/forum/viewtopice732.html?f=11&amp;t=3643 能补充UACMe</p>
<h3 id="uac-绕过的历史">UAC 绕过的历史</h3>
<p>2014年12月：有63种UAC绕过的方法。20%的方法是其他方法的结合。<strong>Win32</strong>/<strong>Simda</strong>. B 这个之前广泛传播的木马，它利用的<strong>ISecurityEditor</strong> 这个方法让微软限制它只能用于文件后，不仅原来的方法失效了，<em>Application Verifier</em> dll planting（later this method was also used in some ITW malware）相关的方法也受到了影响。</p>
<p>微软只在有很大负面新闻的时候和大版本更新的时候才搞搞UAC。</p>
<p><em>Sysprep.exe</em>、<em>inetmgr.exe</em> 通过Manifest 的<strong><em>loadFrom</em></strong> 加固，unfortunately this was incomplete fix and it took them few more years to finally harden sysprep from dll hijacking。这里面的故事可以讲讲 TODO</p>
<p>*<strong>Software</strong> 被动了，WD就会报警</p>
<p><em>sdclt.exe</em> *<strong>/kickoffelev*</strong> 的报警</p>
<h3 id="uac-原理">UAC 原理</h3>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/technet-magazine/dd822916(v=msdn.10)">微软找借口文章1-</a></p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/bb757008(v=msdn.10)">How UAC Works</a></p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/bb756945(v=msdn.10)">UAC Architecture</a></p>
<p>在启动新进程的时候，通过一系列的流程决定是给程序受限令牌还是完整令牌。</p>
<p>通过安全桌面询问用户。</p>
<p>UAC slide UAC提醒级别控制条。AlwaysNotify</p>
<p>默认的级别运行可以看到，允许部分系统设置更改的时候提醒。</p>
<h3 id="uac自动提升总结">UAC自动提升总结</h3>
<p>Security through obscurity？</p>
<p>RPC call is made to AIS 。appinfo.dll逆向得到<a href="https://medium.com/tenable-techblog/uac-bypass-by-mocking-trusted-directories-24a96675f6e">自动提取的规则</a></p>
<p>阶段1：Manifest内的AutoElevate/<strong>g_lpAutoApproveEXEList</strong></p>
<p>阶段2 微软签名</p>
<p>阶段3 受信任的目录下 C: 、Program Files等</p>
<p>不能把微软的不提权程序通过修改Manifest成为提权程序，因为 如果自己去更改Manifest，会破坏签名</p>
<p>Manifest中的自动提升 https://technet.microsoft.com/en-us/magazine/2009.07.uac.aspx</p>
<ol type="1">
<li>被（微软）签名</li>
<li>位于如 C: 的安全目录<strong>g_lpIncludePFDirs</strong> 中</li>
</ol>
<p><strong>g_lpAutoApproveEXEList</strong> 内部的approve表，直接提权</p>
<p><strong>g_lpIncludePFDirs</strong> 内部的可信文件夹列表</p>
<p>COM Approval List <a href="https://docs.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker">elevated com moniker</a> https://swapcontext.blogspot.com/</p>
<ol type="1">
<li><p>需要首先在HKEY_CLASSES_ROOT {CLSID} = 1 这里启用</p></li>
<li><p>（RS1）HKEY_LOCAL_MACHINENT里面也有。这次更新打掉了不少的Bypass的</p></li>
</ol>
<h2 id="基本操作--explorer-ifileoperation">基本操作- Explorer + IFileOperation</h2>
<p>注入到Explorer.exe然后使用IFileOperation移动文件。</p>
<p>拓展：<a href="https://github.com/AV1080p/Mottoin-SecPaper/blob/master/UAC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90.md#0x03-%E6%8F%90%E6%9D%83%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">伪装成explorer.EXE</a></p>
<h2 id="dll劫持">DLL劫持</h2>
<p>https://www.freebuf.com/articles/system/83369.html</p>
<p>程序可以通过DLL实现拓展功能。由于DLL的灵活性，程序可以动态判断是否有某个DLL，如果有则加载，并使用相关的功能，没有则不加载，从而实现插件等功能。但这也为DLL劫持留下了机会。</p>
<p>可能是debug用途的劫持，可能是搜索路径靠前的劫持。</p>
<p>大多数的DLL劫持的方法需要高权限移动文件。这是第一道防线</p>
<p>接下来需要防住劫持的点，这是第二道防线。</p>
<p>最后是一些通用的劫持防御，比如system32文件夹下的可执行文件增加的检测，system32文件夹下的.local劫持检测，这是第三道防线。</p>
<p>通常情况下是不会有这些文件的，而且也不可能有。</p>
<p>然而sysmon只支持检测文件的创建：</p>
<ol type="1">
<li>检测创建文件时的路径里是否含有.exe.local<br />
</li>
<li>ImageLoad里面增加Include，判断路径里是否含.exe.local<br />
</li>
</ol>
<p>缺点：文件剪切粘贴会被绕过、无法检测文件夹创建</p>
<p>winsxs的dot-local为DLL劫持提供了更多的机会</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order">DLL搜索路径</a></p>
<p>一些可劫持的exe和dll组合的统计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\windows\System32\sysprep\sysprep.exe</span><br><span class="line">C:\Windows\System32\Sysprep\SHCORE.dll</span><br><span class="line">C:\Windows\System32\Sysprep\OLEACC.DLL</span><br><span class="line"></span><br><span class="line">C:\windows\System32\cliconfg.exe</span><br><span class="line">C:\Windows\System32\NTWDBLIB.DLL</span><br><span class="line"></span><br><span class="line">C:\windows\System32\pwcreator.exe</span><br><span class="line">C:\Windows\System32\vds.exe</span><br><span class="line">C:\Program Files\Common Files\microsoft shared\ink\CRYPTBASE.dll</span><br><span class="line">C:\Program Files\Common Files\microsoft shared\ink\CRYPTSP.dll</span><br><span class="line">C:\Program Files\Common Files\microsoft shared\ink\dwmapi.dll</span><br><span class="line">C:\Program Files\Common Files\microsoft shared\ink\USERENV.dll</span><br><span class="line">C:\Program Files\Common Files\microsoft shared\ink\OLEACC.dll</span><br><span class="line"></span><br><span class="line">C:\windows\System32\cliconfg.exe</span><br><span class="line">C:\Windows\System32\NTWDBLIB.DLL</span><br><span class="line"></span><br><span class="line">C:\windows\System32\pwcreator.exe</span><br><span class="line">C:\Windows\System32\vds.exe</span><br><span class="line">C:\Windows\System32\UReFS.DLL</span><br><span class="line"></span><br><span class="line">C:\windows\ehome\Mcx2Prov.exe</span><br><span class="line">C:\Windows\ehome\CRYPTBASE.dll</span><br><span class="line"></span><br><span class="line">C:\windows\System32\sysprep\sysprep.exe</span><br><span class="line">C:\Windows\System32\sysprep\CRYPTSP.dll</span><br><span class="line">C:\windows\System32\sysprep\CRYPTBASE.dll</span><br><span class="line">C:\Windows\System32\sysprep\RpcRtRemote.dll</span><br><span class="line">C:\Windows\System32\sysprep\UxTheme.dll</span><br><span class="line"></span><br><span class="line">C:\windows\System32\cliconfg.exe</span><br><span class="line">C:\Windows\System32\NTWDBLIB.DLL</span><br></pre></td></tr></table></figure>
<p>首先第一层防线是防止高权限移动文件。</p>
<p>dll劫持一方面攻击者可能发现各种各样的新dll可以劫持，拦截特定路径下的特定dll不太好</p>
<p>需要更好的办法</p>
<h2 id="winsxs">winsxs</h2>
<p>https://www.kernelmode.info/forum/viewtopic2782.html?t=3643&amp;start=110#p28833</p>
<p>https://docs.microsoft.com/zh-cn/archive/blogs/junfeng/dotlocal-local-dll-redirection</p>
<p>http://www.hexacorn.com/blog/2015/01/09/beyond-good-ol-run-key-part-23/</p>
<p>没有manifest就会启用.local，这样的程序不算多</p>
<p>设置注册表可以全局启用</p>
<p>当前目录下的exe名字+.local文件夹会优先成为dll搜索路径</p>
<p>dccw.exe屏幕校准和consent.exe，GoogleUpdate.exe没有menifest会找.local</p>
<h3 id="setprocessmitigationpolicy">SetProcessMitigationPolicy</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy">API文档</a></p>
<p>ProcessSignaturePolicy 防止加载非微软签名的dll。相关的论文不少。</p>
<p>怎样让系统exe能启动的时候调用？内核态驱动层设置？</p>
<h3 id="已经收集的攻击方法分类">已经收集的攻击方法分类</h3>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>未修复的攻击</th>
<th>已修复</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>注册表劫持</td>
<td>#33 #62 #53 #56 #61</td>
<td>#29 #25 #31</td>
</tr>
<tr class="even">
<td>DLL劫持</td>
<td>#22 #23 #30 #37 #39</td>
<td>#18 #26</td>
</tr>
<tr class="odd">
<td>COM组件</td>
<td>#38 #59 #41 #43</td>
<td></td>
</tr>
<tr class="even">
<td>UIAccess</td>
<td>#32 #55</td>
<td></td>
</tr>
<tr class="odd">
<td>其他</td>
<td>#36 #35 #52 #63</td>
<td></td>
</tr>
<tr class="even">
<td>环境变量</td>
<td>#34 #58</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中也有UAC提醒等级为Always Notify下可以绕过的方法: #26 #34</p>
<h3 id="windows-中的动词机制">Windows 中的动词机制</h3>
<p>https://docs.microsoft.com/en-us/windows/win32/shell/fa-verbs</p>
<p><strong>eg : Print</strong>, <strong>Edit</strong> and <strong>Open with</strong>. 这个动词对应的恰好是ShellExecute的lpOperation参数。系统拿着动词去注册表找。</p>
<p>HKEY_CLASSES_ROOT 是*HKEY_LOCAL_MACHINE的链接。内保存了各种不同类型的文件拓展对应的打开方式。如HKCR\.py\@ 保存的是Python.File。而HKCR\Python.File就保存了打开python文件的命令行。</p>
<p>但是HKEY_LOCAL_MACHINE是系统的总体打开方式。每个用户也有自己的HKEY_Current_User。</p>
<p>用户自己设置的打开方式理论上是覆盖系统的打开方式，就像局部变量的名字覆盖全局变量一样。</p>
<p>一般HKCU里面查不到是正常的，在HKLM里有，但是会去HKCU里面找。</p>
<h2 id="eventvwr.exe的注册表劫持---失效">#25 EventVwr.exe的注册表劫持 - 失效</h2>
<p>发现者：enigma0x3，时间：20160815。https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</p>
<p>sdclt.exe /KickOffElev</p>
<p>**HKCR*</p>
<p>EventVwr.exe redesigned, CompMgmtLauncher.exe autoelevation removed</p>
<p>https://github.com/turbo/zero2hero</p>
<ul>
<li>Works from: Windows 7 (7600)</li>
<li>Fixed in: Windows 10 RS2 (15031)
<ul>
<li>How: EventVwr.exe redesigned, CompMgmtLauncher.exe autoelevation removed</li>
</ul></li>
</ul>
<h2 id="sdclt.exe-apppathmethod---fixed">#29 sdclt.exe AppPathMethod - fixed</h2>
<p>发现者：enigma0x3，时间：20170314。链接：https://enigma0x3.net/2017/03/14/bypassing-uac-using-app-paths/</p>
<p>sdclt.exe（打开跳到控制面板的backup）通过查看低权限的注册表<strong>HKCU:Paths.exe</strong> 启动控制面板。</p>
<ul>
<li>Works from: Windows 10 TH1 (10240)</li>
<li>Fixed in: Windows 10 RS3 (16215)
<ul>
<li>How: Shell API update</li>
</ul></li>
</ul>
<h2 id="sdclt.exe-isolatedcommandmethod---fixed">#31 sdclt.exe IsolatedCommandMethod - fixed</h2>
<p>发现者：enigma0x3，时间：20170317。https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/</p>
<p>sdclt.exe /KickOffElev</p>
<ul>
<li>Works from: Windows 10 TH1 (10240)</li>
<li>Fixed in: Windows 10 RS4 (17025)
<ul>
<li>How: Shell API / Windows components update</li>
</ul></li>
</ul>
<h2 id="注册表劫持">#33（#62） 注册表劫持</h2>
<p>有点像infamous Enigma0x3 "<strong><em>mscfile fileless</em></strong>" bypass，但利用的是不同的注册表和不同的程序。widely used ITW by malware。</p>
<p>https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz</p>
<p>fodhelper.exe computerdefaults.exe 加载注册表中的 exe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New-Item &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Force</span><br><span class="line">New-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;DelegateExecute&quot; -Value &quot;&quot; -Force</span><br><span class="line">Set-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;(default)&quot; -Value cmd.exe -Force</span><br><span class="line">Start-Process &quot;C:\Windows\System32\fodhelper.exe&quot;</span><br><span class="line">Remove-Item &quot;HKCU:\Software\Classes\ms-settings\&quot; -Recurse -Force</span><br></pre></td></tr></table></figure>
<p>https://devblogs.microsoft.com/oldnewthing/?p=14623</p>
<p>其中#62就只是computerdefaults.exe触发</p>
<p>WD的检测与绕过：</p>
<ul>
<li>符号链接写入</li>
</ul>
<h2 id="注册表劫持-1">#53 注册表劫持</h2>
<p>Target key here is <strong><em>HKCU</em></strong>\<strong><em>Software\</em></strong> <span class="citation" data-cites="*Default">@*Default</span>* value (+<em>DeletegateExecute</em> as usual) and trigger is <em>sdclt.exe</em>。</p>
<p>WD会检测。修改那个@default就会触发。</p>
<p>绕过方法同上。</p>
<h2 id="注册表劫持-2">#56 注册表劫持</h2>
<p>Target key here is <em><strong>HKCU82a6gwre4fdg3bt635tn5ctqjf8msdd2</strong> <span class="citation" data-cites="*Default">@*Default</span></em> value (+<em>DeletegateExecute</em> as usual) and trigger is <em>wsreset.exe</em></p>
<p>WD会检测。修改那个@default就会触发。</p>
<p>绕过方法：准备好注册表相关的结构，再重命名过去。</p>
<h2 id="注册表劫持-3">#61 注册表劫持</h2>
<p>Target key here is <strong><em>HKCU*</em>Launcher.SystemSettings</strong> <span class="citation" data-cites="*Default">@*Default</span>* value (+<em>DeletegateExecute</em> as usual) and trigger is <em>slui.exe</em> which is started with <em><strong>runas*</strong> verb</em>.*</p>
<p>WD会检测。修改那个@default就会触发。</p>
<h2 id="com组件的环境变量劫持-alwaysnofity-ok">#58 COM组件的环境变量劫持 AlwaysNofity ok</h2>
<p><strong>EditionUpgradeManager</strong> 这个提权的接口里的<em>AcquireModernLicenseWithPreviousId</em> 函数会通过%windir%去组合路径调用<em>Clipup.exe</em>。设置windir环境变量去劫持。</p>
<p>Cheap and easy fix - get rid of environment variables from Win95 era and build a proper path to <em>clipup.exe</em> by using, surprise - surprise! <strong><em>GetSystemDirectory</em></strong>.</p>
<h2 id="diskcleanup计划任务---unfixed---alwaysnofity-ok">#34 DiskCleanup计划任务 - unfixed - AlwaysNofity ok</h2>
<p>20170515 <a href="https://twitter.com/tiraniddo">James Forshaw</a> https://www.tiraniddo.dev/2017/05/exploiting-environment-variables-in.html</p>
<p>https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz</p>
<p>*Microsoft会启动 %windir%.exe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Environment&quot; -Name &quot;windir&quot; -Value &quot;cmd.exe /k cmd.exe&quot; -PropertyType String -Force</span><br><span class="line">schtasks.exe /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /I</span><br></pre></td></tr></table></figure>
<p>WD的检测：<em>schtaks.exe</em> 的命令行是否包含“Microsoft”，有则警报 （<strong>Behavior:Win32/SilentCleanupUACBypass</strong>）</p>
<p>检查<strong>* 子串（</strong><em>PossibleSchedTasksUACBypass</em>** ）</p>
<p>绕过：不用schtaks，用<strong><em>ITaskService</em></strong>, <strong><em>ITaskFolder</em></strong> and <strong><em>IRegisteredTask</em></strong> 接口自己去启动</p>
<p>真正应该：检测windir 环境变量改变。</p>
<p>windows中的环境变量直接反映在注册表里。</p>
<h2 id="method-18--fixed">Method #18 -fixed</h2>
<p>参考资料：</p>
<p>https://www.reddit.com/r/lowlevel/comments/4lktyw/sxs_backdoor_and_story_of_windows_uac_ridiculous/</p>
<p>https://www.kernelmode.info/forum/viewtopicb857.html?t=3643&amp;start=90#p28579</p>
<p>背景，自从SxS+sysprep.exe的劫持，已经烂大街，微软拿出了自己的后门进行修复：</p>
<p><strong>malware</strong> friendly的微软对应用的垃圾Manifest文件的undocumented 项</p>
<p><code>&lt;file loadFrom="%systemroot%\system32\NAME.dll" name="NAME.dll" /&gt;</code></p>
<p>只要找到没有manifest的文件，通过外置manifest文件的方法，<code>ExeName.exe.manifest</code> 通过cryptbase.dll依然在sysprep文件夹内做dll劫持。</p>
<p><code>&lt;file loadFrom="%systemroot%\system32\sysprep\cryptbase.DLL" name="cryptbase.DLL"      /&gt;</code></p>
<p>当前该方法已经失效，因为外置manifest文件不再支持这个项了。</p>
<h2 id="section">#22</h2>
<p><em>comctrl32.dll</em> 植入到system32 （利用.local?） 劫持<em>consent.exe</em> 。</p>
<p>WD只检测了子文件夹创建，和文件移动到对应的文件夹内（移动？）。不移动，直接写入文件夹可以绕过？</p>
<p>首先通过<strong><em>IFileOperation</em></strong> with <strong>ISecurityEditor</strong> 创建文件夹并降权？</p>
<p>创建好对应名字的文件再降权再写入。</p>
<p>创建好其他名字的文件后再降权？再重命名，写入</p>
<p>微软应该这样修复： process mitigation policy 的 <strong>ProcessSignaturePolicy</strong> 设置为只有微软签名的</p>
<p>ProcessSignaturePolicy restrict image loading to those images that are either signed by Microsoft, by the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs</p>
<h2 id="pkgmgr-dism劫持">#23 PkgMgr-Dism劫持</h2>
<p>https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz</p>
<p>+博客https://swapcontext.blogspot.com/</p>
<p><em>PkgMgr</em> 被放弃支持了，但还在自动提权的exe列表（g_lpAutoApproveEXEList）里，是dism的启动器。</p>
<p>dism搜索<strong><em>dismcore.dll</em></strong> 的时候会先搜索system32文件夹，再搜索当前路径，然后找到。</p>
<ol type="1">
<li><p>创建<em>oemsetup.xml</em>文件，用来调用pkgmgr程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;unattend xmlns=&quot;urn:schemas-microsoft-com:unattend&quot;&gt;</span><br><span class="line">&lt;servicing&gt;</span><br><span class="line">&lt;package action=&quot;install&quot;&gt;</span><br><span class="line">&lt;assemblyIdentity name=&quot;Package_1_for_KB929761&quot; version=&quot;6.0.1.1&quot; language=&quot;neutral&quot; processorArchitecture=&quot;x86&quot; publicKeyToken=&quot;31bf3856ad364e35&quot;/&gt;</span><br><span class="line">&lt;source location=&quot;%configsetroot%\Windows6.0-KB929761-x86.CAB&quot; /&gt;</span><br><span class="line">&lt;/package&gt;</span><br><span class="line">&lt;/servicing&gt;</span><br><span class="line">&lt;/unattend&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>IFileOperation 移动DismCore.dll到<em>C:</em>.</p></li>
<li><p><code>"C:\WINDOWS\system32\pkgmgr.exe" /n:C:\Users\&lt;user&gt;\AppData\Local\Temp\oemsetup.xml</code></p>
<p>随后pkgmgr调用<code>"C:\WINDOWS\system32\dism.exe" /online /norestart /apply-unattend:"C:\Users\&lt;user&gt;\AppData\Local\Temp\oemsetup.xml"</code></p></li>
</ol>
<p>WD叫<strong><em>Win32/Disemer</em></strong>，首先会检测system32下的 DismCore.dll（平常系统不可能发生），其次会检测<em>pkgmgr.exe</em> 的参数里特定的Token</p>
<p>绕过方法：通过其他的dll去劫持。pkgmgr的参数（xml文件）也不用加什么？？因为没有意义。</p>
<h2 id="wow64-subsystem-logger-dll">#30 Wow64 subsystem logger dll</h2>
<p>subsystem logger dll是无文档内部的debug工具，十年前<a href="https://lhc645.wordpress.com/tag/wow64log-dll/">lhc645</a>就发现了。wow64log.dll 源码骨架都有。</p>
<p>每个wow64 application（32位）启动的时候都会加载它（64位），</p>
<p>This method has a lot of disadvantages and not that much room to maneuver in case of active counteraction from WD.</p>
<p>UACMe首先移植非native的wow64log.dll到system32，之后相关程序启动之后就会崩溃，然后启动<em>WerFault</em> 实例，此时wow64log.dll才执行payload。</p>
<p>最好能默认关闭这个debug功能。</p>
<h2 id="dismhost.exe劫持---fixed">#26 dismhost.exe劫持 - fixed</h2>
<p>发现者：enigma0x3，时间：20160722。https://enigma0x3.net/2016/07/22/bypassing-uac-on-windows-10-using-disk-cleanup/</p>
<p>cleanmgr.exe 系统的计划任务中的磁盘清理程序，是提权的计划任务。它运行的时候会把dismhost.exe和一些其他dll拷到%temp%.exe再运行。通过复制LogProvider.dll劫持。需要一直监控着temp文件夹然后在他们运行之前拷好。有点算条件竞争吧。</p>
<ul>
<li><p>Works from: Windows 10 TH1 (10240)</p></li>
<li><p>AlwaysNotify compatible</p></li>
<li><p>Fixed in: Windows 10 RS2 (15031)</p>
<ul>
<li>How: File security permissions altered</li>
</ul></li>
</ul>
<h2 id="section-1">#36</h2>
<p>infamous <em>SandboxEscaper</em> 利用Wusa在当前盘符根目录下创建的临时目录的安全性不对，利用NTFS reparse point feature。条件竞争设置reparse point到那个目录上就可以重定向写入到其他地方。</p>
<h2 id="section-2">#37</h2>
<p>使用#35去高权限移动文件。</p>
<p>使用GdiPlus with target set to <em>DCCW.exe</em> 进行dotLocal的dll劫持。</p>
<p>dccw.exe.local的防御</p>
<h2 id="没看懂">#38 没看懂</h2>
<p>This method uses <em>appinfo</em> command line parsing spoofing. This requires talking to <em>appinfo</em> via <em>RPC</em> as Windows Shell always build correct command line request when used <em>ShellExecute(Ex)</em>. This can be achieved through <strong><em>AicLaunchAdminProcess</em></strong> hook or by direct <em>RPC</em> call. You have to prepare your <em>MMC</em> snap-in and embed in it <em>Shockwave Flash Object</em> which will execute supplied <em>HTML</em> script located somewhere on disk. This <em>HTML</em> code will eventually run your payload through <em>ExecuteShellCommand</em> method.</p>
<h2 id="section-3">#59</h2>
<p><em>appinfo</em> direct talking 的debug object去提权，非常复杂。和#38利用的原理不同</p>
<h2 id="c-profile---unfixed">#39 C# profile - unfixed</h2>
<p>https://www.freebuf.com/vuls/183914.html</p>
<p>https://offsec.almond.consulting/UAC-bypass-dotnet.html</p>
<p>https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-bypass-UAC/</p>
<p>双击任一msc文件，通过Procmon监控发现最终运行的都是mmc.exe文件</p>
<p>CLR(Common Language Runtime)，是微软为他们的.NET的虚拟机所选用的名称</p>
<p>CLR会先检查环境变量中COR_ENABLE_PROFILING是否为1，若检查通过，则根据.NET版本不同，查找DLL位置的方法也不同，对于低于4.0的则去注册表中查找CLSID或ProgID项，找到其指定的dll文件路径。从.NET4.0版本开始则先查找环境变量COR_PROFILER_PATH是否指定dll文件路径，没有再去注册表中查找对应的CLSID项。所以这里我们就不设置COR_PROFILER_PATH了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COR_ENABLE_PROFILING = 1</span><br><span class="line"></span><br><span class="line">COR_PROFILER=&#123;CLSIDor ProgID&#125;</span><br></pre></td></tr></table></figure>
<p>找到HKEY_CURRENT_USER，分别添加以下新项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;11111111-1111-1111-1111-111111111111&#125;和InprocServer32</span><br></pre></td></tr></table></figure>
<p>该dll中只负责运行cmd.exe，并退出主进程：现在我们尝试运行gpedit.msc，看能否运行管理员权限的cmd程序：</p>
<p>WD：无法检测</p>
<p>检测方法：检测环境变量。</p>
<p>真正的修复：mmc.exe在高权限允许时应该不允许加载非微软签名的程序。</p>
<h2 id="icmluautil">#41 ICMLuaUtil</h2>
<p>应该直接从COMAutoApprovalList移除。</p>
<h2 id="icolordataproxy">#43 IColorDataProxy</h2>
<p>先用#41的任意注册表写，写入<strong>HKLMNT* <span class="citation" data-cites="*DisplayCalibrator">@*DisplayCalibrator</span>* 然后调用 </strong>IColorDataProxy** 通过高完整度<strong>ShellExecuteEx</strong> 运行指定的程序。</p>
<h2 id="appinfo里利用getlongpathname缺陷">#52 appinfo里利用GetLongPathName缺陷</h2>
<p>恶意软件非常喜欢的方法。简单。Win32 API path conversion</p>
<p>特殊方法创建一个后面带空格的"C:"目录，然后在appinfo.dll里面UAC检查的时候经过*<strong>GetLongPathName*</strong> 这个API会自作主张修复这个不合法的路径，导致之后比对的时候成为可信路径。</p>
<p>然后从system32里面拷可信exe出来做dll劫持。</p>
<p>UACME的作者改进了，增加了reparse points。</p>
<h2 id="osk的劫持uiaccess消息注入">#32 osk的劫持+UIAccess消息注入</h2>
<p>复制osk.exe到<code>%ProgramFiles%\Windows Media Player</code> 文件夹，然后通过该文件夹下的<em>duser.dll</em> or <em>osksupport.dll</em> 进行劫持，最终得到Medium+的带UIAccess的权限。可以通过MessageHook注入高权限进程。UacMe注入了<em>eventvwr.exe</em> 。</p>
<p>微软应该：</p>
<ol type="1">
<li>加固Manifest的LoadFrom项</li>
<li>禁止<em>UIAccess</em> 权限的进程从Medium+注入到High</li>
</ol>
<h2 id="method-55">Method #55</h2>
<p>有意思的攻击，虽然是自动化的，但是涉及到了UI的操作，会被用户看到。</p>
<blockquote>
<p>参考资料：</p>
<p>https://github.com/rootm0s/UUB</p>
<p>https://swapcontext.blogspot.com/</p>
<p>https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz</p>
</blockquote>
<p>获取UIAccess权限 -&gt; 利用它提权。</p>
<h4 id="阶段一-uipi-token窃取">阶段一 UIPI token窃取</h4>
<p>从msra.exe/osk.exe(on-screen keyboard) 窃取有UIAccess标志的令牌，然后修改完整度从Medium+到Medium，再启动自己的程序，这样就能操作高完整度的UI窗口了。</p>
<h4 id="阶段二-gui操作">阶段二 GUI操作</h4>
<p>启动msconfig打开cmd，cmd输入命令任意执行。</p>
<h2 id="section-4">#63</h2>
<p>相对较新的方法。dll injection to the Windows <em>Native Image Cache (NIC)</em></p>
<h2 id="always-notify下可以绕过的方法">Always Notify下可以绕过的方法</h2>
<h2 id="结语">结语</h2>
<p>While maybe not that sophisticated and complicated UAC is still part of Windows and integrated to the system. It is not about OpenDialog. The better you understand Windows internals the better you understand how UAC works and it weakness (and the more you laugh at yet another idiot with OpenDialog). Aside of this some of these bypasses are usually accompaned by various different mechanics, algorithms and internals that need to be researched.</p>
<p>There is a still a lot of possible real UAC bypasses undiscovered since this system mechanics is entirely broken in many ways and these methods are just waiting to be exploited.</p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>main函数启动与POSIX-ABI</title>
    <url>/2020/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E4%B8%8EPOSIX-ABI/</url>
    <content><![CDATA[<h1 id="main函数启动与posix-abi">main函数启动与POSIX-ABI</h1>
<span id="more"></span>
<p>https://0xax.gitbooks.io/linux-insides/content/Misc/linux-misc-4.html 这篇文章不错</p>
<p>https://embeddedartistry.com/blog/2019/04/08/a-general-overview-of-what-happens-before-main/ 这篇文章的拓展阅读不少好东西： https://lwn.net/Articles/631631/ ## 初始时的栈布局 https://luomuxiaoxiao.com/?p=516 这篇文章也不错</p>
<blockquote>
<p>3.2.1 首先，_start是如何启动的？ 当你执行一个程序的时候，shell或者GUI会调用execve()，它会执行linux系统调用execve()。如果你想了解关于execve()函数，你可以简单的在shell中输入man execve。这些帮助来自于man手册（包含了所有系统调用）的第二节。简而言之，系统会为你设置栈，并且将argc，argv和envp压入栈中。文件描述符0，1和2（stdin, stdout和stderr）保留shell之前的设置。加载器会帮你完成重定位，调用你设置的预初始化函数。当所有搞定之后，控制权会传递给_start()，下面是使用objdump -d prog1输出的_start函数的内容：</p>
</blockquote>
<p>所以程序的运行过程就是，系统把elf的规定好的几个段加载进去，然后从_start(entry_point)运行。但是这时候，难道栈上什么都没有吗？ 为了探究在进入entry_point时候的栈上的数据，看x86-64-ps-ABI.pdf。 在Low Level Interface &gt; Process Initialization &gt; Initial Stack and Register State这里的图3-9就表示了初始化时的栈布局： 这里先提一下寄存器的布局，除了rsp和rdx其他的寄存器的内容都是未定义的。其中rbp被点明需要清零，rdx是需要注册到退出前的函数的（application should register it with atexit）(BA_OS).这里观察到是_dl_fini。r13寄存器的值观察到和rsp一样，r12和rip一样。r9指向0x400000,rsi指向一个ld.so的数据段下方的无名地址。rax我还以为是execve的系统调用号，很可惜不是，而是0x1c。由于最先接管程序的反而是ld.so，所以这里的数据是什么在于它最后做了什么。而且栈的低地址方向上还有不少各种各样的数据，估计也是它的。有大概0xd10 3344字节的脏数据。。。 <img src="../imgs/psABIstack.png" alt="stack layout" /> 总之栈初始时是有东西的，而且还不少！随便找一个64位的程序用gdb打开，start自动停在入口点，就可以看到： 从低地址到高地址，首先rsp指向的是 argument count，接下来是对应数量的参数指针，接着是参数和环境变量之间的8字节空白分隔， 接下来是环境变量的指针数组，libc的全局变量environ就是指向这里。key和value没有分开，在同一个字符串里面用等于号连接。这样每一个指针就指向一个带等于号的字符串。然后又是一个8字节的0分隔。（可想而知如果程序简单，main函数的栈只有几十字节大小，环境变量数组很容易就被溢出了，导致调用system失败。。。） 接下来是一些不明意义的数据，叫做Auxiliary vector entries，每个16字节，前8字节是类型，后8字节是内容。这里接下来好像是0x18字节的分隔？ https://lwn.net/Articles/519085/ 可以通过getauxval()这个libc的函数调用获得 我对照着表把这次运行的flag都标注了一下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24:0120│          0x7fffffffe380 ◂— 0x21 /* &#x27;!&#x27; */ AT_SYSINFO_EHDR？</span><br><span class="line">25:0128│          0x7fffffffe388 —▸ 0x7ffff7ffa000 ◂— jg     0x7ffff7ffa047 # vdso 的地址。 link：https://www.jianshu.com/p/071358f497ea</span><br><span class="line">26:0130│          0x7fffffffe390 ◂— 0x10 AT_HWCAP</span><br><span class="line">27:0138│          0x7fffffffe398 ◂— 0x78bfbff  an bitmask of CPU features. It mask to the value returned by CPUID 1.EDX.</span><br><span class="line">28:0140│          0x7fffffffe3a0 ◂— 0x6 AT_PAGESZ</span><br><span class="line">29:0148│          0x7fffffffe3a8 ◂— 0x1000 in bytes. 这就是为什么加载时最后三位都是0吧</span><br><span class="line">2a:0150│          0x7fffffffe3b0 ◂— 0x11 AT_CLKTCK</span><br><span class="line">2b:0158│          0x7fffffffe3b8 ◂— 0x64 /* &#x27;d&#x27; */  contains the frequency at which times() increments.</span><br><span class="line">2c:0160│          0x7fffffffe3c0 ◂— 0x3 AT_PHDR</span><br><span class="line">2d:0168│          0x7fffffffe3c8 —▸ 0x400040 ◂— 0x500000006 给脚本文件开头的#!/bin/bash之类的用的， tells the interpreter where to find the program header table in the memory image.</span><br><span class="line">2e:0170│          0x7fffffffe3d0 ◂— 0x4 AT_PHENT </span><br><span class="line">2f:0178│          0x7fffffffe3d8 ◂— 0x38 /* &#x27;8&#x27; */  the size, in bytes, of one entry in the program header table to which the AT_PHDR entry points.</span><br><span class="line">30:0180│          0x7fffffffe3e0 ◂— 0x5 AT_PHNUM</span><br><span class="line">31:0188│          0x7fffffffe3e8 ◂— 9 /* &#x27;\t&#x27; */ the number of entries in the program header table to which the AT_PHDR entry points.</span><br><span class="line">32:0190│          0x7fffffffe3f0 ◂— 0x7 AT_BASE</span><br><span class="line">33:0198│          0x7fffffffe3f8 —▸ 0x7ffff7dd5000 ◂— jg     0x7ffff7dd5047 holds the base address at which the interpreter program was loaded into memory. 这里是ld.so的地址</span><br><span class="line">34:01a0│          0x7fffffffe400 ◂— 0x8 AT_FLAGS</span><br><span class="line">35:01a8│          0x7fffffffe408 ◂— 0x0 一些flag位，但暂时没有用？？</span><br><span class="line">36:01b0│          0x7fffffffe410 ◂— 9 /* &#x27;\t&#x27; */ AT_ENTRY</span><br><span class="line">37:01b8│          0x7fffffffe418 —▸ 0x400470 (_start) ◂— xor    ebp, ebp # the entry point of the application program to which the interpreter program should transfer control.这就是entry_point的地址 </span><br><span class="line">38:01c0│          0x7fffffffe420 ◂— 0xb /* &#x27;\x0b&#x27; */ AT_UID </span><br><span class="line">39:01c8│          0x7fffffffe428 ◂— 0x3e8 the real user id of the process.</span><br><span class="line">3a:01d0│          0x7fffffffe430 ◂— 0xc /* &#x27;\x0c&#x27; */ AT_EUID</span><br><span class="line">3b:01d8│          0x7fffffffe438 ◂— 0x3e8 the effective user id of the process.</span><br><span class="line">3c:01e0│          0x7fffffffe440 ◂— 0xd /* &#x27;\r&#x27; */ AT_GID</span><br><span class="line">3d:01e8│          0x7fffffffe448 ◂— 0x3e8</span><br><span class="line">3e:01f0│          0x7fffffffe450 ◂— 0xe AT_EGID</span><br><span class="line">3f:01f8│          0x7fffffffe458 ◂— 0x3e8</span><br><span class="line">40:0200│          0x7fffffffe460 ◂— 0x17 AT_SECURE </span><br><span class="line">41:0208│          0x7fffffffe468 ◂— 0x0 if the program is in secure mode (for example started with suid). Otherwise zero.</span><br><span class="line">42:0210│          0x7fffffffe470 ◂— 0x19 AT_RANDOM</span><br><span class="line">43:0218│          0x7fffffffe478 —▸ 0x7fffffffe4c9 ◂— 0x3f2d4c26e658aa6f # 16 securely generated</span><br><span class="line">random bytes.</span><br><span class="line">44:0220│          0x7fffffffe480 ◂— 0x1a AT_HWCAP2</span><br><span class="line">45:0228│          0x7fffffffe488 ◂— 0x0 contains the extended hardware feature mask. Currently it is 0, but may contain additional feature bits in the future.</span><br><span class="line">46:0230│          0x7fffffffe490 ◂— 0x1f AT_EXECFN</span><br><span class="line">47:0238│          0x7fffffffe498 —▸ 0x7fffffffefbe ◂— 0x6667682f746e6d2f (&#x27;/mnt/hgf&#x27;) a pointer to the file name of the executed program.</span><br><span class="line">48:0240│          0x7fffffffe4a0 ◂— 0xf AT_PLATFORM</span><br><span class="line">49:0248│          0x7fffffffe4a8 —▸ 0x7fffffffe4d9 ◂— 0x34365f363878 /* &#x27;x86_64&#x27; */ a string containing the platform name.</span><br></pre></td></tr></table></figure> 再往下就是一些数据了。比如保存环境变量的字符串，这里我居然看到了一个环境变量是SHELL=/bin/bash，如果能泄露到这个变量，那连输入/bin/sh也不用愁了，不知道部署到服务器会怎么样。可能到docker里环境变量就全没了吧 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; find 0x7fffffffe260, 0x7ffffffff000-1, &quot;sh&quot;</span><br><span class="line">0x7fffffffeda6</span><br><span class="line">1 pattern found.</span><br></pre></td></tr></table></figure> 我随便打开了一个程序，初始时的栈离底部是3488字节。</p>
<h2 id="sysdepsx86_64start.s函数">sysdeps/x86_64/start.S函数</h2>
<p>32位： 首先清空ebp 再调用__libc_start_main，然后就是hlt这个指令，opcode是f4。。。这个难道不是让cpu停止工作的指令吗。。。 _start的函数代码在sysdeps/x86_64/start.S 这个hlt处的代码的注释写道：/* Crash if somehow `exit' does return. */ 也就是说libc_start_main是不会返回的。因为它调用了exit <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STATIC int</span><br><span class="line">LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),</span><br><span class="line">		 int argc, char **argv,</span><br><span class="line">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span><br><span class="line">		 ElfW(auxv_t) *auxvec,</span><br><span class="line">#endif</span><br><span class="line">		 __typeof (main) init,</span><br><span class="line">		 void (*fini) (void),</span><br><span class="line">		 void (*rtld_fini) (void), void *stack_end)</span><br></pre></td></tr></table></figure> 参数有main函数，argc，argv，[辅助向量数组]，init函数 finit函数，rtld_finit函数，栈末尾指针 所以，当我们在rop中违法调用_start的时候，栈上的第一个数当成了argc，argv也错位了，剩下的参数还好 ## csu/libc-start.c __libc_start_main的主要功能： 处理关于setuid、setgid程序的安全问题 启动线程 把fini函数和rtld_fini函数作为参数传递给at_exit调用，使它们在at_exit里被调用，从而完成用户程序和加载器的调用结束之后的清理工作 调用其init参数 调用main函数，并把argc和argv参数、环境变量传递给它 调用exit函数，并将main函数的返回值传递给它</p>
<p>但是这里发现_start函数有一个很诡异的动作就是push rax push rsp。不知道是不是有意为之。总之栈上在argc上面就多了这两个数据。 其实是因为之前栈进行了对齐，这里push的rax是没有用的数据。而push的rsp是第七个参数stack_end指针，它要被放在栈上。rax就是为了保证对齐的。 接下来call __libc_start_main 栈上多了第一个返回地址。在argc上面一点点的__start+41这样的地址就是第一个返回地址。然而其实它并不会返回。</p>
<p>接下来则是dl去延迟绑定__libc_start_main。这里push了序号2和linkmap。之后进入_dl_runtime_resolve_xsavec它建立起了第一个栈。也就是说，这里保存了一个为0的rbp。所以按照栈帧回溯，最终是要回溯到0的。。。</p>
<p>我调试时发现源码上方写道忽略了fini参数，让fini参数在__cxa_atexit注册</p>
<h2 id="csuelf-init.c-libc_csu_init">csu/elf-init.c (libc_csu_init)</h2>
<p>libc_start_main函数的init参数被设置成了csu_init函数。csu函数先是调用了_init函数，再是循环调用init_array的函数指针，传入的参数和main函数一样 这里的init函数也在程序中 <img src="../imgs/startmaincallgraph.png" alt="start main call graph" /></p>
<p>在我的ida中，它也叫init_proc。程序极其短，就算是汇编也没有几行。调用完gmon函数就完了，所以它也就是一个设置profiling的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub     rsp, 8          ; _init</span><br><span class="line">mov     rax, cs:__gmon_start___ptr</span><br><span class="line">test    rax, rax</span><br><span class="line">jz      short loc_592</span><br><span class="line">call    rax ; __gmon_start__</span><br><span class="line"></span><br><span class="line">loc_592:</span><br><span class="line">add     rsp, 8</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gmon_start函数。如果它是空的，我们跳过它，不调用它。否则，调用它来设置profiling。该函数调用一个例程开始profiling，并且调用at_exit去调用另一个程序运行,并且在运行结束的时候生成gmon.out。</p>
</blockquote>
<p>回到csu_init，看来还是靠csu，它去调用每个init array <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    r15</span><br><span class="line">push    r14</span><br><span class="line">mov     r15, rdx</span><br><span class="line">push    r13</span><br><span class="line">push    r12</span><br><span class="line">lea     r12, __frame_dummy_init_array_entry # init array</span><br><span class="line">push    rbp</span><br><span class="line">lea     rbp, __do_global_dtors_aux_fini_array_entry # finit array的开始地址就是init array 的结束地址！</span><br><span class="line">push    rbx</span><br><span class="line">mov     r13d, edi</span><br><span class="line">mov     r14, rsi</span><br><span class="line">sub     rbp, r12 把init array的结束地址减去开始地址再除以8得到数组大小</span><br><span class="line">sub     rsp, 8</span><br><span class="line">sar     rbp, 3</span><br><span class="line">call    _init_proc # 调用init</span><br><span class="line">test    rbp, rbp</span><br><span class="line">jz      short loc_7B6 # 如果数组大小是0就提前跳转结束</span><br></pre></td></tr></table></figure> 也就是csu_init 就是负责调用每一个init数组的。 那init数组里到底有什么？一般是frame_dummy 为什么csu结尾有那么多的pop? 这是为什么? 难道csu是用汇编写的?? 其实不是, csu的源码如下 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_csu_init (<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* For dynamically linked executables the preinit array is executed by</span></span><br><span class="line"><span class="comment">     the dynamic linker (before initializing any shared object).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="comment">/* For static executables, preinit happens right before init.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = __preinit_array_end - __preinit_array_start;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__preinit_array_start [i]) (argc, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _init ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = __init_array_end - __init_array_start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__init_array_start [i]) (argc, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 有pop可能只是编译器用到了太多寄存器去实现这个函数, 所以先保存在栈上吧....</p>
<p>在x86-64-psABI.pdf的Program Loading and Dynamic Linking里面的Dynamic Linking的最后部分： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.2.2 Initialization and Termination Functions</span><br><span class="line">The implementation is responsible for executing the initialization functions specified</span><br><span class="line">by DT_INIT, DT_INIT_ARRAY, and DT_PREINIT_ARRAY entries in</span><br><span class="line">the executable file and shared object files for a process, and the termination (or</span><br><span class="line">finalization) functions specified by DT_FINI and DT_FINI_ARRAY, as specified</span><br><span class="line">by the System V ABI. The user program plays no further part in executing the</span><br><span class="line">initialization and termination functions specified by these dynamic tags.</span><br></pre></td></tr></table></figure> ## frame_dummy &gt; 接下来frame_dummy函数会被调用。其目的是调用__register_frame_info函数，但是，调用frame_dummy是为了给上述函数设置参数。这么做的目的是为了在出错时设置unwinding stack frames。 但是在我这ida里，它调用的是register_tm_clones https://stackoverflow.com/questions/41274482/why-does-register-tm-clones-and-deregister-tm-clones-reference-an-address-past-t 原来这两个函数是gcc的函数，其实不是libc的， https://stackoverflow.com/questions/34966097/what-functions-does-gcc-add-to-the-linux-elf</p>
<p>总之它们是为了提供多线程的原子类操作transaction memory的，在这里其实就是什么也不干，不会调用_ITM_registerTMCloneTable</p>
<h2 id="返回">返回</h2>
<p>csu_init结束返回</p>
<h2 id="exit函数">exit函数</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functions that were registered with the atexit or on_exit functions are called in the reverse order of their registration. This mechanism allows your application to specify its own “cleanup” actions to be performed at program termination. Typically, this is used to do things like saving program state information in a file, or unlocking locks in shared data bases.</span><br><span class="line"></span><br><span class="line">All open streams are closed, writing out any buffered output data. See Closing Streams. In addition, temporary files opened with the tmpfile function are removed; see Temporary Files.</span><br><span class="line"></span><br><span class="line">_exit is called, terminating the program. See Termination Internals.</span><br></pre></td></tr></table></figure>
<p>把fini函数和rtld_fini函数作为参数传递给at_exit调用，使它们在at_exit里被调用</p>
<h2 id="其他栈调用规范">其他：栈调用规范</h2>
<p>这个规范里面有关函数调用的部分值得好好读读，下面是之前探究system函数rop调用失败的情况。有机会再补充。</p>
<p>The x86-64 System V ABI guarantees 16-byte stack alignment before a call, so libc system is allowed to take advantage of that for 16-byte aligned loads/stores.</p>
<p>找这个标准 https://stackoverflow.com/questions/18133812/where-is-the-x86-64-system-v-abi-documented 找到了 https://github.com/hjl-tools/x86-psABI/tree/hjl/master</p>
<p>下载下来看第18页，里面的图显示了需要在调用函数时对齐16字节。 也就是call的时候的push rip占了8字节，然后函数开头保存ebp占用8字节，刚好16字节。 所以只要遵循了这个函数调用就可以正常使用system函数了.</p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>堆复习</title>
    <url>/2020/heap/</url>
    <content><![CDATA[<h1 id="堆复习">堆复习</h1>
<p>64位时, 默认开启的fastbin范围(chunk总大小)是0x20 - 0x80 32位TODO</p>
<p>tcache是64个单向链表，最多7个节点(chunk)，chunk的大小在32bit上是8到512（8byte递增）；在64bits上是16到1024（16bytes递增）。 fastbin只有10个链表, 范围肯定很小, 而和smallbins有62个, 大小基本重合.</p>
<p>当某一个tcache链表满了7个，再有对应的chunk（不属于fastbin的）被free，就直接进入了unsortedbin中。 tcache_perthread_struct结构，一般是在heapbase+0x10（0x8）的位置。对应tcache的数目是char类型。</p>
<span id="more"></span>
<h2 id="堆块结构">堆块结构</h2>
<p>堆块大小计算: 使用者视角, 两个指针的大小的整数倍(不包括下一个块的prevsize), 或者指针大小的奇数倍(包括下一个块的prevsize). 采用后一种说法</p>
<p>管理者视角, 每个堆块前面有size和prevsize, 其中prevsize属于前一个堆块, 当前一个堆块是空闲的时候, 会放上前一个堆块的大小. (有没有标志位?? TODO). 管理者视角来说的话, 堆块的大小为: (n * 两个指针的大小) + 指针大小(prevsize) + 指针大小(size). 也就是n+1倍的两个指针大小. size域保存的就是这种大小. 因此谈到各种bin的时候也是指包括size域的大小.</p>
<p>chunk指针一般指向prev_size域的开始处.</p>
<p>堆块siza域最低位是AMP. (32位的时候只有3bit, 但是64位的时候就有4bit没有用了. 但还是只用3bit)</p>
<p>总结NON_MAIN_ARENA块和mmapped块与其他正常块的区别. 在libc_malloc调用int_malloc返回的时候, 会检测得到的堆块是不是当前arena的. ?? TODO</p>
<p>mmapped的块指一页内存大小的整数倍的分配来的内存. 其他两个bit会被忽略, 因为它是单独的一块, 不会和其他空闲块相邻, 也不会在任何arena里. 回收的时候会直接调用munmap</p>
<h2 id="malloc_state">malloc_state</h2>
<p>malloc_state描述arena的结构体. 主线程的arena是全局变量, 其他的arena在堆上(TODO). non_main_arena 可以有多个"堆"(heap_info). <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk 不在其他任何bin里 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Unsorted, small and large bins */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins 表示某个bin空 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list, 组织各个arena */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">mstate</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="bins">bins</h2>
<p>fastbin有10个,位于fastbinsY, 单链表, 栈式后进先出, 大小是 <code>(1 * 两个指针的大小) + 2 * 指针大小</code> 到 <code>(10 * 两个指针的大小) + 2 * 指针大小</code>. 内部的堆块标记为使用中, 不前后合并</p>
<p>其他的bin都是双链表.<code>mchunkptr bins[NBINS * 2 - 2];</code>中, 两个指针是一个bin. 下标为0的bin没有被使用, 下标为1的是unsorted bin. 下标2-63的是small bin. 下标64-126的是large bin.</p>
<p>small bins 有 62个. 列表式的先进后出. 范围是16=0x10 --- 504=0x1f8大小.(含header) 64位是32=0x20 - 1008=0x3f0大小</p>
<p>large bins 有63个. 前32个, 每个bin管理64大小, 后16个, 每个bin管理512字节的范围, 8个4096, 2个262144, 1个剩下的任何大小.</p>
<p>top chunk是最底下的chunk, 使用sbrk的时候扩大的就是这个chunk. 它的prev_inuse位总是在的, 因为相邻的free chunk在free的时候总会被合并.</p>
<p>last remainder chunk 上一个被分隔的chunk</p>
<h2 id="bins的循环">bins的循环</h2>
<p>综述: free的bins首先放到unsorted里, malloc遍历unsorted的时候顺便整理放到各个bins里</p>
<h3 id="malloc_init_state">malloc_init_state</h3>
<p>对非fastbin, 创建头节点指向尾节点的循环 设置mstate的flags中的FASTCHUNKS_BIT. 初始化top chunk为第一个unsorted bin中的chunk.</p>
<h3 id="int_malloc">_int_malloc</h3>
<p>__libc_malloc获取了arena后调用该函数. 如果大小在fastbin中. 去fastbin中找, 没有则到下一步, 有则检查得到的块, 检查通过后返回. 大小在small bin的时候, 去small bin中找, 如果对应的bin为空, 则下一步. 有则从末尾取一个, 检查一下另外一个方向的链表是否正常. 然后设置内存相邻的下一个chunk的prev_inuse, 最后返回 大小在large bin的, 也到large bin里找. 找完后调用malloc_consolidate (如果arena有FASTCHUNKS_BIT). 如果都没找到就遍历unsorted bin, (只有这时候才会把chunk放到bins里面) 从尾部遍历, 遍历的时候插入large bin的时候会总是插入第二个位置. 当1. 申请的chunk是small bin大小. 2. 当前的chunk是last remainder. 3. 这个chunk的大小大于请求的大小, 则将这个chunk分割, 剩下的部分还放回unsorted bin. 还没找到的话, 如果是large bin, 就遍历每个更大的large bin, 找到小的但大于要求大小的large bin. 能分隔则分隔, 不能分隔(剩下的空间小于最小chunk大小)则不分隔返回. 分隔出来的chunk插入到unsorted bin 末尾. 如果是small bin, 开始考虑更大small bin的分割. 同样找到最小的但大于要求大小的chunk分隔. 如果都不能满足, 则使用top chunk. 剩下的成为新的top chunk 如果还不能满足, 调用sysmalloc用mmap分配内存.</p>
<h2 id="int_free">_int_free</h2>
<p>如果在fastbin 区间内, 插入人fastbin 再前后合并, 注意和top chunk的合并, 检查unsorted bin 并插入头节点.</p>
<h3 id="malloc_consolidate">malloc_consolidate</h3>
<p>遍历每个fastbin, 前后如果有free chunk先调用unlink后合并, 放到unsorted bin 头部里面去. 如果是top chunk当然和top chunk 合并</p>
<h2 id="层次化描述malloc">层次化描述malloc</h2>
<p>malloc和free这内存管理的逻辑过于复杂, 而且很多逻辑耦合比较紧密, 不好拆开分块理解. 导致了学习的难度. 这里试图采取迭代的思想, 毕竟大型项目都是从简单到复杂的迭代出来的.</p>
<h3 id="small-binlarge-bin模型">small bin+large bin模型</h3>
<p>该模型中只有small bin和large bin. 堆块的分配, 第一阶段是精确查找. 无法在对应的bin中找到时进入第二阶段是best fit查找, 找到满足要求的最小的堆块, 分隔或者不分割得到最终的堆块. free的时候也前后合并, 合并了再放到bin里. 该模型还包含了top chunk. free的时候如果和top chunk 相邻, 则和top chunk合并. 当small/large bin中任何chunk都无法满足的时候, 首先看top chunk, 然后使用mmap去满足. 包含了binmap的数据结构, 方便跳过空的bins. binmap中标记为空的bin一定为空, 但是标记为有的bin则不一定必须有chunk, 也可以为空.</p>
<p>(精确查找阶段对于large bin是只要求处于相同bin内还是必须相同大小?? TODO 怀疑是后者)</p>
<h3 id="slsmall-large-unsorted-bin模型">sl(small large) + unsorted bin模型</h3>
<p>该模型加入了unsorted bin. free的时候直接放入unsorted bin开头, 而malloc的时候, 在精确查找和best fit查找之间插入unsorted bin查找, 在末尾一边找一边处理unsorted bin. 当unsorted bin碰到大小合适的bin的时候直接返回, 否则就一直查找处理(把遍历过的chunk插入合适的small/large bin中).</p>
<p>为了使unsorted bin处理的时间更加均匀, 处理unsorted bin中的chunk最多处理MAX_ITER个.</p>
<h3 id="改进1-减少多次分割时的开销.">改进1 减少多次分割时的开销.</h3>
<p>经常会碰到小bin完全空, 分配时总是去某个large bin中分割的情况. 这种情况每次分配小块的时候都需要遍历一次很多small bin和large bin. 可以做出改进. 当每次有split的时候, 将剩下的chunk作为last remainder chunk单独指针保存, 并且插入unsorted bin的末尾. 当遍历unsorted bin的时候, 如果是小chunk(在small bin范围内), 当前指向的chunk是last remainder chunk, 并且大小大于要求的大小, 则优先分隔该chunk直接返回.</p>
<h3 id="slu-fast-bin模型">slu + fast bin模型</h3>
<p>增加10个fast bin 作为上述模型的外包层. free的时候, 如果是fast bin范围内的直接放入fast bin(因为fast bin无限容量.233 这也说明unsorted bin不会有fast bin范围的chunk?? TODO) malloc的时候的精确查找阶段先去fast bin里面找(fast bin范围内), 没有再去small/large bin里找.</p>
<p>引入 malloc_consolidate函数, 用于把fast bin中的chunk清理到small bin 中去. 引入flags中的 FASTCHUNKS_BIT 指示当前的arena有没有fast bin.</p>
<p>best fit阶段也不能满足, 找到了topchunk. 如果top chunk也不能满足要求, 就先清理掉fast bin再去mmap. 调用malloc_consolidate, 然后再去重新遍历unsorted bin, 把所有的chunk都清理了. 之后再回到这里, 发现没有fast bin的时候再通过mmap满足要求.</p>
<p>当分配large bin而精确查找阶段也满足了的时候也调用 malloc_consolidate.</p>
<h2 id="sluf-tcache模型">sluf + tcache模型</h2>
<p>在fast bin之前增加tcache. (在__libc_malloc()调用_int_malloc()之前)在获取arena之前, 就先看tcache, 有则直接返回. free的时候优先放到tcache, 满了才继续放到别处.</p>
<p>tcache是很多个链表, 保存大小相同的chunk. tcache是直接指向下一个的tcache_next, 而不是指向堆块头部. 直接形成链表 tcache_perthread_struct用于维护各个tcache内空闲堆块的数量, 和索引各个tcache. 第一次malloc的时候, 会malloc一块区域保存tcache_perthread_struct.</p>
<h2 id="与其他部分的关系">与其他部分的关系</h2>
<p>glibc2.26 开始有了tcache, 并默认开启. tcache比small bin还多一点. 内存释放的时候, tcache没满优先放到tcache. 分配的时候, 调用malloc之前看看tcache有没有. 申请fastbin大小的内存的时候, 找到fastbin内如果找到, 把fastbin上其他块填入tcache中. smallbin同理. 处理unsorted bin的时候, 即使找到大小合适的块, 也不直接返回, 而是</p>
<h2 id="查阅的资料">查阅的资料</h2>
<p>64位时, 默认开启的fastbin范围(chunk总大小)是0x20 - 0x80 32位TODO</p>
<p>tcache是64个单向链表，最多7个节点(chunk)，chunk的大小在32bit上是8到512（8byte递增）；在64bits上是16到1024（16bytes递增）。 fastbin只有10个链表, 范围肯定很小, 而和smallbins有62个, 大小基本重合.</p>
<p>当某一个tcache链表满了7个，再有对应的chunk（不属于fastbin的）被free，就直接进入了unsortedbin中。 tcache_perthread_struct结构，一般是在heapbase+0x10（0x8）的位置。对应tcache的数目是char类型。</p>
<h2 id="待整理">待整理</h2>
<blockquote>
<p>绕过tcache使得堆块free后进入unsorted bin的方式通常有两种：</p>
</blockquote>
<blockquote>
<p>每个tcache链上默认最多包含7个块，再次free这个大小的堆块将会进入其他bin中，例如tcache_attack/libc-leak 默认情况下，tcache中的单链表个数是64个，64位下可容纳的最大内存块大小是1032（0x408），故只要申请一个size大于0x408的堆块，然后free即可</p>
</blockquote>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>rcore学习笔记</title>
    <url>/2020/rcore%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="rcore学习笔记">rcore学习笔记</h1>
<p>这是我这几天学习rcore-Tutorial第三版时的笔记, 汇总到了一起. <a href="#lab1中断">lab1</a> 学习了不少RISC-V的中断相关的基础知识, 之后补的中断相关的知识也补在这里了 <a href="#lab3虚拟内存管理">lab3</a>, <a href="#lab4线程与调度">lab4</a> 对实现细节写得详细一些, 稍微看懂一点代码就写上去了, 很多函数的实现细节都写下来了.</p>
<p>有的地方还留下了一些疑问没有解决, 自己也查了资料但没有找到答案, 如果去掉感觉有可能产生误导, 所以就留着了.</p>
<span id="more"></span>
<h2 id="lab1中断">lab1中断</h2>
<p>回顾ucore, ucore的lab1也主要讲了中断, lab2讲分页 ucore的进程管理分了好几个lab, 内核进程, 用户进程, 进程调度.</p>
<p>添加了interrupt/context.rs, 文件也是一个mod, interrupt文件夹也是一个新的mod, 现在rust2018, 既可以采用src/interrupt/mod.rs, 也可以用src/interrupt.rs来代表整个文件夹作为mod.</p>
<p>由于中断说起来比较顺口, 因此下文中部分地方说中断这个词的时候其实既包括中断又包括异常, 也就是包括那些会跳转到trap vector的事件.</p>
<h3 id="csr-是什么">CSR 是什么</h3>
<p>Control and status registers, 大部分是处理特权相关的寄存器. 为操作系统程序提供特权, 方便管理用户态程序.</p>
<p>操作这相关的寄存器的包装, riscv这个crate, 这是相关的文档. https://docs.rs/riscv/0.6.0/riscv/register/index.html dependencies里写的居然是rcore自己的fork, 而且比官方的多了特别多的commit, 太神奇了. 因此可能有我们rcore自己的fork实现的东西, 而文档里没有.</p>
<h3 id="risc-v中断">RISC-V中断</h3>
<p>比较关键的一点是sbi做什么, 而操作系统做什么 https://github.com/riscv/riscv-sbi-doc/blob/master/riscv-sbi.adoc 可以看看上面这个文档. 一个稍微比较重要的理念是supervisor态和user态都可能是虚拟化的, 只有m态不是虚拟化的. 因此一些对虚拟化有用的操作都不能直接从s态掌控. 包括时钟和ipc. 硬件线程间的通信.</p>
<h4 id="异常中断委托">异常/中断委托</h4>
<p>委托机制的使用: 默认是所有中断和异常都转到m模式的mtvec, 通过设置mideleg/medeleg寄存器可以设置把哪些中断和异常委托给s模式.</p>
<p>下面这段话是privileged isa手册中说的 &gt; Some exceptions cannot occur at less privileged modes, and corresponding x edeleg bits should be hardwired to zero. In particular, <code>medeleg[11]</code> and <code>sedeleg[11:9]</code> are all hardwired to zero.</p>
<p>最后一句的意思是m模式产生的ecall异常无法被委托, s模式下的ecall和m模式下的ecall在sedeleg中无法被委托给user模式.</p>
<p>所以在tutorial中具体哪些中断被委派了? 启动的时候opensbi会打印委派寄存器的值如下. MIDELEG : 0x0000000000000222 MEDELEG : 0x000000000000b109 mideleg的bit为分布和mip和mie相同, medeleg的bit分布对应那张异常的编号的表. 分析一下得知: 地址对齐异常, 断点异常, 用户模式的ecall, 三种页异常(读写和指令) 被委派. 中断有: s态软件中断, s态时间中断, s态外部中断 被委派</p>
<p>TODO 为什么user态的三个中断没有被委派?? user态中断是m态先处理还是s态先处理??</p>
<h4 id="中断的屏蔽">中断的屏蔽</h4>
<p>sstatus的SIE位是总开关, 每个单独的中断也可以针对性地屏蔽, 在sie寄存器有对应的屏蔽位. sie和sip这两个寄存器中, 只有被m态委派的对应位能够修改.</p>
<h4 id="中断向量">中断向量</h4>
<p>中断寄存器stvec指向的是中断的入口. 不像x86有一长条的中断向量表. 有两种模式, 向量模式和直接模式, 直接模式用一个地址处理所有中断和异常, 向量模式则会让不同中断跳转到不同的位置, 在基地址的基础上加上一定的偏移量, 而异常还是直接跳转到基地址. mtvec<a href="vec寄存器的指令对齐使得最低位无效">0</a>设置为1可启用向量模式中断, 根据中断原因x将PC设置为(base + 4x), 也就是跳转到不同的地址.</p>
<p>产生中断时各种中断相关的位会被放到对应的previous位中, 之前的权限模式被放到sstatus的SPP.</p>
<p>执行相关的sRet指令的时候, 类似于产生异常的逆过程. 1是会把sepc恢复到pc, 2是sstatus中各种previous位都恢复到原来的位置. mret, uret类似.</p>
<h3 id="中断过程梳理">中断过程梳理</h3>
<p>之前lab0完成了最小的启动, 通过sbi接口打印字符 本次lab1的代码主要完成的是中断相关. 接到控制权后转到了entry.asm 将bss段作为栈, 然后调用rust_main.</p>
<h4 id="中断准备">中断准备</h4>
<p>正是因为rust_main被汇编调用, 因此声明的时候要加上extern "C"从而使用C的abi. rust_main 作为初始化代码, 刚启动就执行的代码, 自然是调用各种初始化函数. 这里调用中断初始化, 这部分代码单独放到一个mod内了, 也就是interrupt文件夹.</p>
<p>具体来说, 使用global_asm宏引入了interrupt.asm, 在要用到的地方用extern "C" 声明函数, 最后使用write写入__interrupt地址到stvec.这里把写入stvec寄存器也放到unsafe内的原因是这个函数声明的作用域仅限unsafe作用域内.</p>
<p>main函数中调用interrupt模块的初始化, 完成中断的准备. 中断的初始化主要做两件事, 把准备好的中断处理函数加载到trap vector寄存器stvec, 和打开中断总开关和对应的分开关.</p>
<p>进入interrupt模块的初始化函数, 分别是handler的初始化和timer的初始化.handler的初始化函数设置了stvec寄存器为interrupt.asm中符号<code>__interrupt</code>的地址, 同时开启sie寄存器中s态外部中断的开关 TODO 外部中断有哪些??. timer的初始化函数则打开了sie中的s态时钟中断, 和中断的总开关, 并且设置了第一次时钟中断.</p>
<p>那Sstatus寄存器的SIE位负责的是中断总开关, 而类似ebreak这样的是异常, 所以不设置这个位也能进入trap处理. 当lab1后半部分用到时钟中断的时候就要设置SIE位打开总开关了.</p>
<h4 id="中断发生">中断发生</h4>
<p>中断随时可能来, 发生的时候, 可能程序执行到一半, 即使是一些临时寄存器也可能正在使用. 因此不能破坏任何现场.</p>
<p>断点异常和S态时钟中断都被opensbi在deleg系列寄存器中委托过了, 因此这两个中断产生时就会转到我们S态的中断向量处.</p>
<p>当有中断或者异常发生的时候就会跳转到之前设置好的<code>__interrupt</code>处, 硬件只是会修改sepc, scause, stval等寄存器的值, 而不像x86会直接保存到栈上. 保存到栈上全靠我们操作系统的指令. 而<code>__interrupt</code>主要做的就是保存现场并恢复. 首先是把各个寄存器压栈形成Context, Context的结构并不复杂, 32个通用寄存器, 加上sstatus, sepc. (riscv的pc不在32个通用寄存器里) 然后将栈上的Context地址放到a0, 把scause放到a1, 把stval放到a2, 最后jal(jump and link) 实现跳转. 因为函数调用约定就是用的jal调用函数, ret返回. link代表把下一个指令的地址放到link寄存器中. 当handle_interrupt函数返回的时候, 就回到了汇编代码interrupt.asm中, 到了__restore这个部分, 自动开始了恢复中断的过程.</p>
<p>sscratch是一个单纯用来存数据的寄存器, 在tutorial中, sscratch在用户态用来保存内核栈的地址, 内核态是0, 因为进入内核态(进入中断)的时候os把它清零. 之后为了支持用户态程序, 就需要用到sscratch, 先切换栈再保存Context, 而我们lab1还是一直内核态, 内核态发生中断, 就可以直接保存各种寄存器在当前栈上, 取出栈上的指针作为Context结构体的借用传入interrupt_handler. sstatus里的带P(previous)的位会被设置好, 因此需要保存sstatus. 而scause和stval就直接看作局部于这次中断处理的临时变量(handle_interrupt的参数), 不保存, 在中断处理的过程中用寄存器传递.</p>
<p>os/src/interrupt.asm 内含中断保存现场__interrupt, 和恢复现场__restore 首先sp减34*8开辟空间, 保存时使用以sp为基地址的栈上偏移量寻址Context成员(类似栈上临时变量), 为了sp(x2)保持不变, 首先保存x1, 然后利用空闲出来的x1去计算原来的sp, 也就是把sp加34*8保存到x1, 再保存x1(作为sp(x2)), 再依次保存各种寄存器. 恢复的时候最后恢复sp即可.</p>
<p>handle_interrupt函数直接根据cause来调用不同的函数处理. 如果是断点异常, 就打印出来, 将PC加2(看来使用了C拓展减少了指令长度), 时钟中断就调用tick函数, 默认就调用fault函数panic并且打印未解决的异常.</p>
<h4 id="时钟中断">时钟中断</h4>
<p>现在RISC-V的timer一般都是内置在cpu内的, 不像x86是通过外部芯片产生时钟中断.</p>
<p>每次时钟中断的时候, 都会从中断处理程序那走一遭, 然后调用tick函数计数并继续设置下一次时钟. 目前设置的是每10 0000条指令产生一次时钟中断</p>
<blockquote>
<p>S模式不直接控制 时钟中断 和软件中断，而是使用 ecall指令请求 M模式设置定时器或代表它发送处理器间中断。该软件约定是监管者二进制接口 (Supervisor Binary Interface)的一部分。</p>
</blockquote>
<p>上面这句话来自那本中文的《riscv手册》. 虽然时钟的设置是通过sbi接口, 也就是ecall指令去使用m态程序(opensbi)提供的服务, 但时间到了的通知, 还是通过S态时钟中断. (猜测是opensbi设置时钟, 得到m态的时钟中断信号的时候, 传递下来, 产生S态的时钟中断信号.)</p>
<p>由于没有一个接口来设置固定重复的时间中断间隔，因此我们需要在每一次时钟中断时，设置再下一次的时钟中断.</p>
<h4 id="断点异常">断点异常</h4>
<p>ebreak指令会产生断点异常. 无论是ebreak还是ecall, 产生异常时的sepc都是指向该指令, 而不是下一条指令.</p>
<p>??那其他异常呢? 是下一条指令吗?? TODO</p>
<h4 id="中断结束">中断结束</h4>
<p>当handle_interrupt函数返回的时候, 返回到调用它的interrupt.asm中的jal指令之后, 开始恢复之前保存的现场. 直接把各个保存的寄存器恢复, 这样寄存器的状态就是发生中断时的状态. 恢复现场后, sstatus和sepc也恢复了, sret, 返回的时候将pc设置为sepc. 并且恢复sstatus寄存器, 把里面的previous位都还原. 如果中断之前是打开中断的状态, sret后也会回到打开中断状态. 最终恢复到中断前被打断的位置继续执行。</p>
<h3 id="interrupt-pending-寄存器">interrupt pending 寄存器</h3>
<p>machine/supervisor/user interrupt pending寄存器是提供有关正在等待的中断的信息.</p>
<p>这里我也没有彻底学懂, 不过rcore-tutorial没怎么用到.</p>
<h4 id="背景">背景</h4>
<p>当多个中断发生的时候, riscv首先处理特权级最高的, 特权级相同的时候按照 外部-&gt;软件-&gt;时钟的顺序处理(使得最差情况时的处理时间最小). 因此当很多中断同时发生的时候, 或者ISA中断服务例程执行的时候, 其他中断却来了, 此时产生了中断pending. 让当前的中断例程能感知到新中断的存在有一定的作用, 我临时搜索了一下发现, 在arm架构中好像就有相关的应用. 看到一个是应用是省略相继产生的中断间的重新弹栈压栈, 提升性能.</p>
<h4 id="作用">作用</h4>
<p>当从mip(xip)寄存器中获取值的时候, 得到的是对应寄存器和对应中断产生信号的OR之后的值. 也就是如果这个中断真正在等待, 对应的pending位就为1.</p>
<p>高特权级如果设置了低特权级的对应中断的pending位, (不知道是回到对应特权级的时候还是立刻?)就会产生对应的中断. 如, m态的程序就可以通过设置mip对应的supervisor的中断pending位, 从而让低特权级的程序产生中断. 各种m态的中断的pending位在mip寄存器中是只读的, mip中对应低特权级的pending位则既可读, 也可以写触发上述效果. S态软件中断, U态软件中断(基本上)靠这种方式产生.</p>
<h2 id="lab2内存管理">lab2内存管理</h2>
<p>包括临时堆内存管理, 物理内存管理.</p>
<h3 id="临时堆内存管理">临时堆内存管理</h3>
<p>ucore中是先实现按页的物理内存管理, 再实现的任意大小的管理的. 而这里完全不一样, 先是bss段留了8M空间作为堆, 给操作系统动态内存分配用, 再去单独实现按页的物理内存管理.</p>
<p>这里我暂时使用临时堆内存管理这个新词, 表示为了使用rust提供的一些需要使用堆内存的数据结构而在bss段上划分出一块空间作为堆. rcore-tutorial这里我们直接使用现有的buddy system内存分配算法, 在代码中开辟8M大小的bss段空间(u8数组), 作为被分配的空间.</p>
<p>我们分配算法和rust的对接主要在于Trait GlobalAlloc, 实例化之后用 <code>#[global_allocator]</code>标记就可以使用动态内存分配了(可以使用一些需要动态内存分配的内置数据结构, 如Box, Vec等). 接口也是和C语言中malloc/free类似的接口: alloc和dealloc.</p>
<h4 id="bssbuddy-system实现细节">bss+buddy system实现细节</h4>
<p>直接分配u8 static数组,数组名字指向的就是对应的空间. 添加buddy system这个包. spin和lazy_static也顺便加上. 创建memory文件夹作为新的mod, 创建init函数被main调用. 创建一个HEAP全局变量作为分配器, 并在init函数里面把那个数组的内存初始化给它. 想把数组的名字作为指针, 只需要调用.as_str()然后as转换为usize就可以了. 这样, main函数调用完heap的init之后就可以分配堆空间了.</p>
<h4 id="使用自己的堆分配算法">使用自己的堆分配算法</h4>
<p>也可以不使用buddy_system, 答案中的heap2使用自己的algorithm crate的bitmap_vector_allocator提供分配算法支持, 这里自己实现分配算法也可以很简单, 代码量挺少的.</p>
<p>堆分配算法和其他代码的接口一个是<code>#[global_allocator]</code>标注, 一个是init函数. 这里使用的是bitmap标记空闲, 以字节为单位, 查找时按照对齐要求的倍数顺序查找(作为内存的开头), 直到遇到了空闲处. 只标记4096字节, 最多只能管理4K的内存. 这里的实现也是对给定内存范围的对应内存的index(偏移)做分配, 每次分配得到的只是一个偏移, 需要去找到对应的内存地址.</p>
<p>不像buddy_system实现好了GlobalAlloc, 为了global_allocator要实现alloc::alloc::GlobalAlloc这个trait. 需要实现分配和回收两个函数, 传入的是core::alloc::Layout, 并且需要处理指针类型 *mut u8. 直接整个实现都是unsafe的. Heap全局变量也不再是简单的直接是一个实例, 而是在VectorAllocatorImpl的基础上包了一层Option, 再包UnsafeCell. UnsafeCell取内部的值需要get再as_mut, Option就直接unwarp, 就可以得到内部的VectorAllocatorImpl调用alloc/dealloc函数.</p>
<p>包一层Option有一个好处就是可以提供默认值. 初始化之前, Option里是None, 初始化函数使用replace函数替换成实例之后才能分配, 否则会在unwrap的时候panic</p>
<p>完成之后, 将main函数堆测试代码的两个循环数量从10000减少到100才能正常通过测试. 这个自己实现的算法毕竟管理的内存比较少.</p>
<h3 id="按页的物理内存管理">按页的物理内存管理</h3>
<p>物理内存管理不像临时堆内存管理只是为了让我们操作系统自己用, 它是虚拟内存管理的基础. 否则的话只要直接把buddy_system的LockedHeap的init函数中传入的内存改成我们可用的所有内存范围, 就能让我们操作系统自己用上这些内存了.</p>
<h4 id="封装地址类型与frame-tracker">封装地址类型与frame tracker</h4>
<p>内存地址空间确实是非常常用的东西. 无论是分页内存管理还是mmio, 之后肯定会大量用到内存地址的. 因此这里封装出了地址类型. 1. 封装地址类和页号类 1. 抽象实现From trait在地址和页号间相互转换 1. 抽象实现地址转页号的向上/下取整 1. 抽象实现和usize的加减输出操作.</p>
<p>还要在memory中新建mod range. 提供对内存地址range的支持. 它在基础的core::ops::range基础上增加相互转换, 和len函数, 和迭代, 重叠检测, 虚拟物理相互转换, 取下标, 包含检测的功能.</p>
<p>frame tracker 作为物理页面的智能指针, 继承PhysicalPageNumber, 实现Drop. frame模块除了frame_tracker的实现, 同时承载分配相关的实现: allocator.rs 对分配算法进行包装, 对接frame tracker和分配. 分配算法实现Allocator trait(一次分配回收一个元素的index), 包装后提供初始化创建(起始物理页号和页数量), 分配一个页(frame tracker), frame tracker析构的时候自动调用回收. 由于是简单的一次分配一个元素, 而且可以是离散的, 简单地使用一个栈进行分配. 创建StackedAllocator, 在allocator.rs中作为AllocImpl, 就会使用这个算法了.</p>
<p>frame tracker创建的时候不会自动申请页面, 因此想要获得frame tracker需要通过allocator分配, 不能自己构造.</p>
<h4 id="分配哪些内存">分配哪些内存</h4>
<p>可以直接根据qemu内存映射, riscv从0x8000_0000开始到0x8800_0000这128M初始内存, 直接硬编码拿来. 硬编码在 MEMORY_END_ADDRESS, 另外还要设置这些全局变量KERNEL_END_ADDRESS, MEMORY_START_ADDRESS, KERNEL_HEAP_SIZE.</p>
<p>在ucore中, 一般以函数指针结构体作为接口, 让不同的分配算法提供相同的接口. 而且还花大量精力, 使用Page结构体, 链表组织空闲页面.(物理内存管理), 而我们这里实现的就简单得多, 对物理页的下标直接管理.</p>
<h4 id="frameallocator">FrameAllocator</h4>
<p>实现单页单页的物理内存的分配和回收. 内部使用的算法是StackedAllocator, 非常简单, 一个Vec, 新建的时候把一段物理内存范围输入, 每次分配取栈顶的一页, 每次回收页就压入栈中. 按照单页的分配和回收使得实现起来非常简单, 时间空间复杂度也会很低. 接着在StackedAllocator基础上包装出FrameAllocator, 把对下标的分配转化成真正的内存地址, 并且返回时返回Frame Tracker.</p>
<p>物理内存的分配器目前只实现的单页单页的分配和回收, 这一点我之前其实觉得挺合理的, 因为现在离散式虚拟内存技术已经非常成熟, 我们操作系统用到的现在全都是虚拟地址, 需要"连续的内存"时也一般是需要连续的虚拟地址空间, 因此物理地址的分配完全可以是这样一页一页离散的. 但是之后的lab可以看到, DMA确实出现了需要连续的物理内存空间这种需求, 看来这里的实现确实值得改进...</p>
<h3 id="用到的其他小知识点">用到的其他小知识点</h3>
<p>pub(super) 指只对父模块是public的 https://doc.rust-lang.org/reference/visibility-and-privacy.html</p>
<p>KERNEL_END_ADDRESS是lazy_static, 因为不用会报错"pointer-to-integer cast" needs an rfc before being allowed inside constants</p>
<p>下面这个impl代表某种类型, 而且最终会被确定下来 https://doc.rust-lang.org/std/keyword.impl.html <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = T&gt; &#123;</span><br><span class="line">    (<span class="keyword">self</span>.start.<span class="title function_ invoke__">into</span>()..<span class="keyword">self</span>.end.<span class="title function_ invoke__">into</span>()).<span class="title function_ invoke__">map</span>(T::from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这句话的下划线似乎代表让编译器推断类型 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">offset</span> = ptr <span class="keyword">as</span> <span class="type">usize</span> - &amp;HEAP_SPACE <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="lab3虚拟内存管理">lab3虚拟内存管理</h2>
<h3 id="sv39页内存管理">Sv39页内存管理</h3>
<p>Sv39最大支持512G地址空间, 分为3级页表. 每级页表大小都是一页, 因为8B * 512 = 4K. 最高级的页表, 每一项表示1G的地址空间, 第二级页表每项表示2M地址空间, 最低级的页表每一项表示4K地址空间. 虚拟地址空间64位只有低39位有效, 63-39 位的值必须等于第 38 位的值. 也就是说, 根据最高位是不是1, 512G地址空间被分为低256G(高位都是0), 和高256G(高位都是F).</p>
<p>39位的划分: 页内12位 + 9 + 9 + 9 对应的内存大小: 每页4K, ---(512页)---&gt; 2M -(512)-&gt; 1G -&gt; 512G 十六进制表示: 0x1000 -&gt; 0x20 0000 -&gt; 0x4000 0000 -&gt; 0x80 0000 0000 现在架构中最大可寻址的物理地址有56位. 也就是有56-12=44位标识页 而页表项中<code>[53-10]</code>这44位用来标识一个物理页. 也就是物理地址的过高位和低12位去掉之后还要右移两位才可以对应上页表项中. 页表项内低10位自然就是标志位. 页表项最低位(Valid位), 为0则表示该页表项无效.</p>
<p>然而三级和二级页表项不一定要指向下一级页表, 可以作为大页... 如果RWX位全0才是指向下一级页表, 否则作为大页, 项中指向映射的开始页, 向后自动映射2M/1G内存. 这方法厉害啊, 可以在线性映射的时候节约不少内存空间. 另外, 大页也需要按照自己的大小对齐.</p>
<p>satp寄存器指向页表. 要在修改 satp 的指令后面马上使用 sfence.vma 指令刷新整个 TLB。手动修改一个页表项之后可以通过在sfence.vma后面加上一个虚拟地址来刷新单独的页表项中这个虚拟地址的映射.</p>
<h4 id="页表工作方式">页表工作方式</h4>
<ol type="1">
<li>首先从 <code>satp</code> 中获取页表根节点的页号，找到根页表</li>
<li>对于虚拟地址中每一级 VPN（9 位），在对应的页表中找到对应的页表项</li>
<li>如果对应项 Valid 位为 0，则发生 Page Fault</li>
<li>如果对应项 Readable / Writable 位为 1，则表示这是一个叶子节点。 页表项中的值便是虚拟地址对应的物理页号 如果此时还没有达到最低级的页表，说明这是一个大页</li>
<li>将页表项中的页号作为下一级查询目标，查询直到达到最低级的页表，最终得到页号</li>
</ol>
<h3 id="内核启动">内核启动</h3>
<h4 id="内核地址空间的变化">内核地址空间的变化</h4>
<p>内核的地址空间要抬高, 在512G虚拟地址中不是平移256G. 数据段起始地址变成0xffff ffff 8020 0000, 在Sv39看来是0x7f_8020_0000 而原来是0x00 8020 0000, 多了0x7f 0000 0000, 也就是平移了508G.</p>
<p>另外观察到: 0x80200000 = 2G + 2M</p>
<h4 id="启动过程">启动过程</h4>
<ol type="1">
<li>0x80200000处(entry.asm)使用汇编开启分页模式</li>
<li>开启分页模式的一瞬间, 当前的PC还在原来的位置, 因此需要映射0x80200000附近的位置, 同时需要映射0xffffffff80200000 附近的位置 直接使用大页映射, 4K空间作为最高级页表, 映射两个1g, 简单方便省内存. (这里之后的lab会为了访问磁盘设备需要再映射1g的页).</li>
<li>跳转到rust内(rust_main)</li>
</ol>
<h3 id="代码变化梳理">代码变化梳理</h3>
<p>内核启动之后, rust_main在之前的初始化的基础上, 我们还会新建一个kernel的MemorySet内存地址映射, 并激活它. 这里的MemorySet更多主要是为了之后的进程的地址空间映射准备的. 之后lab的main函数在初始化的时候就不会再激活这样的映射了.</p>
<p>需要修改的地方有: 1. ld脚本需要修改链接的基址, 这个比较简单 2. 启动的asm文件, 需要加上临时页表, 和装载临时页表的语句 3. 加入虚拟地址结构体, 实现一些相关trait, 增加一个偏移量常量KERNEL_MAP_OFFSET</p>
<p>修改完这几个, 内核依然能够正常运行进入rust_main. 接着修改, 下面这前两步的工作量最大 1. 封装页表项, 页表等 1. 实现MemorySet, 和内部的Mapping和Segment 2. main函数中新建kernel类型的映射并激活</p>
<h4 id="entry.asm">entry.asm</h4>
<p>这里只说说这个页表项 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.quad (0x80000 &lt;&lt; 10) | 0xcf</span><br></pre></td></tr></table></figure> 由于取页号放到第10位开始的位置, 也就相当于0x8000 0000 &gt;&gt;12 &lt;&lt;10, 0xcf表示 VRWXAD这几个标志位均为 1, 表示这个页具有RWX属性.</p>
<h4 id="虚拟地址的封装-memoryaddress.rs">虚拟地址的封装 memory/address.rs</h4>
<p>完善之前物理地址的封装, 加上虚拟地址 1. 指针转换为虚拟地址, 实现这个trait, 这样任何指针类型都可以直接转虚拟地址类型 2. deref_kernel和deref可以用地址类型转换成任意类型的指针, 而且生命周期是static的. pageNumber类型的deref使得可以直接获得页表大小的u8数组. 3. 对VirtualPageNumber类型实现levels函数, 获得三级页号. 4. 也为address类型实现page_offset函数, 取得页内偏移.</p>
<h4 id="实现页表-memorymapping">实现页表 memory/mapping</h4>
<p>不仅封装了页表, 页表项, 还封装了mapping结构, 类似ucore的vma 1. page_table_entry.rs 封装页表项. 实现了Flags类, 表示每个entry低8bit的标志位. 用implement_flags宏抽象标志位的读的实现. 提供了address函数, page_number函数用来找到页表项指向的页面, 实现了flags函数获取flags, 还有is_empty函数, has_next_level函数, 最后实现了Debug trait的打印 2. page_table.rs 封装了页表(页表项数组). 这里还需要把之前的frame_tracker增加了derefMut到u8数组的trait. 封装了PageTableTracker作为PageTable的智能指针. 内部包含一个FrameTracker, 实现自动释放内存的功能. 和PageTable只有一个Deref的距离. 创建页表时要申请物理页将FrameTracker包装为PageTable的智能指针类型再使用. FrameTracker管理一个页, 并且能转换为任何类型, 作为任何类型的智能指针. 而包装了FrameTracker的PageTableTracker则更加具体, 仅仅作为页表的智能指针. 3. segment.rs 封装了线性映射类型, 实现了遍历某个映射中每个页的功能. 映射有两种类型, 操作系统使用的线性映射, 和按帧分配的离散映射. 后者只能遍历虚拟页, 前者可以直接使用虚拟转物理的转换trait遍历物理页. 4. mapping.rs 负责管理各种页表. 使用vec保存PageTableTracker这个智能指针, 同时另外保存根页表的物理页号(对应页表寄存器). 实现了激活该页表activate函数, new函数新建页表同时分配根目录表, map函数映射一个segment, map_one函数映射一页, unmap移除映射, 会创建页表的find_entry函数(和ucore中那个函数类似), 虚拟地址查找物理地址的lookup函数. 5. memorySet总览全局, 包含了Mapping结构体和Segment数组, 实现添加和删除映射的总接口, 调用下部的mapping的添加和删除映射的接口. 另外还实现了让main函数调用的new_kernel新建memorySet和各种映射的函数, 之后的lab里还要实现读取ELF创建映射的函数</p>
<h3 id="实现细节">实现细节</h3>
<h4 id="mapping">Mapping</h4>
<p>mapping负责管理页表, 整个文件100多行, 非常重要. 1. map_one函数, 映射一个页, 调用find_entry找到对应的entry, 为空则新建并填入Page: <code>*entry = PageTableEntry::new(ppn, flags);</code>由于page_table就是page_table_entry数组, 因此直接赋值由于实现了Copy, 就导致页表项写入. 2. lookup函数, 这个函数是静态的!! 首先拿出当前的页表寄存器内的值, 找到页目录表. 把参数的虚拟地址转为页号调用levels函数方便获取每级下标. 然后先取好最高级页表的下标, 再在循环中如果有下一级页表, 不断取下标, 直到页表项为空(判断valid???), 或者不再有下一level, 此时的entry就保存了base地址, 加上虚拟地址低位的offset(不一定只有12位)得到真正的地址. 3. find_entry函数, 这个函数和lookup有些类似, 但是是从自己的mapping实例的页表物理页号中找到页表, 找的过程中如果页表不存在就直接分配新的页作为页表, 总是能找到页表项, 而且找的总是代表4k一页大小的第三级页表项. 4. unmap函数, 调用find_entry函数并调用clear 5. map函数, map一整个segment. 如果是线性映射, 则遍历虚拟地址不断调用map_one填页表项, 有数据复制数据, 最重要的特点是不用分配物理页面. 如果是离散映射, 则遍历虚拟地址不断分配页面, 把分配到的页面填充0. 拷贝数据的时候映射还没建立, 需要从物理地址加offset这个通用的访问物理内存的映射来复制, 还要考虑区间与整页不对齐的情况, start变量指从页开头开始的偏移, 指向需要复制数据的开始位置. stop变量也是偏移. 每次循环只处理一页. 当开始位置大于当前页的起始位置, 说明是第一页, 需要从开始位置而不是页开头进行复制. 否则就从开始位置复制. 当结束位置减去页起始位置, 小于页的大小的时候, 就说明是最后一页, 需要复制到结束位置为止, 而不是页结束位置.</p>
<h4 id="memoryset">MemorySet</h4>
<p>MemorySet 就是一个进程的所有内存空间管理的信息了. 内部包含Mapping, 负责管理页表, 用一个数组保存PageTableTracker(自己管理页表占用的物理页面), 并且另外保存页目录表. 包含segment数组, 内含每个映射, 和allocated_pairs数组, 保存虚拟页号到物理页智能指针(FrameTracker)的二元组, 拿着分配的物理页. 简而言之, MemorySet包含1页表2映射3物理页</p>
<p>添加新的映射的时候, 一方面要添加到页表里去, 一方面要加入映射vec保存, 如果申请了物理页要放到物理页vec中. 还检查是否和当前内存空间重叠.</p>
<p>由于内核换了位置(使用了虚拟地址), 需要在memory/config中加入MMIO 设备段内存区域起始地址: DEVICE_START_ADDRESS, 和DEVICE_END_ADDRESS, 另外还要将kernel_end_address 改成虚拟地址, config里的部分高位地址都要改改. (MMIO表示memory mapped io. 访问这里的地址就是直接与外设交互)</p>
<h2 id="lab4线程与调度">lab4线程与调度</h2>
<p>这个lab工作量非常大.</p>
<h3 id="总览">总览</h3>
<p>ucore中把初始化的执行包装成idleproc, 调用创建内核线程的函数创建init_main线程. 不过idleproc除了初始化外没有执行任何实质性的任务, 不存在也没有关系. 我们在rcore-tutorial中则直接切换到新来的线程. 而且切换后甚至原本我们使用的栈 bootstack也可以被回收.</p>
<p>当前的内核由于只用一个单核cpu, 只有一个内核栈, 并且不支持中断的嵌套. 而且现在中断的时候无论是内核态还是用户态都会交换sp和sscratch, 这就导致如果嵌套会导致交换两次出现问题. 需要改进为用户态切换栈, 内核态不切换栈才能为支持嵌套中断打基础.</p>
<p>进程和线程辨析: 线程是运行和调度的单位. 进程则包含了地址空间, 同一个进程的不同线程的地址空间是共享的.(意味着高位地址处会映射多块栈给不同的线程) 新建线程和Context都需要传入process结构体</p>
<p>切换则直接通过保存当前中断栈上的Context, 把下一个要执行的线程的Context放到栈顶实现.</p>
<h3 id="代码变化梳理-1">代码变化梳理</h3>
<ol type="1">
<li>interrupt/context.rs 完善之前的Context实现. Context结构体不变, 为Context实现了Default, 使用全零作为Default. 实现了获取/设置 栈指针/返回地址的四个简单函数. 实现了按照调用规则把参数写入Context内对应寄存器的函数, 和传入函数地址, 参数, process结构体新建Context的函数.</li>
<li>新建process文件夹作为mod</li>
<li>增加全局Processor用到的Lock, 原本使用的是unsafeWrapper, 在algorithm目录内.
<ol type="1">
<li>config.rs 包含了每个线程的运行栈大小, 和共用的内核栈大小, 目前都是512K</li>
<li>process.rs process结构体当前只有is_user标志位和memory_set内存空间. 有三个函数, 新建内核进程的new_kernel, 从elf创建进程的from_elf函数(之后的lab才会添加), 映射新的虚拟地址的alloc_page_range函数(类似mmap)</li>
<li>kernel_stack.rs 内核栈也就是作为一个大小为KERNEL_STACK_SIZE的u8数组. 此外实现了push_context函数, 能在栈顶减去Context大小的位置强转为Context指针, 然后赋值写进去, 最后把这个指针返回. 同时暴露出全局变量作为共用的全局内核栈.</li>
<li>thread.rs Thread结构体包含id, 栈(虚拟地址range), 所属进程(arc+读写锁包装的Process结构体), 和inner(用一个mutex包装一些可变数据结构). inner包含context和是否进入休眠的sleeping标志. 实现了Hash Eq这两个trait, Debug打印的trait. prepare函数用于准备执行该线程, 会激活页表, 清空并返回Context, park函数会暂停线程, 保存传入的Context. 新建线程的new函数需要传入Process, 要执行的entry_point, 和参数, 该函数会新分配一段空间(alloc_page_range)作为栈, 并构建新的Context, 最后打包新建thread并返回</li>
<li>processor.rs 包装调度器算法, 包装进程状态转移的操作.</li>
</ol></li>
<li>增加新的调度算法: 使用hrrn高响应比优先的调度算法, 放到process文件夹内. hrrnThread结构体对线程再次包装, 增加birth_time和service_count两个字段. 调度结构体HrrnScheduler则包含linkedList保存的hrrnThread和currenttime的二元组.</li>
<li>修改interrupt.asm支持切换线程, 加入交换sscratch的代码, 修改保存sp为保存sscratch. 恢复时保存弹出Context之后的栈到sscratch. 把a1放到sp使得<code>__restore</code>有返回值和参数这两种新的调用方法, 从而执行不同的线程.</li>
<li>修改interrupt_handler (init函数里面的增加各种中断使能的操作先不做, 后面的lab需要键盘输入的时候再加上), 修改时钟中断处, tick之后调用保存当前进程和准备下一个进程的函数, timer模块不变.</li>
<li>在interrupt/mod.rs中增加一个wait_for_interrupt函数. 给processor.rs中函数调用</li>
<li>修改timer模块init, 删除<code>sstatus::set_sie();</code> 这样main函数就不开中断, 执行内核线程的时候再接受中断</li>
<li>修改main.rs启动线程 main函数首先对各种东西进行初始化, 然后对线程的实现进行测试.</li>
</ol>
<h3 id="实现细节-1">实现细节</h3>
<h4 id="interruptcontext.rs">interrupt/context.rs</h4>
<p>这里新建的时候Context中返回值寄存器设置为-1, 如果执行的函数返回了, 就会报错. 之后新版的代码似乎修改了这里, 能正常返回.</p>
<h4 id="processprocess.rs">process/process.rs</h4>
<p>process结构体也算是MemorySet的封装了, 新建的时候会新建MemorySet, 函数也是调用MemorySet的接口.</p>
<p>alloc_page_range函数类似于mmap吧, 基于memory_set提供的接口操作, 传入一个size, 返回分配好的地址范围. 首先把size向上取整到页倍数, 再用while循环从0x100_0000开始不断步进查找可用内存空间(memory_set的overlap_with), 可用则调用memory_set.add_segment增加映射.</p>
<h4 id="kernel_stack.rs">kernel_stack.rs</h4>
<p>因为线程都有自己的栈映射在低地址区了, 函数调用关系的维护不靠内核栈, 内核栈只处理中断, 而且中断不会嵌套. 如果中断不嵌套, 那么Context总是在公用内核栈最顶上. 因此切换内核线程前可直接将Context放到栈顶上假装是正常的中断返回.</p>
<h4 id="thread.rs">thread.rs</h4>
<p>prepare函数, 1激活了新线程的页表, 2把Context放到了公共内核栈的栈顶. 切换线程的时候都是这样假装是中断返回. 此时大概调用了park函数保存好了中断进入时那个线程的Context.</p>
<p>重点关注新建线程的函数. 1. 新建线程的时候用的栈, 是新映射分配的!! 2. 新建的Context, 在切换的过程中还不会打开中断, 直到sret的时候中断才会打开. 3. 是否是用户线程取决于Process的is_user. 4. 返回的时候, is_sleeping是false. 这意味着一创建就开始执行? 不, 这只说明不是放到sleeping的队列而是放到scheduler的队列里</p>
<h4 id="processor.rs">processor.rs</h4>
<p>processor 主要是包装一下进程的状态转换操作, 调度靠每次prepare_next_thread中询问调度算法的操作, 主要靠timer_interrupt的时候的park+prepare组合拳. 当线程出现问题调用fault函数的时候, 就会调用kill/prepare组合拳</p>
<p>在这样单核的环境, 确实可以说调度器是局部于处理器的.</p>
<p>线程的组织上, 使用了hashbrown这个crate保存sleeping的thread, 需要调度的线程让调度算法去用自己的数据结构保存.</p>
<p>add thread会检查是否当前线程为None, 是则放入. 主要还是加入scheduler. 只有刚启动的时候, 和kill线程的时候会take当前的Option-thread 为none</p>
<p>确实, __restore作为函数调用只出现在processor的run里面, run函数只出现在rust_main里面. 只有刚开始的时候会刻意去调用__restore 毕竟,初始化的时候并不是调用的interrupt_handler, 不会返回到__restore. 而且使用的是boot_stack</p>
<p>执行的函数组合可以为 parl/kill [sleep] prepare_next_thread</p>
<h4 id="interrupt.rs">interrupt.rs</h4>
<p>外部中断如果是键盘输入, 就会把字符push到STDIN里(fs/stdin.rs)TODO</p>
<h4 id="unsafewrapper">unsafeWrapper</h4>
<p>unsafe包装后能增加多少灵活性? 这里的unsafe一方面实现了&amp;self 转mut, 使得可以同时持有多个可变借用. 并且实现了(标记了)sync Trait, 使得可以多线程共享.</p>
<p>static unsafe wrapper 还增加了Phantom data成员, 表明该结构体确实拥有T类型的值的所有权, 让wrapper被drop的时候也能drop T.</p>
<h4 id="hrrn_scheduler.rs">hrrn_scheduler.rs</h4>
<p>alloc::collections::LinkedList组织内部线程 对线程再增加了一层包装HrrnThread, 增加相关数据结构. 真正关键的只是一个.max_by()</p>
<h4 id="interrupt.asm">interrupt.asm</h4>
<p>原来是直接把sp保存不切换栈, 现在是先交换sscratch再保存, 而且保存的时候是保存的原来的sp, 所以恢复的时候直接正常恢复就好. 只要把当前的栈放好到sscratch就行.</p>
<p>无论如何, 发生了中断就交换栈为sscratch. sscratch的值可能是什么?? 如果是单线程不嵌套中断的话, 一定是公共栈顶上?? 恐怕是的</p>
<p>riscv调用约定中, a0, a1既是第一个参数, 又是返回地址. 这设计强!! <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    mv      sp, a0  # 加入这一行</span><br></pre></td></tr></table></figure> 这样一方面可以调用__restore(context), 一方面也可以让interrupt_handler返回context指针. 也就是中断返回的时候, 如果不切换进程, 就返回当前的进程的context, 否则返回切换到的进程的context. 其次, 把第一个参数作为sp, 而sp不仅是当前Context的位置, 还是之后保存到sscratch的位置!!! 因此这个参数/返回值一定要放在作为栈的内存顶上</p>
<h4 id="interrupthandler.rs">interrupt/handler.rs</h4>
<p>这里打开了一些神奇的中断. <code>sie::set_sext();</code>这个应该只是使能sie寄存器的某个中断, 中断的总开关还是没有打开的. 在某些特殊地址写入数字就能在OpenSBI中打开中断?? 为什么??</p>
<p>handle_interrupt函数中, 每个单独的处理函数确实应该返回应该Result类型, 是错误则调用fault.</p>
<p>fault函数现在出现异常的时候会杀死当前的线程了, 传入的参数也变了 最重要的当然还是timer的时候调度一下</p>
<h4 id="lock.rs">lock.rs</h4>
<p>为Mutex增加关中断的功能得到Lock类型. 则当获取其中内容的时候, 既关+保存了中断, 又独占了资源.</p>
<p>具体实现上, 上锁是在get函数中, 释放是在Drop的trait中.</p>
<p>同时实现了deref和deref mut, 可作为被包裹对象的智能指针使用.</p>
<p>另外实现了一个不上锁不关中断, 直接获得内部对象的unsafe_get函数, 用于PROCESSOR::run()的时候因为不会返回, 导致不会调用对应的析构函数</p>
<h3 id="线程的结束">线程的结束</h3>
<p>目前, 内核线程的结束是靠设置自己线程的isDead变量, 然后触发中断的时候检查时结束的. 也就是说设置了这个变量后即使不使用ebreak, 用其他方式触发中断也会被结束.</p>
<h3 id="线程进程的保存与组织">线程/进程的保存与组织</h3>
<p>线程的组织上, 使用了hashbrown这个crate保存sleeping的thread, 需要调度的线程让调度算法去用自己的数据结构保存.</p>
<p>Arc RwLock包着进程, 创建新线程的时候会把Arc RwLock-进程的所有权要过来, 用clone可以多处持有. 似乎没有单独组织进程的地方, 父进程子进程之类的关系链接也似乎没有</p>
<h2 id="lab5-设备驱动与文件系统">lab5 设备驱动与文件系统</h2>
<h3 id="综述">综述</h3>
<ol type="1">
<li>提供对ELF文件用户程序的解析</li>
<li>提供对磁盘映像的支持</li>
<li>实现系统调用支持</li>
<li>支持文件描述符</li>
</ol>
<h3 id="相关修改">相关修改</h3>
<ol start="0" type="1">
<li>entry.asm 增加映射低位页表</li>
<li>main函数增加参数, 调用drivers的初始化函数</li>
<li>新建drivers文件夹, 在mod.rs中增加init函数, 调用设备树子模块的init函数</li>
<li>drivers/device_tree.rs 增加对device_tree这个库的依赖. init函数调用dtb遍历库, walk函数负责遍历生成的树.</li>
<li>修改makefile, 增加qemu的启动参数 增加TEST_IMG变量指向之后的磁盘镜像</li>
<li>增加drivers/bus文件夹并增加子模块virtio_mmio.</li>
</ol>
<h4 id="entry.asm-1">entry.asm</h4>
<p>这里没想到增加了新的页表. 花了我差不多一个小时的时间去debug 当parse dtb, 得到磁盘的Header的时候, 这个header的位置在0x1000_8000, 位于低地址, 而我们此时还处于初始化的状态, 映射还是巨页映射, 只映射了0x8000 0000开头的1GB, (1GB是0x4000 0000). 更加恐怖的是, 此时的sscratch都没有值, 中断都无法正常进行. 当前的设计是中断一定切换栈, 每次中断的时候都是先交换sscratch和sp, 然后保存真正的原来的sp到栈上. 离开的时候先把sp弹出后的位置放到sscratch. 而第一次放入sscratch就是运行线程时假装中断返回的时候. 因此, 我在debug的时候, 第一次页访问异常, 进入中断的时候, 从sscratch中取来了(似乎是-1)未知的值, 作为内核栈放到sp, 然后在保存第一个寄存器的时候发生了第二次页访问异常. 这时又把sscratch和sp交换, 得到了正常的sp值, 反而正常处理了, 但是报错的地址好像是0xffff_ffff_ffff_ffec. 我在main函数加入了把kernel stack放到sscratch的汇编才正常得到了中断发生错误的地址.</p>
<h4 id="drivers模块">drivers模块</h4>
<p>driver模块目前主要负责文件系统的driver. 对外暴露的接口是driver模块中的driver trait, 和DRIVERS这个组织各种驱动的数据结构.</p>
<p>模块的初始化函数在mod.rs中, 参数传入dtb地址, 负责调用解析设备树的device_tree::init, device_tree的walk函数则一边遍历, 一边判断是不是想要的设备, 这里单指对应磁盘的块设备, 找到则把这个节点传给对应的总线协议驱动程序, 这里是bus/virtio_mmio. 本次实验中找到块设备的节点后, 把节点里reg字段拿出, 转换为virtio_drivers(库)::VirtIOHeader类型, 就传给驱动程序的包装virtio_blk, virtio_blk::VirtIOBlkDriver内部包装的是mutex包装的virtio_drivers(库)::VirtIOBlk, 对外实现了driver的trait.</p>
<p>之后在fs中才会用到BlockDevice, 它包装driver, 实现rcore_fs的BlockDevice trait从而传入给SimpleFileSystem::open函数</p>
<p>层次关系: virtio_drivers(库)::VirtIOBlk --包装--&gt; VirtIOBlkDriver(实现Driver) --包装--&gt; BlockDevice(实现rcore_fs的BlockDevice)</p>
<h4 id="driver.rs">driver.rs</h4>
<p>这个模块包含了驱动接口driver trait, 描述驱动类型的DeviceType, 和lazy_static的DRIVERS.</p>
<p>Driver 这个trait, 使用时根据device_type返回的DeviceType, 来调用对应的方法, 现在这个trait中只有块设备相关的方法, 提供了用unimplemented宏表明没有实现这个方法的默认实现. 实现新的设备驱动的时候, 只需要加入新的方法即可.</p>
<p>DRIVERS保存所有驱动的数据结构, 方便获取驱动. 驱动是dyn Driver类型, 首先用Arc实现共享, 再通过Vec保存, 再加上读写锁保证多线程安全.</p>
<h4 id="device_tree.rs">device_tree.rs</h4>
<p>device tree blob 确实是个标准. 其中头部的字段其实很多, 包括了dtb的版本等等. 我们现在只读取了前两个字段. 第二个字段size确实是包含整个dtb的大小的, 包括头部. https://www.devicetree.org/specifications/</p>
<p>这里init函数首先校验头部, 得到size, 再把整个dtb作为u8数组传入DeviceTree的crate中, 并且让遍历的walk函数递归遍历. 而walk函数则只是搜索compatiable字段为virtio,mmio的节点, 把节点传入virtio_probe进行初始化</p>
<h4 id="busvirtio_mmio.rs">bus/virtio_mmio.rs</h4>
<p>将传入的dtb节点的reg字段转为VirtIOHeader传入驱动程序进行初始化.</p>
<p>这里会遇到不少verify不对的设备, 因此如果verify函数调用失败或者没有reg字段就直接返回. 这里verify的时候就会访问1000_xxxx开头的低地址.</p>
<p>此外, 暴露了virtio_dma_dealloc, virtio_phys_to_virt, virtio_virt_to_phys这三个extern "C"且no_mangle的函数. 而且没有在我们代码中其他地方被调用. 这说明是库函数在C语言中或者汇编中调用了这两个函数. 根据名字看可能是virtio库.</p>
<h4 id="block模块和-blockvirtio_blk.rs">block模块和 block/virtio_blk.rs</h4>
<p>block模块的mod.rs里提供了对接驱动与文件系统的VirtIOBlkDriver包装. 而模块内部则是保存的块设备的Driver实现.</p>
<p>BlockDevice的实现主要是将Driver的返回bool值的read_block/write_block 函数转换成返回Result&lt;()&gt;的read_at/write_at函数, 另外实现假的sync函数</p>
<p>VirtIOBlkDriver的实现就是调用内部的Driver的read_block/write_block函数, 把返回的Result再用is_ok转成bool.</p>
<p>VirtIOBlkDriver则需要实现read_block/write_block的Driver接口, 另外给解析Node的virtio_mmio.rs:virtio_probe函数一个创建设备的add_driver函数. add_driver函数把header传给VirtIOBlk::new得到包装的内部驱动, 再把驱动包装上刚刚实现的VirtIOBlkDriver加入DRIVERS列表.</p>
<h3 id="fs模块">fs模块</h3>
<p>模块的mod.rs 提供了lazy_static的全局变量ROOT_INODE, 初始化的时候获取第一个Block类型的driver, 用BlockDevice包装后传入SimpleFileSystem::open()函数, 返回值赋给ROOT_INODE. 也许是SimpleFileSystem实现了对INode的deref, 在ROOT_INODE上可以调用到inode_ext拓展INode实现的方法</p>
<p>还有init函数, 负责作为测试, main函数初始化的时候使用ls方法测试我们文件系统的功能.</p>
<h4 id="inode_ext.rs">inode_ext.rs</h4>
<p>impl INodeExt for dyn INode 通过这种方法为已有的Inode类型增加功能. 额外实现了 ls这个直接打印而不返回值的函数, 和readall函数, 把所有内容读到<code>Vec&lt;u8&gt;</code>并返回.</p>
<h3 id="elf相关代码">elf相关代码</h3>
<p>ELF文件也可以看作是一个地址空间. 因为它定义了各个段的映射关系. MemorySet中增加根据ELF文件创建的from_elf函数, 它遍历elf文件的每个段, 根据大小和权限映射每个段.</p>
<p>首先在program_header中对每个为load类型的段, 读取开始地址和大小和数据和权限之后进行映射</p>
<p>process中也加入from_elf函数, 主要是调用MemorySet中的from_elf函数.</p>
<h3 id="sfs文件系统中的指向关系">sfs文件系统中的指向关系</h3>
<p>文件夹inode -&gt; 文件entry -&gt; 文件inode -&gt; 文件数据</p>
<h2 id="lab6-用户程序-系统调用-文件描述符">lab6 用户程序, 系统调用, 文件描述符</h2>
<h3 id="步骤">步骤</h3>
<ol type="1">
<li>完全构建新的crate作为user程序的框架, 这里也要新建Makefile文件, 并且可以单独build</li>
<li>在外面新建makefile文件, 依次make两个子目录</li>
<li>中断处理中, 初始化时开启外部中断, 用户态的ecall异常时调用kernel模块的syscall_handler, 增加外部中断处理键盘输入</li>
<li>为线程增加打开的文件descriptor数组, 初始化创建的时候就放入STDIN, STDOUT.</li>
<li>fs中增加stdin和stdout全局变量</li>
<li>增加mod kernel
<ol type="1">
<li>condvar.rs 利用线程的睡眠实现条件变量</li>
<li>syscall.rs 系统调用的总入口.</li>
<li>process.rs 处理线程退出的系统调用</li>
<li>fs.rs 处理文件读取相关的系统调用</li>
</ol></li>
</ol>
<h3 id="用户进程">用户进程</h3>
<p>类似于自己做一些rust标准库的事情. 首先是实现了ecall的包装,从而实现了sys_read, sys_write, sys_exit. 利用sys_write实现了print, println宏. 实现了对用户程序的输入输出的支持.</p>
<p>hello_world主要使用了输出. nodebook可以把输入的字符回显.</p>
<h4 id="fsstdout.rs-stdin.rs">fs/stdout.rs stdin.rs</h4>
<p>让标准输入和输出实现和文件一样的接口(INode)进行读写.</p>
<p>stdout没想到就是一个空结构体 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br></pre></td></tr></table></figure> 然后直接实现INode的方法, read和poll都返回不支持的错误, write不允许offset为非0.</p>
<p>标准输入stdin同理, 只允许offset为0, buf中没有值则等待一次条件变量, 否则进入读过程, 要么是stdin的buffer空了, 要么是buf不够长, 返回.</p>
<h4 id="系统调用的实现">系统调用的实现</h4>
<p>syscall_handler函数根据传入的系统调用号调用各个子函数, 重要的是子函数的返回值还代表了对当前进程的处理方式.</p>
<p>write: 根据fd在进程的descriptor内获取inode, 调用inode的write_at, 直接返回Proceed和返回值.</p>
<p>read: 调用inode的read_at, 然后根据返回值包装一下. 和write不同的地方在于, 如果返回值为0则park当前线程(阻塞), 此时已经在read_at内部等待了condvar, 调用等待时会把当前线程放入等待队列并sleep_current_thread. 之后syscall_handler在处理返回值的时候发现是Park类型会再切换线程. 直到之后external interrupt键盘输入-&gt;push到stdin中-&gt;条件变量notify-&gt;进程恢复调度.</p>
<h4 id="condvar">condvar</h4>
<p>这里的条件变量利用的是线程的休眠, 等待条件变量时进入条件变量内部的队列, 线程休眠. 当notify时则唤醒进程. 只在fs/stdin.rs中被实例化并使用.</p>
<p>如果有多个线程同时等待标准输入? 因为现在的线程的标准输入标准输出都是公用的, 没有不同的tty终端的概念, 如果等待输入的线程去sleep了, 那新执行的线程如果还想读取输入的话, 那就会产生冲突了, 两个线程读取一个标准输入. 如果引入了不同的终端的概念, 能有多个标准输入相互区分开就不会冲突. 目前看来还是阻塞, 另外加入新的把线程放到后台的按键, 这样比较好.</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>rcore</tag>
      </tags>
  </entry>
  <entry>
    <title>设置最新版本的windows10能够访问的samba服务器</title>
    <url>/2020/samba/</url>
    <content><![CDATA[<h1 id="设置最新版本的windows10能够访问的samba服务器">设置最新版本的windows10能够访问的samba服务器</h1>
<p>目标：需要有只读的公共访问和可读可写的非公共访问</p>
<p>注意的地方是, 第一次访问可能会询问用户名密码, 不代表guest配置失败, 乱输用户名即可通过<code>map to guest = bad user</code> 作为guest。坑惨我了</p>
<span id="more"></span>
<p>现在回头看，总感觉微软只关注了那种公司内使用了域控服务器管理了大量主机，从而可以相互认证的情况，而不关心我们这种笔记本用户的“孤岛”情况，导致<code>"默认"</code>并不是无密码，而是当前用户的账号密码。无密码访问挺不容易的。</p>
<h2 id="关键配置1-加密和签名">关键配置1 加密和签名</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	server signing = mandatory</span><br><span class="line">#	smb encrypt = mandatory</span><br></pre></td></tr></table></figure>
<p>查看日志发现, 新版本的win10(还是samba服务器??)对没有加密也没有签名的连接会拒绝. 所以需要这两个选项.</p>
<p>加密必须要用户名和密码, 因为加密的会话密钥就是和用户名关联的. 因此为了guest用户, 需要注释掉加密的选项.</p>
<p>来自<a href="https://serverfault.com/questions/874423/how-to-enable-samba-encryption-and-do-not-require-user-authentication">How to enable SAMBA encryption and do not require user authentication</a></p>
<h2 id="关键配置2">关键配置2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#	min protocol = SMB2</span><br></pre></td></tr></table></figure>
<p>自从win10开始, 默认使用的就是SMB3_11了, 在 <code>启用或关闭windows功能</code> 里开启SMB1/CIFS, 访问时就可能会使用SMB2. 这里调试的时候可以考虑强制改成SMB3. 发现关键问题之后为了兼容性注释掉了</p>
<h2 id="关键配置3">关键配置3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guest account = guest</span><br><span class="line">null passwords = yes</span><br></pre></td></tr></table></figure>
<p>默认是<code>guest account = nobody</code>. #TODO 第二个参数 <code>null passwords</code> 不加上, 使用空密码登录的时候就会被拒绝.</p>
<h2 id="关键配置4-ntlm-auth">关键配置4 ntlm auth</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntlm auth = ntlmv1-permitted</span><br><span class="line">lanman auth = yes</span><br><span class="line">raw NTLMv2 auth = yes</span><br></pre></td></tr></table></figure>
<p>win10可能会使用ntlmv1, 而经过永恒之蓝事件之后samba默认只接受ntlmv2了. 关键的只是第一条, 后面的两条是逛的时候发现的, 加了可以增加兼容性.</p>
<p><a href="https://bgstack15.wordpress.com/2017/10/01/samba-and-ntlm-for-windows-clients/">Samba and ntlm for Windows clients</a></p>
<p><a href="https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html#NTLMAUTH">samba config ntlmauth</a></p>
<h2 id="关键配置5-passdb-backend">关键配置5 passdb backend</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passdb backend = smbpasswd:/etc/samba/smbpasswd</span><br><span class="line">smb passwd file = /etc/samba/smbpasswd</span><br></pre></td></tr></table></figure>
<p>新版本默认使用的不是smbpasswd, 默认的数据库位置更不是 <code>/etc/samba/smbpasswd</code>. 新版本似乎用的是 <code>pdbedit</code>?</p>
<p>指定数据库文件位置似乎是用第一行的方式了, 第二行似乎没有效果了?</p>
<h2 id="关键配置6-force-user">关键配置6 force user</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">force user = pi</span><br></pre></td></tr></table></figure>
<p>强制用户了之后上传的文件的所有者就都是一样的了</p>
<h2 id="总体配置">总体配置:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">    map to guest = Bad User</span><br><span class="line">	server signing = mandatory</span><br><span class="line">#	smb encrypt = mandatory</span><br><span class="line">#	min protocol = SMB2</span><br><span class="line">	passdb backend = smbpasswd:/etc/samba/smbpasswd</span><br><span class="line">	smb passwd file = /etc/samba/smbpasswd</span><br><span class="line">	guest account = guest</span><br><span class="line">	null passwords = yes</span><br><span class="line">	security=user</span><br><span class="line">	ntlm auth = ntlmv1-permitted</span><br><span class="line">	lanman auth = yes</span><br><span class="line">	raw NTLMv2 auth = yes</span><br><span class="line"></span><br><span class="line">[ro]</span><br><span class="line">        # This share allows anonymous (guest) access</span><br><span class="line">        # without authentication!</span><br><span class="line">        path = /home/pi/</span><br><span class="line">#	force user = pi</span><br><span class="line">        read only = yes</span><br><span class="line">        guest ok = yes</span><br><span class="line">#        guest only = yes</span><br><span class="line"></span><br><span class="line">[rw]</span><br><span class="line">	path = /home/pi/</span><br><span class="line">	read only = no</span><br><span class="line">	valid users = pi</span><br><span class="line">	force user = pi</span><br></pre></td></tr></table></figure>
<h2 id="debug方法">debug方法</h2>
<p>windows 清除登录密码首先要凭据管理器删除 接着我任务管理器关闭explorer再启动, 没有用, 只有重启</p>
<p>debug samba 的方法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service smbd stop</span><br><span class="line">sudo smbd -F -S -d=10</span><br></pre></td></tr></table></figure> 此时再连接, 就可以看到debug信息了. -d指定的loglevel从1到10. <code>-d=5</code>的时候的log就已经很多了, <code>-d=3</code> 的时候log不是很多.平时一般先使用 <code>-d=3</code></p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab1</title>
    <url>/2020/ucore%20lab1/</url>
    <content><![CDATA[<h1 id="ucore-lab1">ucore lab1</h1>
<p>上来先看看Intel 80386 Programmer's Reference Manual, 1987 (HTML)吧。 http://www.logix.cz/michal/doc/i386/</p>
<span id="more"></span>
<h2 id="makefile">makefile</h2>
<blockquote>
<p>https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_ref_ucore-resource.html</p>
</blockquote>
<p>跟我一起写makefile &gt; https://seisman.github.io/how-to-write-makefile/functions.html &gt; makefile这鬼东西真tm功能强，强得我什么都看不懂。原来在那个眼花缭乱的makefile里面全是各种各样的函数。。。。 但是实际上不需要全部读懂，稍微看看就好，这个不是重点，而且好像这个脚本比较通用。</p>
<blockquote>
<p>https://blog.csdn.net/u013484370/article/details/50638353 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># add files to packet: (#files, cc[, flags, packet, dir])</span><br><span class="line">#此模板，就是真正在makefile中用来编译所有的目表文件，并生成makefile规则的模板。</span><br><span class="line">define do_add_files_to_packet</span><br><span class="line">#__temp_packet__用来记录所有的临时目标文件。</span><br><span class="line">__temp_packet__ := $(call packetname,$(4))</span><br><span class="line">ifeq ($$(origin $$(__temp_packet__)),undefined)</span><br><span class="line">$$(__temp_packet__) :=</span><br><span class="line">endif</span><br><span class="line">__temp_objs__ := $(call toobj,$(1),$(5))</span><br><span class="line">$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(5))))</span><br><span class="line">$$(__temp_packet__) += $$(__temp_objs__)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>其他资料： &gt; How to make an Operating System &gt; https://samypesse.gitbook.io/how-to-create-an-operating-system/chapter-3 &gt; 别人的lab1实验报告: &gt; https://www.jianshu.com/p/2f95d38afa1d &gt; https://www.cnblogs.com/maruixin/p/3175894.html &gt;</p>
<h2 id="硬盘读取">硬盘读取</h2>
<blockquote>
<p>《读取磁盘：LBA方式》 https://www.cnblogs.com/mlzrq/p/10223060.html</p>
</blockquote>
<p>这个写的比那个gitbook实验指导书讲得好一点 &gt; LBA简介 &gt; 磁盘读取发展 &gt; &gt; IO操作读取硬盘的三种方式： &gt; &gt; chs方式 ：小于8G (8064MB) &gt; &gt; LBA28方式：小于137GB &gt; &gt; LBA48方式：小于144,000,000 GB &gt; &gt; LBA方式访问使用了data寄存器，LBA寄存器（总共3个），device寄存器，command寄存器来完成的。 &gt; &gt; LBA28和LBA48方式： &gt; LBA28方式使用28位来描述一个扇区地址，最大支持128GB的硬磁盘容量。 &gt; &gt; LBA28的寄存器 &gt; &gt;</p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 37%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>寄存器</th>
<th>端口</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>data寄存器</td>
<td>0x1F0 已经读取或写入的数据，大小为两个字节（16位数据)</td>
<td>每次读取1个word,反复循环，直到读完所有数据</td>
</tr>
<tr class="even">
<td>features寄存器</td>
<td>0x1F1</td>
<td>读取时的错误信息，写入时的额外参数</td>
</tr>
<tr class="odd">
<td>sector count寄存器</td>
<td>0x1F2</td>
<td>指定读取或写入的扇区数</td>
</tr>
<tr class="even">
<td>LBA low寄存器</td>
<td>0x1F3</td>
<td>lba地址的低8位</td>
</tr>
<tr class="odd">
<td>LBA mid寄存器</td>
<td>0x1F4</td>
<td>lba地址的中8位</td>
</tr>
<tr class="even">
<td>LBA high寄存器</td>
<td>0x1F5</td>
<td>lba地址的高8位</td>
</tr>
<tr class="odd">
<td>device寄存器</td>
<td>0x1F6</td>
<td>lba地址的前4位（占用device寄存器的低4位）<br />主盘值为0（占用device寄存器的第5位）<br />第6位值为1<br />LBA模式为1，CHS模式为0（占用device寄存器的第7位）<br />第8位值为1</td>
</tr>
<tr class="even">
<td>command寄存器</td>
<td>0x1F7</td>
<td>读取，写入的命令，返回磁盘状态。<br />1 读取扇区:0x20 写入扇区:0x30<br />磁盘识别:0xEC</td>
</tr>
</tbody>
</table>
<p>IDE通道1，读写0x1f0-0x1f7号端口 IDE通道2，读写0x170-0x17f号端口</p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Program header描述的是一个段在文件中的位置、大小以及它被放进内存后所在的位置和大小。 所以bootmain中的读取elf文件，需要把每一个段都按照指定的虚拟地址和size加载好。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line"></span><br><span class="line">    // is this a valid ELF?</span><br><span class="line">    if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    // load each program segment (ignores ph flags)</span><br><span class="line">    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call the entry point from the ELF header</span><br><span class="line">    // note: does not return</span><br><span class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br></pre></td></tr></table></figure> 但是为什么是ph-&gt;p_va &amp; 0xFFFFFF？ 去掉了前面一个字节。 答：应该不是因为硬盘的问题，可能是内存大小的限制 &gt; https://blog.csdn.net/u012418573/article/details/73823524 &gt; 2、链接地址VS加载地址 &gt; （1）链接地址：是虚拟地址，代码中的绝对跳转地址和全局变量的地址都依赖于链接地址，链接地址改变时，这些地址也会改变，但相对跳转不依赖与链接地址。 &gt; （2）加载地址：程序被加载到的物理地址 &gt; （3）关系：链接地址经过地址转换要等于物理地址（加载地址） &gt; （4）内核的加载地址：0x100000处，参加bootmain.c &gt; （5）内核的链接地址：0xf0100000处，但是我们没有那么大的内存，故：ELFHDR-&gt;e_entry&amp;0xFFFFFF</td>
</tr>
<tr class="even">
<td>另外，这个问题好像不简单啊： &gt; ucore Lab2 调试时断点无效分析 &gt; http://blog.sina.com.cn/s/blog_3dce1e7b0102x6t3.html</td>
</tr>
<tr class="odd">
<td>就是说，lab2的bootloader加载完成之后，会加载一个新的gdt段表，让地址多了一个KERNBASE(0xC0000000)。而lab1没有这个功能，就直接通过这样与一下来解决。</td>
</tr>
<tr class="even">
<td>## 实模式到保护模式的切换</td>
</tr>
<tr class="odd">
<td>问：16位到32位的切换是瞬间完成的吗？</td>
</tr>
<tr class="even">
<td>问：发现进入实模式之后的ljmp之后，cs自动变成8 答：代码段寄存器（CS）的内容不能由装载指令（如MOV）直接设置，而只能被那些会改变程序执行顺序的指令（如JMP、INT、CALL）间接地设置。 8代表序号为1的段描述符表。进入实模式之前就要设置好段描述符表。 &gt; 下面摘自《计算机启动流程分析--以JOS为例（从BIOS到刚进入boot loader）》 &gt; https://blog.csdn.net/old_memory/article/details/79572498</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(CR0_PE_ON是CR0设置实模式或保护模式的开关，这里打开，表明接下来的地址都是32位的虚拟地址（必须注意，这里由于是刚开始，所有的虚拟地址和物理地址等价），然而，系统是怎样真正进入32位寻址的呢？以下代码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"> </span><br><span class="line">  .code32                     # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br></pre></td></tr></table></figure> 它的作用仅仅是跳转到下一行，但是ljmp有副作用：\)</span>PROT_MODE_CSEG的值会被加载，boot.S文件开头的宏表明： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br></pre></td></tr></table></figure> 它的值是0x8，这个值被存入CS寄存器，它会与GDT一起影响地址翻译。</td>
</tr>
<tr class="even">
<td>摘录结束，另外在文件bootblock.asm中有 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">7c2d:	ea                   	.byte 0xea</span><br><span class="line">7c2e:	32 7c 08 00          	xor    0x0(%eax,%ecx,1),%bh</span><br></pre></td></tr></table></figure> 这说明反汇编失败了？所以ljmp实际上是32位才有的指令吧。 可是为什么在gdb里面却显示 0x7c2d &lt;seta20+25&gt;: ljmp $0xb866,$0x87c32 只是跳转到7c32，为什么有这么多一堆东西？ 严重怀疑在jmp之前还是十六位的代码。</td>
</tr>
<tr class="odd">
<td>另外这篇文章说得特别好啊，说出了内幕： &gt; https://blog.csdn.net/dog250/article/details/5303304 &gt; ljmp的含义是长跳，长跳主要就是重新加载寄存器，32位保护模式主要体现在段寄存器，具有可以参考段选择子和段描述符的概念，如果不用长跳的话，那么段寄存器不会重新加载，后面的取指结果仍然是老段寄存器中的值，当然保护模式不会生效了，Intel手册上有讲可见寄存器和不可见寄存器的篇章，可以看一下，其实实模式就是保护模式的一种权限全开放的特殊情况，就是说段寄存器左移相当于右边添加0，而这添加的0可以看做保护模式的RPL，RPL为0代表Intel的0环，当然是全权限了。 &gt; &gt; 不过Intel的实模式的概念实属不得已而为之，现在的意义已经不大了，从实模式启动然后跳转到保护模式纯粹是在绕圈子，没有实质的意义，商业上为了保护以前的投资不得不将技术做的没有意义的复杂...</td>
</tr>
</tbody>
</table>
<blockquote>
<p>【补充】保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14 个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。目前所谓的64TB（2^(14+32) =2^46 ）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。注：在ucore lab中只用到了GDT，没有用LDT。</p>
</blockquote>
<p>没想到说32位系统最多有4gb内存不是假的啊。。。换页还能换着用超出4gb的内存吗？</p>
<p>另外为什么是2^13次方？ 因为段寄存器占用了三个比特位用来干别的。参见 https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_1_protection_mode.html 这实验指导书这次摘录得特别好啊！</p>
<hr />
<h2 id="段描述符">段描述符</h2>
<p>问： 如果某个段描述符要求的权限级别是3，那么我通过加载段寄存器，index选择这个描述符，但是权限级是0，那这样不就让当前权限变成0了？ 答：对应的段因为权限是三，本来就没有对权限做限制。所以访问起来并没有什么区别。 但是如果再切换的话就会造成影响，使得能够切换到ring0的数据段。 难道是真正切换时，权限级不由自己加载的段寄存器的值确定，而是由选择出来的段描述符的权限级确定？</p>
<p>特权级和特权级转移 https://www.jianshu.com/p/377f473dd0a9</p>
<p>这段描述符的结构很重要。 <img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1_figs/image003.png" /> * 段基地址：规定线性地址空间中段的起始地址。在80386保护模式下，段基地址长32位。因为基地址长度与寻址地址的长度相同，所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不象实方式下规定的边界必须被16整除。 * 段界限：规定段的大小。在80386保护模式下，段界限用20位表示，而且段界限可以是以字节为单位或以4K字节为单位。 * 段属性：确定段的各种性质。: * 段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。 * 类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。 * 描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。 * 段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。图5-4显示了当存在位为0时，描述符的格式。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。 * 已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。</p>
<p>http://www.logix.cz/michal/doc/i386/chp06-03.htm#06-03-01 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Figure 6-1. Protection Fields of Segment Descriptors</span><br><span class="line">                           DATA SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+---------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     |  TYPE   |#################|</span><br><span class="line"> |###BASE 31..24###|G|B|0|V| 19..16  |P| DPL |         |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     |1|0|E|W|A|#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-+-+-+-+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|        SEGMENT LIMIT 15..0        | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                        EXECUTABLE SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+---------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     |  TYPE   |#################|</span><br><span class="line"> |###BASE 31..24###|G|D|0|V| 19..16  |P| DPL |         |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     |1|0|C|R|A|#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-+-+-+-+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|        SEGMENT LIMIT 15..0        | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                         SYSTEM SEGMENT DESCRIPTOR</span><br><span class="line"></span><br><span class="line">  31                23                15                7               0</span><br><span class="line"> +-----------------+-+-+-+-+---------+-+-----+-+-------+-----------------+</span><br><span class="line"> |#################|#|#|#|A| LIMIT   |#|     | |       |#################|</span><br><span class="line"> |###BASE 31..24###|G|X|0|V| 19..16  |P| DPL |0| TYPE  |###BASE 23..16###| 4</span><br><span class="line"> |#################|#|#|#|L|         |#|     | |       |#################|</span><br><span class="line"> |-----------------+-+-+-+-+---------+-+-----+-+-------+-----------------|</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> |########SEGMENT BASE 15..0#########|       SEGMENT LIMIT 15..0         | 0</span><br><span class="line"> |###################################|                                   |</span><br><span class="line"> +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line">        A   - ACCESSED                              E   - EXPAND-DOWN</span><br><span class="line">        AVL - AVAILABLE FOR PROGRAMMERS USE         G   - GRANULARITY</span><br><span class="line">        B   - BIG                                   P   - SEGMENT PRESENT</span><br><span class="line">        C   - CONFORMING                            R   - READABLE</span><br><span class="line">        D   - DEFAULT                               W   - WRITABLE</span><br><span class="line">        DPL - DESCRIPTOR PRIVILEGE LEVEL</span><br><span class="line"></span><br><span class="line">Table 6-1. System and Gate Descriptor Types</span><br><span class="line">Code      Type of Segment or Gate</span><br><span class="line"></span><br><span class="line">  0       -reserved</span><br><span class="line">  1       Available 286 TSS</span><br><span class="line">  2       LDT</span><br><span class="line">  3       Busy 286 TSS</span><br><span class="line">  4       Call Gate</span><br><span class="line">  5       Task Gate</span><br><span class="line">  6       286 Interrupt Gate</span><br><span class="line">  7       286 Trap Gate</span><br><span class="line">  8       -reserved</span><br><span class="line">  9       Available 386 TSS</span><br><span class="line">  A       -reserved</span><br><span class="line">  B       Busy 386 TSS</span><br><span class="line">  C       386 Call Gate</span><br><span class="line">  D       -reserved</span><br><span class="line">  E       386 Interrupt Gate</span><br><span class="line">  F       386 Trap Gate</span><br></pre></td></tr></table></figure></p>
<h2 id="idt的结构">IDT的结构</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Figure 9-1. IDT Register and Table</span><br><span class="line">                                              INTERRUPT DESCRIPTOR TABLE</span><br><span class="line">                                              +------+-----+-----+------+</span><br><span class="line">                                        +----&gt;|      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #N -|</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     +------+-----+-----+------+</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     *                         *</span><br><span class="line">                                        |     +------+-----+-----+------+</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #2 -|</span><br><span class="line">                                        |     |      |     |     |      |</span><br><span class="line">                                        |     |------+-----+-----+------|</span><br><span class="line">            IDT REGISTER                |     |      |     |     |      |</span><br><span class="line">                                        |     |- GATE FOR INTERRUPT #1 -|</span><br><span class="line">                    15            0     |     |      |     |     |      |</span><br><span class="line">                   +---------------+    |     |------+-----+-----+------|</span><br><span class="line">                   |   IDT LIMIT   |----+     |      |     |     |      |</span><br><span class="line">  +----------------+---------------|          |- GATE FOR INTERRUPT #0 -|</span><br><span class="line">  |            IDT BASE            |---------&gt;|      |     |     |      |</span><br><span class="line">  +--------------------------------+          +------+-----+-----+------+</span><br><span class="line">   31                             0</span><br></pre></td></tr></table></figure>
<p>这里的idt limit是idt的长度减1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Figure 9-3. 80306 IDT Gate Descriptors</span><br><span class="line">                                80386 TASK GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----------------+</span><br><span class="line">  |#############(NOT USED)############| P |DPL|0 0 1 0 1|###(NOT USED)####|4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----------------|</span><br><span class="line">  |             SELECTOR              |#############(NOT USED)############|0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                                80386 INTERRUPT GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----+-----------+</span><br><span class="line">  |           OFFSET 31..16           | P |DPL|0 1 1 1 0|0 0 0|(NOT USED) |4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----+-----------|</span><br><span class="line">  |             SELECTOR              |           OFFSET 15..0            |0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br><span class="line"></span><br><span class="line">                                80386 TRAP GATE</span><br><span class="line">   31                23                15                7                0</span><br><span class="line">  +-----------------+-----------------+---+---+---------+-----+-----------+</span><br><span class="line">  |          OFFSET 31..16            | P |DPL|0 1 1 1 1|0 0 0|(NOT USED) |4</span><br><span class="line">  |-----------------------------------+---+---+---------+-----+-----------|</span><br><span class="line">  |             SELECTOR              |           OFFSET 15..0            |0</span><br><span class="line">  +-----------------+-----------------+-----------------+-----------------+</span><br></pre></td></tr></table></figure>
<p>关于 Segment Present</p>
<blockquote>
<p>Segment-Present bit: If this bit is zero, the descriptor is not valid for use in address transformation; the processor will signal an exception when a selector for the descriptor is loaded into a segment register. Figure 5-4 shows the format of a descriptor when the present-bit is zero. The operating system is free to use the locations marked AVAILABLE. Operating systems that implement segment-based virtual memory clear the present bit in either of these cases:</p>
<p>When the linear space spanned by the segment is not mapped by the paging mechanism. When the segment is not present in memory.</p>
</blockquote>
<h2 id="tss-task-status-segment">TSS （Task Status Segment）</h2>
<p>没想到在看似平常的GDT下面，居然出现了一个全新的没见过的概念。。。 https://www.cnblogs.com/yasmi/articles/5198138.html</p>
<p>首先GDT里有TSS Descriptor，用来保存当前指令地址。 另外，在IDT里有Task Gate Discriptor，相当于是TSS的一个指针，不过在权限上可以单独设置 Task Gate Discriptor在LDT里居然也有！ http://www.logix.cz/michal/doc/i386/chp07-04.htm</p>
<ol type="1">
<li>加载task register ltr 指令使用提供的 selector 在 GDT / LDT 里索引查找到 TSS descriptor 后，加载到 TR 寄存器里。初始的 TSS descriptor 必须设为 available 状态，否则不能加载到 TR。processor 加载 TSS descriptor 后，将 TSS descriptor 置为 busy 状态。</li>
<li>任务切换 当前进程要切换另一个进程时，可以使用 2 种 selector 进行：使用 TSS selector 以及 Task gate selector（任务门符）。 当前进程的执行环境被保存在当前进程的 TSS segment 中。 发生了 TSS selector 切换。新的 TSS selector 被加载到 TR.selector，而新的 TSS descriptor 也被加载到 TR 寄存的隐藏部分。 processor 从当前的 TSS segment 取出新进程的执行环境。经过相关的 selector &amp; descriptor 的常规检查以及权限检查。通过之后才真正加载。 将新进程的 TSS descriptor 置为 busy 状态。使得新进程不能重入。</li>
</ol>
<blockquote>
<p>https://www.xuebuyuan.com/737019.html 我们可以看到，只有用CALL指令+调用门方式跳转，且目标代码段是非一致代码段时，才会引起CPL的变化，即引起代码执行特权级的跃迁，这是目前得知的改变执行特权级的唯一办法</p>
</blockquote>
<p>mark 关于push esp pop esp https://blog.csdn.net/particleHorizon/article/details/78722683</p>
<h2 id="中断门调用过程">中断门调用过程</h2>
<p>最早设置好idt表，通过汇编指令lidt。里面保存了表的大小和起始地址，地址指向的表的每一项都有地址，段寄存器，特权级这三个属性。特权级限制了访问，而地址加上段寄存器的组合就指向了中断服务程序。 于是当发生中断的时候，cpu就会找到指定的地址调用。 调用前，会依次把一些重要的寄存器压栈。 (特权级切换时还有的ss, esp)eflags, cs, eip, error code。 然后就像call调用一样，跳转到指定的地方继续运行。 这里，一般的操作系统会继续保存上下文，以方便恢复一切结束中断。被打断的有当前的各种寄存器，还有栈。结束的时候就恢复自己保存的栈和寄存器再iret就可以了。 当不切换栈的时候是直接保存在当前栈上，反正之后会回来清理，中断的时候cpu忙，旧的栈也没有人来用。 切换栈的时候，系统是会从tss段取出esp吗？保存的栈帧是在系统栈还是在用户栈？？</p>
<p>https://www.cnblogs.com/chaozhu/p/6283495.html 1. 在发生中断、异常时前，程序运行在用户态，ESP指向的是Interrupted Procedure's Stack，即用户栈。 1. 运行下一条指令前，检测到中断（x86不会在指令执行没有指向完期间响应中断）。从TSS中取出esp0字段（esp0代表的是内核栈指针，特权级0）赋给ESP，所以此时ESP指向了Handler's Stack，即内核栈。 1. cpu控制单元将用户堆栈指针（TSS中的ss，sp字段，这代表的是用户栈指针）压入栈，ESP已经指向内核栈，所以入栈指的的是入内核栈。 1. cpu控制单元依次压入EFLAGS、CS、EIP、Error Code（如果有的话）。此时内核栈指针ESP位置见图4中的ESP After Transfer to Handler。</p>
<p>https://www.xuebuyuan.com/915513.html 也是讲堆栈切换的</p>
<p>为什么当前的tss保存的是内核的东西？虽然这和TSS的用法不符，但是应该没错吧。 为什么垃圾intel 80386 程序员手册没有在中断一节说清楚？是我瞎吗</p>
<p>那么当一个os初始化完成之后，它第一个用户态程序是怎么切换权限级的？直接加载一个更低的权限？ 当系统解析ELF文件的时候，就要安排好各种数据，分段（有页吗？）设置好权限（读写执行）和权限级。然后跳转过去吗？这样不就直接转换</p>
<h2 id="a和8253-timer">8295A和8253 timer</h2>
<p>详解8259A https://blog.csdn.net/longintchar/article/details/79439466 https://baike.baidu.com/item/8253%E8%8A%AF%E7%89%87/3699917</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows权限与UAC</title>
    <url>/2020/windows%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="windows权限与uac">Windows权限与UAC</h1>
<p>这篇文章是课程中被逼无奈（被一门2学分的课的老师疯狂压榨时间）调研Windows相关的攻击，UAC绕过中总结的一些笔记</p>
<span id="more"></span>
<h2 id="综述">综述</h2>
<p>在windows中有两种访问控制，首先是强制完整性控制，它蕴含在SACL中。其次是自主访问控制DACL。</p>
<p>SACL原本的用途是类似自主访问控制一样自主控制系统日志，但完整性控制加入到了它的范围内。</p>
<p>UAC提权不仅完整性从medium到了high，而且多了特权。特权是另外的资源。</p>
<p>UAC绕过的例外方法：提升的COM名字对象，UIAccess</p>
<p>从admin到system的方法：令牌窃取。</p>
<h3 id="强制完整性控制mic">强制完整性控制（MIC）</h3>
<p>windows 首先是自主访问控制, 只有很简单的强制访问控制, 在原本只是打印日志的SACL的完整性字段里. 实现的方式是"可上读, 可下写". 为了保证完整性, 只需要严格控制写权限. TODO: 能不能下读.</p>
<p>保护完整性的强制访问控制: 低级的不可以（发送消息）影响高级的程序。</p>
<p>与之对应的是保护机密性的强制访问控制：低级的可以发消息给高级程序，而高级程序无法发消息给低级程序（泄露机密。）</p>
<p>windows中的完整性等级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SeUntrustedMandatorySid</span><br><span class="line">SeLowMandatorySid</span><br><span class="line">SeMediumMandatorySid</span><br><span class="line">SeHighMandatorySid</span><br><span class="line">SeSystemMandatorySid</span><br></pre></td></tr></table></figure>
<p>主体的缺省完整性级别是SeUntrustedMandatorySid，而客体的缺省完整性级别是SeMediumMandatorySid</p>
<blockquote>
<p>进程完整性级别是为了保证不同标签的进程（TOKEN) 和对象（SACL)之间的访问安全 https://zh.wikipedia.org/wiki/%E5%BC%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6</p>
<p><a href="https://en.wikipedia.org/wiki/Security_Identifier">SID</a></p>
<p>可以看到标准用户和经过权限提升的UAC用户信息的差别。用户名项中组信息和sid均相同，区别就是UAC用户是经过权限提升的，最终体现在权限上的不同如下：</p>
<p>1.组信息项中主要是Integrity levels (IL)【进程完整性级别不同】。标准用户是Medium Mandatory Level，UAC用户是High Mandatory Level,它包括Untrust， Low， Medium， Hight， System等， 级别越低，权限也就越低。我们可以通过GetTokenInformation的TokenIntegrityLevel来进行查询。 2.体现在Privilege中的就是UAC用户拥有很多Privilege，比如最常用的SeDebugPrivilege 。 注释： 进程完整性级别是为了保证不同标签的进程（TOKEN) 和对象（SACL)之间的访问安全，如果当前进程的TOKEN 是Low Mandatory Level， 它就不能修改具有Medium Mandatory Level的对象，即使我们对象的DACL赋予完全读写的权限。当每个进程打开对象， 我们会进行SACL和DACL检查，这个检查通过核心态函数 SeAccessCheck . 只有当前进程TOKEN的　完整性标签　高于或者等于　对象的完整性标，　我们才会进一步进行 DACL 检查。如果完整性标签验证通不过。 即使DACL给予再高权限都无济于事。</p>
</blockquote>
<h3 id="dacl-自主访问控制列表">DACL 自主访问控制列表</h3>
<p>文件/注册表方面自然是还有自主访问控制. 进程没想到!!和文件一样的, 有安全描述符 主体是访问令牌. 每个进程都有一个基本令牌 (Primary Token)，可以被进程中的每个线程所共享, 后面线程可以获得其他令牌. 令牌里有用户sid, 组sid, 受限sid, 特权, 身份模拟级别, 完整度级别. 客体是对象: 文件/注册表/进程. 客体关联了安全描述符, 安全描述符包括所有者SID, 组SID, DACL, SACL(日志)</p>
<p>“属性” =&gt; “安全”, “权限”选项卡就是DACL，”审核”选项卡是SACL，“所有者”是Owner、Group。</p>
<p>每个DACL内有很多ACE, 访问控制表项, 可以接受也可以拒绝, 先找到的生效. 因此(有时?)一般拒绝的放在接受的前面.</p>
<p>impersonation 身份模拟 传输层, 被rpc使用的, 服务端可以使用客户端的令牌.</p>
<p>令牌里的权限有的没有enable, 要单独开启 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+0x000 Present          : Uint8B</span><br><span class="line">+0x008 Enabled          : Uint8B</span><br><span class="line">+0x010 EnabledByDefault : Uint8B</span><br></pre></td></tr></table></figure> 特权Privilege在访问某个具体的安全对象时并没有作用，Privilege是表示进程是否能够进行特定的系统操作，如关闭系统、修改系统时间、加载设备驱动等。</p>
<h3 id="uac">UAC</h3>
<p>当用户登录Windows时，操作系统会为用户生成一对初始令牌，分别是代表着用户所拥有的全部权限的完整版本令牌(即管理员权限令牌)，以及被限制管理员权限后的普通令牌，二者互为关联令牌;此后，代表用户的进程所使用的令牌都是由普通令牌继承而来，用来进行常规的、非敏感的操作;当用户需要进行一些需要管理员权限的操作时，比如安装软件、修改重要的系统设置时，都会通过弹出提权对话框的形式提示用户面临的风险，征求用户的同意，一旦用户同意，将会切换到当前普通令牌关联的管理员权限令牌，来进行敏感操作。通过这种与用户交互的方式，避免一些恶意程序在后台稍稍执行敏感操作。 <a href="http://blog.nsfocus.net/analysis-windows-access-authority-inspection-mechanism/">来自</a></p>
<blockquote>
<p>Access Token：是一个包含了登陆会话安全信息的 Windows 软件对象，用于指名一个用户以及他所在组以及相应的特权。 UAC Token：定义了Windows Vista 用户在UAC支持开启的时候的默认交互式登陆特权。一个 UAC Token 定义了最小的运行特权。 Full Token：给账户提供了最大的经过授权的特权。Full Token 实际上是由该用户隶属于的用户组决定的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过whoami -all查看当前用户所拥有的Privilege。</span><br></pre></td></tr></table></figure>
<h3 id="其他">其他</h3>
<p>部分受保护进程难以获得debug, 注入等权限. 保护进程的Protection成员不为0. 两种保护类型：Protected Process(PP)，Protected Process Lite(PPL). 对于Signer为PsProtectedSignerWindows(5)和PsProtectedSignerTcb(6)的保护进程, 其Type和Signer信息会被抽取出来, 组合成sid, 保存到基本令牌中的TrustLevelSid成员中</p>
<p>通过创建受限令牌，可以获得一个普通令牌所有拥有的权限集合的一个子集，用来进行一些低权限操作，降低安全风险。</p>
<p><a href="http://www.youngroe.com/2015/08/14/Windows/Windows-Permissions-Privilege/">权限编程需要注意的</a> <a href="http://www.cppblog.com/weiym/archive/2013/08/25/202751.html?opt=admin">权限编程2</a></p>
<h2 id="用户界面特权隔离-user-interface-privilege-isolation-uipi">用户界面特权隔离 User Interface Privilege Isolation, UIPI</h2>
<p>通过结合强制完整性控制，用户界面特权隔离阻止较低等完整性级别（Integrity level）的进程向较高等完整性级别进程的窗口发送消息或者安装钩子，但也有一些消息不被阻止。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-account-control-allow-uiaccess-applications-to-prompt-for-elevation-without-using-the-secure-desktop">UIAccess</a> 选项The ability to bypass UIPI restrictions across privilege levels is available for UI automation programs by using UIAccess. 但是必须签名并且安装在指定地点.</p>
<p>UAC level: asInvoker 不询问权限, 但是用户可以右键以管理员权限运行. highestAvailable时如果用户在admin用户组则和requireAdministrator一样, 必须以管理员权限运行.</p>
<blockquote>
<p>A lower privilege process cannot:</p>
</blockquote>
<blockquote>
<ul>
<li>Perform a window handle validation of higher process privilege.</li>
<li>SendMessage or PostMessage to higher privilege application windows. These application programming interfaces (APIs) return success but silently drop the window message.</li>
<li>Use thread hooks to attach to a higher privilege process.</li>
<li>Use Journal hooks to monitor a higher privilege process.</li>
<li>Perform dynamic link library (DLL)–injection to a higher privilege process.</li>
</ul>
</blockquote>
<h2 id="键盘监控的思路">键盘监控的思路</h2>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>适用范围</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GetAsyncKeyState</td>
<td></td>
<td>每次获取单个按键的状态, 轮询每个键状态, 效率略低</td>
</tr>
<tr class="even">
<td>GetKeyboardState</td>
<td></td>
<td>一次获取所有的键的状态, 和消息队列相关</td>
</tr>
<tr class="odd">
<td>SetWindowsHookEx 指定键盘</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="setwindowshookex">SetWindowsHookEx</h3>
<p>在回调函数中，我们将接收KeyboardProc的wParam中的虚拟键码和LowLevelKeyboardProc的KBDLLHOOKSTRUCT.vkCode（wParam指向KBDLLHOOKSTRUCT）。</p>
<p>如果m_ThreadId = 0，则消息钩子是全局消息钩子。针对全局消息钩子，你必须将回调函数置于dll中，并且需要编写2个dll来分别处理x86/x64进程。</p>
<p>针对底层键盘钩子，SetWindowsHookEx的HMod参数可以为NULL或者本进程加载的模块（我测试了user32，ntdll）。</p>
<p>WH_KEYBOARD_LL不需要dll中的回调函数，并且能适应x86/x64进程。</p>
<p>WH_KEYBOARD需要两个版本的dll，分别处理x86/x64。但是如果使用x86版本的全局消息钩子，所有的x64线程仍被标记为“hooked”，并且系统在钩子应用上下文执行钩子。类似的，如果是x64，所有的32位的进程将使用x64钩子应用的回调函数。这就是为什么安装钩子的线程必须要有一个消息循环。</p>
<p>hook是在整个桌面环境(desktop)内的. uac是safe desktop, 另外一个桌面</p>
<p><a href="https://www.anquanke.com/post/id/86403">来自</a> <a href="https://securelist.com/keyloggers-implementing-keyloggers-in-windows-part-two/36358/">专业文章</a></p>
<p>已知设置钩子是不能跨越完整度保护的. 猜测至少需要最高的完整度级别才能设置全局钩子</p>
<blockquote>
<p>"Process isolation provides a way to extend the authorization model to common extension points for inter-process communication. For example, if an application running at medium integrity were to register a hook to process Windows messages, this hook would not be active in a process running at the high integrity level."</p>
</blockquote>
<p>所以可能可以安装但是其实不是全局?</p>
<h3 id="subsystem-console">subsystem: console</h3>
<p>是一个过时的东西, 直接用subsystem: windows?? <a href="https://www.devever.net/~hl/win32con">看这</a></p>
<h2 id="自启动技术">自启动技术</h2>
<p><a href="https://www.jianshu.com/p/cf01fee50fb4">自启动技术</a></p>
<h2 id="bypass-uac">bypass uac</h2>
<p><a href="https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz">概述</a></p>
<p>这里研究的是COM接口绕过 <a href="https://y4er.com/post/bypassuac-with-icmluautil/">详述</a></p>
<h2 id="提权">提权</h2>
<ol type="1">
<li>权限窃取</li>
<li>使用服务的impersonation 真正的关键是分析其中的权限问题</li>
</ol>
<p>首先是bypass UAC, 得到SeDebugPrivilege, 然后就可以直接用窃取的方式得到System 没有UAC时特权很少, 完整度级别为Medium, 过了UAC就是High</p>
<p>现在就看创建服务了. 如果创建服务获取system不需要高完整度, 那就神了. 否则还是要bypass uac, 那还不如上面的方法. 目前我猜测大概是要高完整度的.</p>
<h2 id="远程线程注入">远程线程注入</h2>
<p>远程线程注入首当其冲就是权限问题, 需要debug权限?? !! meterpreter 怎么migrate的</p>
<p>打开一个同级别的进程, Medium的完整度的, OpenProcess的时候指定什么权限??</p>
<h2 id="raw_input方法的主函数的消息循环">raw_input方法的主函数的消息循环</h2>
<p>发现主函数其实消息非常少... 平时只有一个消息, 开了hook之后每按下和松开都有一个事件. 理解为是winmain的消息传过去的吗... 或者要先给到这边, 才能给到那边winProc 发现如果没有getMessage的循环，无论是Hook的keylog还是rawInput的keylog都不行。创建一个子进程执行而不是在dllmain里面执行好像没什么区别？？？ notepad.exe正常使用？？ 我的问题是，notepad.exe这种桌面程序难道不是应该winmain里有自己的Getmessage吗。。。为什么即使是注入也需要自己有getMessage的循环？？</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab2</title>
    <url>/2020/ucore%20lab2/</url>
    <content><![CDATA[<h1 id="ucore-lab2">ucore lab2</h1>
<p>继续看Intel 80386 Programmer's Reference Manual, 1987 (HTML) http://www.logix.cz/michal/doc/i386/ 再看Intel® 64 and IA-32 Architectures Software Developer Manuals https://software.intel.com/en-us/articles/intel-sdm</p>
<span id="more"></span>
<h3 id="内存管理">内存管理</h3>
<p>分段机制启动、分页机制未启动：逻辑地址---&gt;段机制处理---&gt;线性地址=物理地址 分段机制和分页机制都启动：逻辑地址---&gt;段机制处理---&gt;线性地址---&gt;页机制处理---&gt;物理地址</p>
<p>2^32 = 2^10 * 2^10 * 4k 段机制的时候，limit域长20bit，如果以4k为单位，那么就是最大4g 页机制，一个页4k字节，4字节一个页，一个页可以放1k个页表，那就是1k × 4k = 4M的内存，页表目录则是保存1k个页表，正好4M × 1000 = 4G</p>
<p>内存分配有几个阶段 https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_3_5_4_maping_relations.html</p>
<h3 id="lab2-宏观内存分配">lab2 宏观内存分配</h3>
<p><img src="https://segmentfault.com/img/remote/1460000009450843" /> 图片来自https://segmentfault.com/a/1190000009450840 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memory: 0009fc00, [00000000, 0009fbff], type = 1.</span><br><span class="line">memory: 00000400, [0009fc00, 0009ffff], type = 2.</span><br><span class="line">memory: 00010000, [000f0000, 000fffff], type = 2.</span><br><span class="line">memory: 07ee0000, [00100000, 07fdffff], type = 1.</span><br><span class="line">memory: 00020000, [07fe0000, 07ffffff], type = 2.</span><br><span class="line">memory: 00040000, [fffc0000, ffffffff], type = 2.</span><br></pre></td></tr></table></figure> 可用内存有两块，一个是从00000000 --&gt; 0009fc00 约1M字节 5个十六进制位是20bit，2^10 是1KB,那么2^20就是1M</p>
<p>bios加载bootloader bootblock占512字节 = 0x200.占0x7c00 ---&gt; 0x 7dff bootloader探测的内存信息位于0x8000</p>
<p>内核加载到100000，恰好是第二块可用内存的起始地址 第二块内存有07ee0000，大概126MB多一点 在memlayout.h <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define KMEMSIZE            0x38000000                  // the maximum amount of physical memory</span><br></pre></td></tr></table></figure> 这里限制的物理内存接近1g</p>
<p>然后就是kernel的ELF一路加载下来 其中data段有页目录表（约0x0010b000）和第一个页表 映射0~4MB的首个页表已经填充好。</p>
<p>0x10e000之后就是Page结构体，有32736个，每一个管理4K内存，和内存总量相符。 每一个Page有20字节，所以Pages占了654720字节 = 0x9fd80。占了640K...比想象中大好多 page管理物理内存，数量固定，页表数量可能变化，按需创建。 0x1add80之后就是用来分配的内存了，我们的kernel总共用了0xadd80=712KB。</p>
<p>如果内存再大的话，如果想对应上整个4g空间，那么Page占的空间还可以大32倍。</p>
<h3 id="diff-lab2-with-lab1">diff lab2 with lab1</h3>
<p>https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_2_2_phymemlab_files.html 简单来说变化不大，变化的部分除了一些不重要的库（cprintf，什么console的命令解析）其他的基本上都要在写lab2的时候碰到，指导书也讲得很详细。 可以先git commit lab1_result 之后再把lab2 覆盖进去看看变化。</p>
<h3 id="内存探测">内存探测</h3>
<p>bootasm.S 添加了有关内存分布的汇编代码 https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_5_probe_phymem_methods.html</p>
<h3 id="do-while0">do while(0)</h3>
<p>kern/sync/sync.h https://www.jianshu.com/p/99efda8dfec9</p>
<h3 id="kern_entry">kern_entry</h3>
<p>https://segmentfault.com/a/1190000009450840 https://chyyuu.gitbooks.io/ucore_os_docs/content/lab2/lab2_3_3_5_4_maping_relations.html</p>
<h3 id="gdb打印变量不对">gdb打印变量不对</h3>
<p>https://blog.csdn.net/jeff_/article/details/53333154 http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html CFLAGS := -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS) 修改成 CFLAGS := -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gdwarf-4 -nostdinc $(DEFS) 目测没有什么其他问题 然而 造成了print_stackframe()不能打印出行数了</p>
<h3 id="页表映射到自己">页表映射到自己</h3>
<p>页目录表地址意义： 这个地址开头的线性地址，管理它的页表在哪一个内存页（物理地址）？ 页表地址意义： 你这个4M的地址范围空间，里面的这个地址页在哪个物理内存页？</p>
<p>如果把页目录表项当成页表项，也就是说，里面的每一个页，都是一个页表。 把0xFAC（10 bit）映射到自己，也就是说在0xFAC（10 bit），这4M的虚拟地址，之后加上10bit的页表的虚拟地址前10bit作为index，就可以直接访问到页表了。 这就相当于必须要解两次地址，消耗了一次，这样就可以达到只取一次地址的效果了。</p>
<h3 id="invlpg">invlpg</h3>
<p>https://blog.csdn.net/cinmyheart/article/details/39994769 TLB 页表缓冲，我还以为只是页目录表缓冲。。。</p>
<p>问： TLB里面有页目录表吗？ 暂时答：因为缓冲一次就缓冲了整个页表，是否命中的判断就是根据对应的页目录表项对不对，所以可能命中缓冲时完全不需要访问页目录表。。。</p>
<blockquote>
<p>5.2.5 Page Translation Cache For greatest efficiency in address translation, the processor stores the most recently used page-table data in an on-chip cache. Only if the necessary paging information is not in the cache must both levels of page tables be referenced.</p>
<p>The existence of the page-translation cache is invisible to applications programmers but not to systems programmers; operating-system programmers must flush the cache whenever the page tables are changed. The page-translation cache can be flushed by either of two methods:</p>
<ol type="1">
<li><p>By reloading CR3 with a MOV instruction; for example:</p>
<p>MOV CR3, EAX</p></li>
<li><p>By performing a task switch to a TSS that has a different CR3 image than the current TSS. (Refer to Chapter 7 for more information on task switching.)</p></li>
</ol>
</blockquote>
<p>When to do or not do INVLPG, MOV to CR3 to minimize TLB flushing https://www.e-learn.cn/content/wangluowenzhang/626493 TLB的那些事儿 https://blog.csdn.net/omnispace/article/details/61415935</p>
<h2 id="缺页">缺页？</h2>
<p>问题： 现在管理的只是物理内存，那谁管理页表的映设关系？如果某虚拟地址没有对应的页怎么办？ 还是说lab2其实就没有管这一块？ 暂时答：似乎确实不管这回事？虽然有一些维护页表项的函数，但是没怎么被调用。 先写写lab3吧。</p>
<h3 id="mark-收藏夹">mark-收藏夹</h3>
<p>https://www.jianshu.com/p/abbe81dfe016 https://blog.csdn.net/hezxyz/article/details/95764158</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>NativeSummary：Java/C安卓应用无源码污点分析。</title>
    <url>/2022/NativeSummary/</url>
    <content><![CDATA[<p>让原有的安卓污点分析工具（如FlowDroid），支持通过JNI接口调用的汇编代码（C语言代码）的分析。</p>
<p>不使用符号执行等动态分析技术，而是使用二进制静态分析技术。</p>
<span id="more"></span>
<p>这是我本科毕设。最初选题其实我非常不喜欢这个题目的，现在只能说选都选了，还是继续搞吧，因为后面发现也没有想象中那么差。</p>
<p>这个题目可以分为两个部分 1. 逆向部分：将APK中的二进制库拿出来，分析基于JNI接口的汇编代码在干什么。 2. 跨语言部分：C语言和Java语言的差异摆在那里，如何污点分析。</p>
<p>通过探索得到了下面的方案：</p>
<ol type="1">
<li>首先分析Java部分找到native函数。然后对应到二进制库中的导出函数，即找到二进制的入口点。</li>
<li>依次分析每个JNI函数。至少把JNI API的调用提取出来。</li>
<li>基于观察，部分JNI函数还是非常接近Java里面的一些操作的。比如<code>SetObjectField</code>对应Java里面设置对象的成员，<code>CallObjectMethod</code>对应Java里面调用函数。基于这个思想，把相关的调用转换成Java语句。</li>
<li>为了兼容现有的框架，将生成的Java语句重打包到应用里。因为现有的（只支持Java虚拟机部分代码）的APK污点分析工具，除了都输入一个APK，也没什么额外的拓展接口了。所以通过重打包实现兼容。</li>
</ol>


	<div class="row">
    <embed src="/2022.assets/毕设论文-2022年5月17日-王纪开.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>StaticAnalysis</tag>
      </tags>
  </entry>
  <entry>
    <title>NativeSummary简介</title>
    <url>/2022/NativeSummary-intro/</url>
    <content><![CDATA[<p>本文是对NativeSummary的介绍。配有配套slides。</p>
<span id="more"></span>
<p>直觉是，很多JNI接口很多对应着Java语句的操作。支持的JNI调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Throw,  ThrowNew</span><br><span class="line">NewObject、Call[Nonvirtual/Static]XXXMethod</span><br><span class="line">Get/Set[Static]ObjectField</span><br><span class="line">不太好处理，先不管的：</span><br><span class="line">NewXXXArray、Get/ReleaseXXXArrayElements</span><br><span class="line">ExceptionCheck</span><br></pre></td></tr></table></figure>
<p>当拿到一个APK文件，解包得到dex文件-Java代码，<code>.so</code>文件代表C语言编译后的二进制代码。</p>
<ol type="1">
<li><p>JNI绑定部分：找到分析入口</p>
<ul>
<li><p>最简单的模式，静态块内的System.LoadLibrary，so侧通过导出函数直接绑定。我们则扫描so侧的导出函数作为入口。这些都发生在大部分代码之前。</p></li>
<li><p>动态绑定与JNI_OnLoad：System.LoadLibrary -&gt; JNI_OnLoad(.so库内的C语言函数) -&gt; DynamicRegister函数。也就是说依赖于对函数的分析，如果没有分析成功，直接无法找到函数入口点。但是一般的应用这个函数都是一个比较简单的编程模式的。</p></li>
<li><p>Java动态选择二进制库：Java类在静态块内往往调用System.loadLibrary，去加载不同的库。例如，有的APK会有两个名字类似，功能重复但稍有差别的二进制库，如<code>libxxx.so</code>和<code>libxxx_ssl.so</code>。这个有点麻烦，目前直接假设都会加载。</p></li>
</ul>
<p>还有各种其他小问题：</p>
<ul>
<li>分析的函数调用了其他so库内的函数：需要给分析器加上动态链接功能，加载并解析好。</li>
</ul></li>
<li><p>分析部分</p>
<ul>
<li><p>现在分析的现状：VSA的开源实现效果都不佳。介绍一下心路历程。</p></li>
<li><p>介绍BAI的原理。用一个实例。讲得复杂点。假设一个函数，被不同的context调用。然后有混合的情况。</p></li>
<li><p>介绍如何从AbsEnv里面提取对应到Java语句。同时介绍IR定义。</p></li>
<li><p>介绍如何才能</p></li>
</ul></li>
<li><p>更好地集成：</p>
<ul>
<li>架构设计：（其实之所以分开是因为上一个是Python的Angr和Soot的Java语言不一样。但是现在都是Java，但由于是插件的架构，虽然合并还是有点麻烦，但是理论上是可以的。而且可以更多地合作交互。</li>
<li>集成FlowDroid其实也行，但是不能把Flowdroid作为一个maven依赖使用。。。</li>
<li>最后看来重打包还是挺好的，而且有优点。</li>
</ul></li>
</ol>
<h3 id="callee-saved-register">callee saved register</h3>
<p>打一个形象的比方：假如有两个人（函数）洗衣服和修洗衣机，洗衣服函数会先把衣服放在旁边，然后操作洗衣机。首先判断是否洗衣机是坏的，是则要调用修洗衣机的函数。但是修洗衣机的那个人（函数）需要很大的位置（寄存器），所以需要把衣服挪开，修洗衣机，然后再把衣服放回去。有人可能问，为什么不让洗衣服函数在调用函数前把位置都空出来呢？因为有可能调用的函数是不太需要位置的，比如买洗衣粉函数。所以一般都会有部分位置作为随便用的，部分位置规定是要恢复的。比如这里采取了折中的方案，位置1是随便用的，位置2是要给原来的人保留的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">约定：位置1是随便用的(caller saved)，位置2的要给原来的人放回去（callee saved）</span><br><span class="line"></span><br><span class="line">func 洗衣服</span><br><span class="line">  衣服放到位置1，衣服放到位置2</span><br><span class="line">  if 洗衣机坏了</span><br><span class="line">    把位置1的东西挪到自己的仓库位置1</span><br><span class="line">    修洗衣机()</span><br><span class="line">    把自己的仓库位置1的东西放回位置1</span><br><span class="line">  if 没有洗衣服</span><br><span class="line">    买洗衣粉()</span><br><span class="line"></span><br><span class="line">func 修洗衣机 (需要两个位置)</span><br><span class="line">  把位置2的东西挪到自己的仓库位置1</span><br><span class="line">  在位置1，位置2修洗衣机</span><br><span class="line">  把自己的仓库位置1的东西放回位置2</span><br><span class="line"></span><br><span class="line">func 买洗衣服 (不需要位置)</span><br><span class="line">  买来洗衣粉</span><br><span class="line">  返回</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>StaticAnalysis</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始编写反编译器-WebAssembly</title>
    <url>/2022/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8-WebAssembly/</url>
    <content><![CDATA[<p>NotDec：从零开始编写反编译器： https://github.com/am009/NotDec</p>
<ul>
<li>2022年10月5日 项目目前处于起步阶段，希望有大佬能来一起参与开发。</li>
</ul>
<span id="more"></span>
<h3 id="为什么要反编译-二进制分析和源码分析的差距到底在哪">为什么要反编译？ 二进制分析和源码分析的差距到底在哪？</h3>
<p><strong>程序分析和程序变换相结合</strong>：我一直在思考，二进制分析和源码分析的差距到底在哪？我们知道，源代码一般是不能被直接执行的，我们之所以能够在源代码这个层次上编程，得益于最初编译技术的发展。程序在编译后变成了机器能理解的代码，但是同时也变得更复杂了。从这个角度看，编译器也可以看作是一种混淆，而我们去除混淆后不仅能更容易理解，也使得静态分析更加容易。</p>
<p>我们知道，机器执行的是汇编指令，有各种寄存器，内存，然后高层的数据类型，比如结构体和数组，在汇编指令的层次也不复存在。但最关键的是，每个函数的局部变量，变成了线性内存中维护的栈空间。（callee saved register和寄存器也是，但是这里暂时不提）举一个很简单的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line">arr[input()] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果直接分析汇编指令，就有点类似下面的形式。可以看到对数组的访问可以影响后面的所有变量。这种出现问题的情况还有很多。现在有不少针对二进制代码的定制化静态分析，但是因为处理了很多这样的复杂情况，效率上也是远远比不上源码的分析效率的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">6</span>];</span><br><span class="line">arr[input()] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>既然编译器会增加这么多复杂性，很自然的想法是怎么将编译器做的变换，逆着变换回去，变成原来的更简单的形式。这自然而然地让人想到了反编译。反编译技术的架构一般如下：除了最后的控制流分析，前面的步骤基本上就是我们想要的。</p>
<p>反编译器架构：</p>
<ol type="1">
<li>前端：将字节码转为LLVM IR</li>
<li>中端：优化与分析
<ol type="1">
<li>分析函数参数、分析callee saved register (wasm可以跳过这个阶段)</li>
<li>SSA构建：使得前端可以有些冗余的alloca，由SSA构建来将相关alloca消除。 （编译原理相关）</li>
<li>GVNGCM：Global Value Numbering and Global Code Motion 优化算法，有强大的优化能力，有助于反混淆等。（编译原理相关）</li>
<li>内存分析：将各种通过内存访问的变量显式地恢复出来。可能要用到指针分析算法，类型恢复等。关键词：Memory SSA。</li>
</ol></li>
<li>后端：高层控制流恢复，将字节码转为AST，打印为高级语言的形式。</li>
</ol>
<p>有的人可能会说反编译器可能不能保证静态分析的安全性（soundness），但是随着反编译技术的发展，很多分析手段都是较为通用的，同时能够在遇到异常情况的时候报出警告，告知相关不安全的判断。</p>
<h3 id="当我们说转ir的时候我们在说什么">当我们说转IR的时候，我们在说什么</h3>
<p>在反编译过程中，随着分析的深入，我们的IR也从low level变得更加high level。引用《Static Single Assignment for Decompilation》第6页（1.1 source code）附近说的，源代码可以说分为几个层次：</p>
<ol type="1">
<li>高质量，带注释源码（Well written, documented source code, written by the best human programmers.）</li>
<li>丢失了注释，函数名和各种变量名，结构体成员名字（Source code with few to no comments, mainly generic variable and function names, but otherwise no strange constructs. This is probably the best source code that a fully automatic decompiler could generate.）</li>
<li>同上，但是偶尔有奇怪的（底层的）东西（occasional strange constructs）</li>
<li>没有从内存中识别变量，所有的内存访问都是通过地址计算（Source code with no translation of the data section. Accesses to variables and data structures are via complex expressions such as <em>(v3</em>4+0x8048C00). Most registers in the original program are represented by generic local variables such as v3.）</li>
<li>同上，而且所有原始的寄存器也存在（but all original registers are visible.）</li>
<li>同上，相当于套了一个虚拟机，整个程序就是一个巨大的switch结构，根据不同的opcode去执行不同的指令。（but even the program counter is visible, and the program is in essence a large switch statement with one arm for the various original instructions）</li>
</ol>
<h3 id="现有的wasm反编译器">现有的wasm反编译器</h3>
<p>正如上文所说，现有的“反编译器”，很多的问题都在于没有去理解更深入的语义。</p>
<p>wasm有层次化的几个语言特性，也就意味着优化程度较高的代码对更底层的使用往往更少，导致简单的折叠出来的代码也有不差的效果。但是实际上并没有多少“反编译”的工作在里面。</p>
<ol type="1">
<li>栈 对应着SSA</li>
<li>local 对应着没有转为SSA的局部变量</li>
<li>内存中另外维护的栈 对应着需要取地址的变量，最为复杂。</li>
</ol>
<p>观察现有的“反编译器”：</p>
<ol type="1">
<li>wasm2c 这是wabt的一个工具，可以配套一些外围代码让wasm转换后的C语言能够运行起来。它比套虚拟机好一些，因为wasm指令还是比较简单的，可以转换为C语言指令，而不用弄一个巨大的switch case。</li>
<li>wasm-decompile 这也是wabt的一个工具，</li>
<li>wasmdec github上的一个简单的开源项目。很多这种“反编译器”一看代码量非常小，必然是不可能有完善的反编译分析的。问题也在于没有对内存有足够的分析。</li>
<li>jeb-pro 这个软件包含一个商业的反编译器，之前在安卓和二进制那边都有一些名气。二进制那边出名的反编译器大多都不怎么支持wasm和EVM，但是它似乎对EVM字节码和wasm都有支持。这种从二进制那边过来的反编译器想必基础更加扎实，效果应该也更好。</li>
</ol>
<h2 id="wasm的反编译">wasm的反编译</h2>
<ol type="1">
<li>前端：wasm字节码转LLVM IR
<ul>
<li>wasm独特的，可静态类型检查的栈结构，需要稍微特殊地处理一下。</li>
<li>wasm独特的控制流，处理起来也不是那么简单。</li>
</ul></li>
<li>中端：优化与分析
<ol type="1">
<li>分析函数参数、分析callee saved register (wasm可以跳过这个阶段)
<ul>
<li>wasm作为新时代的字节码标准，作为在浏览器运行中的标准，层次就比汇编高了很多，反编译也更加容易。这里主要说的是，汇编中需要指令和数据的区分，函数的识别，函数参数与保存的寄存器的处理，而这些在wasm中完全不需要。</li>
</ul></li>
<li>SSA构建：使得前端可以有些冗余的alloca，由SSA构建来将相关alloca消除。 （编译原理相关）（可以直接用LLVM的）</li>
<li>GVNGCM：Global Value Numbering and Global Code Motion 优化算法，有强大的优化能力，有助于反混淆等。（编译原理相关）（可以直接用LLVM的）
<ul>
<li>还有很多LLVM的pass可以用过来，可以参考RetDec用的。</li>
</ul></li>
<li>内存分析：将各种通过内存访问的变量显式地恢复出来。可能要用到指针分析算法，类型恢复等。关键词：Memory SSA。</li>
</ol></li>
<li>后端：高层控制流恢复，将字节码转为AST，打印为高级语言的形式。</li>
</ol>
<h3 id="wasm的栈处理与wasm混淆">wasm的栈处理与wasm混淆</h3>
<figure>
<img src="wasm-design-rationale.png" alt="wasm设计时就考虑了解码为ssa" /><figcaption aria-hidden="true">wasm设计时就考虑了解码为ssa</figcaption>
</figure>
<p>其实底层看，wasm的栈机制和结构化控制流，和一个东西很像。在SSA形式的IR中，用于替换Phi指令的语义等价的另一种表示形式是basic block argument。<a href="https://mlir.llvm.org/docs/Rationale/Rationale/#block-arguments-vs-phi-nodes">MLIR</a>也提到了，<a href="https://news.ycombinator.com/item?id=22432344">这里</a>也有相关的讨论。。所以其实wasm字节码的栈部分其实应该可以直接转成SSA形式。</p>
<p>如果你还是不确定Phi指令和Basic Argument是一个东西的话：因为Phi指令必须在基本块开头，而且必须对每个precessor都有一个对应的值，即操作数数量和precessor数量相同。（如果你说未初始化的变量。。那可以在entry块给每个变量赋值为undef，这样必然有值存在）然后想象把Phi指令的操作数直接保存到这条边上，更进一步放到跳转过来的每个jump语句处，然后phi指令对应的value还是放在当前基本块开头，这样其实就变成了BasicBlockArgument。</p>
<p>那wasm的栈到底要怎么转为SSA形式呢？我们可以参考basic block argument思想，在每个block或者loop块，为每个block的argument创建Phi指令，最后再移除trivial的Phi指令即可。</p>
<p>wasm和其SSA的对应形式其实也是对应的。比如，在字节码层面直接进行控制流平坦化，可能遇到栈上的东西不平衡的形式。而栈对应着SSA的值，其实在OLLVM那边的控制流平坦化也会遇到处理Phi指令的问题。他们的策略是demote ssa的值，降级到普通load-store的形式，这个就对应到wasm的local了。意味着我们也应该将导致栈不平衡的值作为local处理。这三个层次从上到下，限制越来越少，即下面的层次完全可以替代上面的层次，但是同时也越来越难以分析，因为其实限制越多越利于分析。</p>
<ol type="1">
<li>栈 对应着SSA</li>
<li>local 对应着没有转为SSA的局部变量</li>
<li>内存中另外维护的栈 对应着需要取地址的变量，最为复杂。</li>
</ol>
<p><strong>wasm的混淆自身有没有独特（specific challenge）之处呢？</strong> 我觉得还是有的，核心其实就在转换这部分。通过先转为现有SSA，再转回Wasm的方式，最大程度复用了混淆中共通的逻辑，那么额外需要的逻辑自然就是wasm特有的挑战了。如果不转为IR直接混淆确实会将部分wasm特有的挑战和混淆逻辑混合在一起，应该是让事情更复杂了。</p>
<h3 id="wasm的控制流处理">wasm的控制流处理</h3>
<p>最近出来了wasm 2.0。看了下好多复杂的东西。不过wasm 1.0 （MVP）还是非常简单的。对于每个控制流相关的指令</p>
<ol type="1">
<li>block，loop分别对应在结尾，开头，增加一个label。</li>
<li>if对应一些label和br_if，br代表直接跳转，br_if同理，根据语义找到对应的跳转目标，生成条件跳转即可。</li>
<li>br_table看似比较麻烦，看了下和LLVM的switch语句对应得非常好啊。也是根据不同的值跳转到不同的边。</li>
</ol>
<h3 id="ssa-ir的选择---为什么用这个ir">SSA IR的选择 - 为什么用这个IR？</h3>
<p>搜了一下，wasm相关的IR有bineryen，和Cranelift。他们内部都有SSA相关的表示。cranelift作为SSA IR，和LLVM IR在很多方面是非常相似的。但是最后各种选择可能</p>
<ol type="1">
<li>bineryen：非常有名，命令行工具是wasm-opt好像。它使用的IR似乎已经有点<a href="https://github.com/WebAssembly/binaryen/issues/663">架构上的问题</a></li>
<li>Cranelift: wasmtime的编译器架构中使用的IR。也支持SSA。但是没想到它居然直接添加了类似vmContext这种隐藏的参数，同时将全局变量lower到了用offset表示。</li>
</ol>
<p><strong>为什么不用现有的开源代码里面的转换部分？</strong> 确实存在相关的项目：</p>
<ol type="1">
<li><a href="https://github.com/WAVM/WAVM">WAVM</a>和<a href="https://github.com/gwsystems/aWsm">aWsm</a> 这两个都有编译器，而且也是LLVM IR的。所以里面很多转换相关的逻辑都是可以抄的。</li>
<li>WAMR wasm-micro-runtime 基于LLVM的，但是是C语言，使用LLVM-C-API，我们打算用的是C++的API。所以不太合适。</li>
</ol>
<p>但是他们似乎也有类似的问题：</p>
<ol type="1">
<li>转换出来的IR带有很多“无关”函数。因为这些VM的编译器要么是JIT要么是AOT，都得带上运行需要的外围函数。和我们的目标还是有所偏离的。</li>
</ol>
<p>另外一个非常奇怪的事情是，(在各种C/C++的wasm runtime项目中，wavm和wamr)，wasm二进制格式解析也没有特别通用统一的库。大家好像都自己写了一套。（除了rust的项目，rust好像都用的wasmparser）</p>
<p>TODO: 内存分析，控制流恢复，AST生成</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>WebAssembly</tag>
        <tag>Decompile</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>反编译-代码混淆-程序分析与编译优化</title>
    <url>/2022/%E5%8F%8D%E7%BC%96%E8%AF%91-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>这个暑假参加了那个编译系统设计赛，经历“磨难”后，不得不说确实视野开阔了很多。曾经CTF比赛中拿各种代码混淆完全没有办法，曾经下定决心想要学反编译却完全不知道从何下手。曾经自己搞代码混淆，看见LLVM IR也是一头雾水。</p>
<p>而现在，视野终于开阔了许多，能够有一些这几个领域的全局的视野了。</p>
<span id="more"></span>
<h3 id="推荐的学习路线">推荐的学习路线</h3>
<p>不得不说，编译器中后端的知识，包括SSA构建，SSA上的GVN等优化算法。和反编译密切相关。</p>
<ol type="1">
<li>《Static Single Assignment for Decompilation》 强烈推荐！！！之前看了很多反编译的论文，讲的都是类型恢复，或者怎么从IR恢复到上层控制流语句。完全没有提底层寄存器分配之类的问题。是这本书让我知道了到底反编译是怎么解决各种寄存器分配导致的问题的！！但是需要一些SSA相关的前置知识</li>
<li>各大反编译器的publication
<ol type="1">
<li>Retdec https://github.com/avast/retdec/tree/master/publications</li>
</ol></li>
<li>《How Far We Have Come: Testing Decompilation Correctness of C Decompilers》这篇论文挺好的，虽然没有直接讲反编译的原理。不仅特别新，而且给我们搞反编译的人带来了信心。</li>
</ol>
<p>关于编译原理的学习资源与路线，参考另外一篇文章。</p>
<h3 id="其他学习资源">其他学习资源</h3>
<p>最开始有一段时间真的是一点资源都没有。。但是现在看来，怎么着我也应该想想是不是又逆向相关的会议。确实，有了下面这些会议，起码逆向方面的论文是不愁看不完了。</p>
<p>Working Conference on Reverse Engineering (WCRE) https://ieeexplore.ieee.org/xpl/conhome/1000635/all-proceedings WCRE Working Conference on Reverse Engineering PPREW-5: Proceedings of the 5th Program Protection and Reverse Engineering Workshop 这个期刊好啊。 https://dl.acm.org/conference/pprew SSPREW: Software Security, Protection, and Reverse Engineering Workshop https://dl.acm.org/conference/ssprew</p>
<p><strong>其他我收藏的链接</strong></p>
<p>Github的两个list https://github.com/yasong/Awesome-Info-Inferring-Binary https://github.com/SystemSecurityStorm/Awesome-Binary-Rewriting</p>
<p>https://news.ycombinator.com/item?id=11218138 两个人的讨论。里面推荐对两篇文章的逆向引用搜索：https://scholar.google.com/scholar?as_ylo=2018&amp;hl=en&amp;as_sdt=2005&amp;sciodt=0,5&amp;cites=1148004013363547510&amp;scipsc=</p>
<p>https://scholar.google.com/scholar?cites=7322807636381891759&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=en</p>
<p>https://github.com/toor-de-force/Ghidra-to-LLVM https://uwspace.uwaterloo.ca/bitstream/handle/10012/17976/Toor_Tejvinder.pdf?sequence=3&amp;isAllowed=y Ghidra Pcode编译到IR。代码太简单了。。栈内存好像是alloca出来的，可能还是想保持语义想运行。</p>
<p>https://github.com/decomp/decomp 这人也想基于LLVM IR然后去优化。https://github.com/decomp/doc 相关文档 https://github.com/avast/retdec/blob/05c9b11351d3e82012d823fa3709f940033768cf/publications/README.md RetDec的publication</p>
<p>The Decompilation Wiki. http://www.program-transformation.org/Transform/DeCompilation</p>
<p>dagger主要讲的是反编译到IR上，找到语义等价的LLVM IR的指令的过程。感觉有点像编译器后端的Instruction Selection，可能能用上利用DAG（有向无环图）选择指令的技术。它是作为llvm的fork编写的，2017后就没有维护了。和llvm耦合好严重啊，都不知道哪里是它的代码。好像好复杂。</p>
<p>https://github.com/repzret/dagger 反编译到LLVM IR。aarch64还在开发过程中。https://llvm.org/devmtg/2013-04/bougacha-slides.pdf 介绍的slides</p>
<p>https://github.com/JuliaComputingOSS/llvm-cbe 曾经IR到C有一个backend，2016年被移除了。现在有人接手</p>
<p>https://corescholar.libraries.wright.edu/cgi/viewcontent.cgi?article=3277&amp;context=etd_all LLVM IR based decompilation。</p>
<p>https://github.com/lifting-bits/sleigh sleigh作为Ghidra的反编译器，是用C++写的，而且汇编到pcode的lift部分也是它负责的。所以用Ghidra可能也只要用这个就可以了。</p>
<p>https://github.com/cmu-sei/pharos 涉及到很多反编译技术</p>
<h3 id="看论文的一些笔记">看论文的一些笔记</h3>
<p>2022年9月18日</p>
<p>很多都是借用现有的type recovery，重点去讲structure recovery。</p>
<p>C Decompilation : Is It Possible ? 2009的一个: http://web.archive.org/web/20180517094139/http://decompilation.info/sites/all/files/articles/C%20decompilation.pdf 第二章相关工作里面有不少引用 structural analysis：[4–6]，这个也用在了编译器：[8]。 unification-based algorithm for recovery of types：Mycroft [9]</p>
<p>现有反编译器：DCC decompiler [7]. Boomerang [11], REC [12] and Hex-Rays plug-in [13]</p>
<p>【Phoenix】Native x86 Decompilation Using Semantics-Preserving Structural Analysis and Iterative Control-Flow Structuring https://kapravelos.com/teaching/csc591-s20/readings/decompilation.pdf Edward Schwartz's PhD thesis (<a href="https://users.ece.cmu.edu/~ejschwar/papers/arthesis14.pdf" class="uri">https://users.ece.cmu.edu/~ejschwar/papers/arthesis14.pdf</a>) covers in detail the Phoenix decompiler, which is another good jumping-off point. 这篇论文关注控制结构的恢复。控制结构的恢复最早是基于interval analysis的？这是什么得学一学。后面才被细化为structural analysis</p>
<p>【Dream】No More Gotos: Decompilation Using Pattern-Independent Control-Flow Structuring and Semantics-Preserving Transformations https://www.ndss-symposium.org/wp-content/uploads/2017/09/11_4_2.pdf slides： https://www.ndss-symposium.org/wp-content/uploads/2017/09/11NoMoreGotos.slide_.pdf code?： https://github.com/USECAP/dream</p>
<p>【DecFuzzer】How far we have come: testing decompilation correctness of C decompilers https://dl.acm.org/doi/abs/10.1145/3395363.3397370 香港科技大学的综述 代码在：https://github.com/monkbai/DecFuzzer 论文下载不到，SCI hub太强了。https://sci-hubtw.hkvisa.net/https://dl.acm.org/doi/10.1145/3395363.3397370 functionality-preserving disassembling and C style control structure recovery [17, 31, 47, 64, 65, 67] 变量恢复static analysis and inference techniques [10, 12, 13, 30, 54]. fool-proof techniques for binary disassembling and decompilation [17, 31, 64-67]. EMI编译器测试看了下是插入了不影响语义的代码之后去开编译优化，发现优化器做出的错误决定而导致的crash。比如把一个不该执行的循环内操作提到外面。错误判断一些分支恒为真或假。 是设置Csmith的输出使得只生成一个函数？？ 本来Csmith生成的代码很多全局变量的使用。如果全局变量改变了，很难手动找到是哪个函数？它是生成了局部变量，然后把对全局变量的使用全替换成了局部变量，函数结束的时候把局部变量的值update到全局变量，这样如果全局变量变了，就肯定是在最后update的时候改变的。那手动看的时候不要继续找内部怎么使用？这样做有什么好处吗。。。可能是方便找到这个函数到底涉及到了哪些全局变量，然后方便只提取这些到反编译结果的全局变量？？ 这篇论文可以研究一下重编译的技术。怎么单独提取出一个文件。怎么合并两个C语言文件。这样我想要用别人的汇编代码也可以用了。</p>
<p>【RetDec】没有论文好像。slides: https://2018.pass-the-salt.org/files/talks/04-retdec.pdf 中端用到了LLVM IR，但是最开始生成的IR也是那种全局变量表示寄存器的形式，不知道最后的时候有没有好一点。也许只是用LLVM IR去做一些控制流的pattern matching？不过有变量识别的Pass。有机会研究一下IR和变量识别的情况。</p>
<p>Evolving Exact Decompilation https://www.cs.unm.edu/~eschulte/data/bed.pdf</p>
<p>【rev.ng】rev.ng: A Multi-Architecture Framework for Reverse Engineering and Vulnerability Discovery. https://www.rev.ng/downloads/iccst-18-paper.pdf 这个反编译器开源了lifter：先转到Qemu IR然后转到LLVM IR。这个好像也不太和反编译相关，也只是搞插桩、fuzzing的。</p>
<p>类型恢复 【TIE】Principled Reverse Engineering of Types in Binary Programs. http://users.ece.cmu.edu/~aavgerin/papers/tie-ndss-2011.pdf 这篇搞了自己的DVSA，主要区别是SI里可以放除esp外的变量符号？。重点主要在后面的约束求解部分。后面的类型系统和求解部分也非常复杂TODO。</p>
<p>【SecondWrite】https://user.eng.umd.edu/~barua/elwazeer-PLDI-2013.pdf</p>
<p>【DIVINE】: DIscovering Variables IN Executables 这篇还是VSA系列的那些人写的。讲先用最简单的semi naïve方法鉴别变量，跑VSA，然后拿VSA结果去生成约束跑ASI。迭代几次得到最好的结果。 里面说如果变量是8字节大小，那VSA直接无法处理，值总是Top（32位程序）。那就不能直接把内存最大切分粒度搞成4字节？？</p>
<p>【REWARDS】Automatic Reverse Engineering of Data Structures from Binary Execution https://www.cs.purdue.edu/homes/xyzhang/Comp/ndss10.pdf TODO</p>
<p>【retypd】https://arxiv.org/pdf/1603.05495.pdf 需要进一步学习subtyping TODO。它不仅开源，而且不需要VSA的指针信息。可以与之前需要VSA的结合？</p>
]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Decompile</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>静态分析学习资源分享</title>
    <url>/2022/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>静态分析学习资源分享。</p>
<span id="more"></span>
<p>不得不说，在学习资源上，书 &gt; 课程 &gt; 论文/博客。对于论文，更早发表的更容易看懂。书则要找中文的，最新出版的。</p>
<p>静态分析方面中文书目前应该还没出来，因此最好和国际接轨，学好英语看英文书。英文书其实也不多，有如下几本：</p>
<ol type="1">
<li><p>《Introduction to Static Analysis An Abstract Interpretation Perspective (Xavier Rival, Kwangkeun Yi) 》 MIT Press 2020</p>
<p>极力推荐。新出版的书整体水平和可读性就是高很多。</p></li>
<li><p>《Principles of Program Analysis》 第二版 2005</p></li>
</ol>
<p>学习资源拿到手看一下，如果讲的都是已经会了的可以扔，如果讲的太难可以记下来，以后回来再看，最后目的都是找到刚好符合自己水平的。</p>
<p>还有各种开源项目的publications</p>
<ol type="1">
<li>SVF http://svf-tools.github.io/SVF/</li>
<li>Frama-C https://frama-c.com/html/publications.html</li>
<li>Python和C跨语言的Mopsa https://mopsa.lip6.fr/</li>
</ol>
<h2 id="之前的总结">之前的总结</h2>


	<div class="row">
    <embed src="/2022.assets/程序静态分析学习资料分享-wjk.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>StaticAnalysis</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理学习与编译系统赛</title>
    <url>/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>暑假参加了编译系统设计赛，受益匪浅。在比赛初期，拖延症严重，同时经常感觉学习资源匮乏，而且也还在摸黑阶段，心理压力下经常就会高估学习的困难，觉得是不可逾越的大山。尤其是编译器后端，这方面相关的学习资源感觉非常匮乏。现在看来，前期确实没能重视一些重要的学习资源，后面走弯路学会了已经晚了。</p>
<span id="more"></span>
<p>不得不说，学了理论还是要实践才能有更深的理解。从最早的操作系统开始，到现在编译原理，真正自己完成一个小型的编译器，操作系统之后，那种感觉是之前反复看书看视频学理论完全没有的。不仅掌握得更深，知道了相关的东西是如何落地的，知道和其他东西的联系，更重要的是有一种能够把握知识体系，一览全局的感觉。就好像去一个位置的地域探索，当你把主干道都走了一遍之后，即使有的地方没去过，它在什么方位也能知道。</p>
<p>编译器学习大概有这几个主线</p>
<ol type="1">
<li>前端：从零开始，学习自动机理论，词法分析，语法分析。然后可以实践语法分析，尝试写parser，使用ANTLR等。更进阶的可以看看《parsing technique》，光是当作科普书也挺有意思的。曾经看到老旧的编译器教材说，之后的中间表示有什么三地址码什么的。反正我学到现在是没有那些东西的，直接LLVM IR吧。</li>
<li>中端：开始接触LLVM IR，开始接触SSA相关理论。更深入地学SSA construction，学SSA destruction。然后接触一些SSA上的优化算法，比如GVN等。</li>
<li>后端：开始了解指令选择和寄存器分配理论。指令选择的话，我们手写简单的编译器应该是难以做到那种给每个指令写配置然后自动生成什么的。然后实践一些图着色的寄存器分配算法。后端寄存器分配这里，如果你觉得线性扫描可能会简单一点的话，那还真不一定。建议直接实现图着色。 大致的经历是，</li>
</ol>
<p>对于参加编译器比赛来说，手把手的实验教程是真的救星：</p>
<ol type="1">
<li><p>北航mini-sysY实验教程：https://github.com/BUAA-SE-Compiling https://buaa-se-compiling.github.io/miniSysY-tutorial/ 这个教程依然是偏前端的，时候早期学习完词法分析，语法分析后实践加深理解。</p></li>
<li><p>北大编译课实践教程：这个是参加比赛时久仰大名的 邢其正 大佬的教程。https://github.com/pku-minic/online-doc https://pku-minic.github.io/online-doc/ 在当时大量教程止步于前端到中端就结束的时候，只有这个教程讲到了后端。</p></li>
</ol>
<p>除了传统的龙书虎书鲸书之外，还有一本书不得不说，《Engineering a compiler》中文版是《编译器设计》 https://book.douban.com/subject/20436488/ 。讲得浅显易懂。建议优先于龙书虎书鲸书看。9.3章非常好，对SSA介绍也比较详细。</p>
<p>《SSA book》挺有名的，之前学程序分析就听说了。但是我个人其实看得不多。甚至ssa构建都是“偷懒”用的《simple and efficient ssa construction》里的简单算法，不需要折腾支配边界的计算什么的。</p>
<p>后端的书有： 1. 《Instruction selection: Principles, Methods, and Applications》。顶着英文看。这本书我之前看起来还是有点费劲的，但是没必要完全看懂不是吗，看下来算是对指令选择这一块有了总体的印象。最后实践上（参加编译器比赛）来说，可能最后还是采取“宏展开”（其实就是对每个IR单独写分支生成机器指令），然后加上一些窥孔优化的思路。里面的一些高级思路基本没用起来。没想到在后端指令选择这里居然也和前端学到的语法分析能扯上关系。</p>
<p>寄存器分配的书看后文</p>
<p>LLVM相关的书有：</p>
<ol type="1">
<li><a href="http://www.aosabook.org/en/llvm.html">The Architecture of Open Source Applications: LLVM</a></li>
<li>《LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries》</li>
<li>《Learning LLVM 12》 这两本新书来自Packt Publishing，非常优质的资源，不可多得</li>
</ol>
<p>LLVM在Youtube上也有很多视频</p>
<ol type="1">
<li>《2019 EuroLLVM Developers’ Meeting: V. Bridgers &amp; F. Piovezan “LLVM IR Tutorial - Phis, GEPs and other things, oh my! - Vince Bridgers (Intel Corporation)”》 https://www.youtube.com/watch?v=m8G_S5LwlTo https://llvm.org/devmtg/2019-04/slides/Tutorial-Bridgers-LLVM_IR_tutorial.pdf 这个视频用来学习GetElementPtr指令非常好</li>
<li>2019 LLVM Developers’ Meeting: A. Warzynski “Writing an LLVM Pass: 101” https://www.youtube.com/watch?v=ar7cJl2aBuU 源码外的Pass：不和LLVM代码放在一起，不需要重新编译LLVM 基于NewPassManager：新版PassManager API，即将成为默认PM</li>
<li>2019 LLVM Developers’ Meeting: J. Paquette &amp; F. Hahn “Getting Started With LLVM: Basics” https://www.youtube.com/watch?v=3QQuhL-dSys 前半部分 讲了LLVM IR Pass需要考虑到的一些东西，users的概念，讲了移除基本块和指令时需要注意的。</li>
<li>《2019 LLVM Developers’ Meeting: S. Haastregt &amp; A. Stulova “An overview of Clang ”》 https://www.youtube.com/watch?v=5kkMpJpIGYU</li>
<li>2019 LLVM Developers’ Meeting: J. Paquette &amp; F. Hahn “Getting Started With LLVM: Basics” https://www.youtube.com/watch?v=3QQuhL-dSys 介绍了后端</li>
</ol>
<h3 id="其他资源">其他资源</h3>
<p>优质的（浅显易懂的）学习资源是学习前期永远稀缺的资源。有时候你想找都不知道怎么找。所以这里列出我记下来的所有资源：</p>
<p><a href="http://c9x.me/compile/bib/">The Compiler Writer Resource Page (c9x.me)</a> 一个人的资源分享</p>
<p>针对arm的优化算法：乘法转移位：Division by invariant integers using multiplication. CPU文档，乘法是6-8周期，除法是10-12周期</p>
<p>ARM手册看Cortex-A72 software Optimization Guide.</p>
<p><a href="https://www.bilibili.com/video/BV1Lf4y1y78n?vd_source=e9f223609ade8d8a4012f354190eda15">C＃C++17系列+动手编写编译器与虚拟机项目（原版共400小时）_哔哩哔哩_bilibili</a></p>
<p><a href="https://tobyho.com/video-series/Live-Code-LLVM-Tutorial-Walkthrough.html">Series: Live Code: LLVM Tutorial Walkthrough (tobyho.com)</a></p>
<p>https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/README.html</p>
<p><a href="https://github.com/elvin-du/tinyscript">elvin-du/tinyscript: 自制的一个编译器， 用于学习，完整实现了词法分析，语法分析，中间代码（SSA）生成，机器码生成，和基于寄存器的虚拟机 (github.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/111635473">编译器资料3 关于编译器和静态分析的一些课程 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.zhihu.com/people/rednaxelafx/answers">RednaxelaFX - 知乎 (zhihu.com)</a> 这人是编译器大佬，他的回答能帮我们节省很多时间：包括什么技术需要看什么论文，有哪些实现</p>
<p>book of runtime</p>
<p>对于LLVM之类的编译器是如何实现在构造 SSA 形式的 IR 的时候，计算出 def-use 链？ - RednaxelaFX的回答 - 知乎 https://www.zhihu.com/question/41999500/answer/93243408</p>
<p>Phi node 是如何实现它的功能的？ - RednaxelaFX的回答 - 知乎 https://www.zhihu.com/question/24992774/answer/29740949</p>
<p><a href="https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html">mem2reg 实验指导 · GitBook (buaa-se-compiling.github.io)</a></p>
<h3 id="ssa构建与gvn的强大优化能力">SSA构建与GVN的强大优化能力</h3>
<p>我之前一直挺疑惑，编译器的优化到底具体在哪里。甚至之前编译器写了一半还是不太知道。就比如我随便找一个C语言代码，想不清楚编译器具体是怎么优化出来的。比如下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test if-else-if</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ifElseIf</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">6</span> || b == <span class="number">0xb</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">10</span> &amp;&amp; a == <span class="number">1</span>)</span><br><span class="line">      a = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">10</span> &amp;&amp; a == <span class="number">-5</span>)</span><br><span class="line">      a = a + <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      a = -+a;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器比赛的时候先追求功能测试，所以没有搞任何ssa的东西。那时候也还是不知道这种该怎么优化。生成出来的IR是下面这样的。</p>
<p>直观感觉，很多条件判断可以搞出来优化掉。但是之前听说的优化，都是什么常量表达式给计算一下，公共子表达式消除一下，都是这种比较浅的。看下面的IR可以看到也没什么可以直接优化的啊，因为你获取变量都还是load加载出来的，但是好像没看到什么分析能够直接追踪你load到底加载了什么东西，然后去优化。所以当时就感觉自己不太懂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @ifElseIf()&#123;</span><br><span class="line">entry:</span><br><span class="line">  %a_0 = alloca i32 </span><br><span class="line">  %b_1 = alloca i32 </span><br><span class="line">  store i32 5, i32* %a_0</span><br><span class="line">  store i32 10, i32* %b_1</span><br><span class="line">  %0 = load i32, i32* %a_0</span><br><span class="line">  %1 = icmp eq i32 %0, 6</span><br><span class="line">  %2 = zext i1 %1 to i32</span><br><span class="line">  %3 = icmp ne i32 0, %2</span><br><span class="line">  br i1 %3, label %if_true_0, label %or_right_1</span><br><span class="line"></span><br><span class="line">or_right_1:</span><br><span class="line">  %4 = load i32, i32* %b_1</span><br><span class="line">  %5 = icmp eq i32 %4, 11</span><br><span class="line">  %6 = zext i1 %5 to i32</span><br><span class="line">  %7 = icmp ne i32 0, %6</span><br><span class="line">  br i1 %7, label %if_true_0, label %if_false_0</span><br><span class="line"></span><br><span class="line">if_true_0:</span><br><span class="line">  %8 = load i32, i32* %a_0</span><br><span class="line">  ret i32 %8</span><br><span class="line"></span><br><span class="line">tmp_2:</span><br><span class="line">  br label %if_end_0</span><br><span class="line"></span><br><span class="line">if_false_0:</span><br><span class="line">  %9 = load i32, i32* %b_1</span><br><span class="line">  %10 = icmp eq i32 %9, 10</span><br><span class="line">  %11 = zext i1 %10 to i32</span><br><span class="line">  %12 = icmp ne i32 0, %11</span><br><span class="line">  br i1 %12, label %and_right_4, label %if_false_3</span><br><span class="line"></span><br><span class="line">and_right_4:</span><br><span class="line">  %13 = load i32, i32* %a_0</span><br><span class="line">  %14 = icmp eq i32 %13, 1</span><br><span class="line">  %15 = zext i1 %14 to i32</span><br><span class="line">  %16 = icmp ne i32 0, %15</span><br><span class="line">  br i1 %16, label %if_true_3, label %if_false_3</span><br><span class="line"></span><br><span class="line">if_true_3:</span><br><span class="line">  store i32 25, i32* %a_0</span><br><span class="line">  br label %if_end_3</span><br><span class="line"></span><br><span class="line">if_false_3:</span><br><span class="line">  %17 = load i32, i32* %b_1</span><br><span class="line">  %18 = icmp eq i32 %17, 10</span><br><span class="line">  %19 = zext i1 %18 to i32</span><br><span class="line">  %20 = icmp ne i32 0, %19</span><br><span class="line">  br i1 %20, label %and_right_6, label %if_false_5</span><br><span class="line"></span><br><span class="line">and_right_6:</span><br><span class="line">  %21 = load i32, i32* %a_0</span><br><span class="line">  %22 = sub i32 0, 5</span><br><span class="line">  %23 = icmp eq i32 %21, %22</span><br><span class="line">  %24 = zext i1 %23 to i32</span><br><span class="line">  %25 = icmp ne i32 0, %24</span><br><span class="line">  br i1 %25, label %if_true_5, label %if_false_5</span><br><span class="line"></span><br><span class="line">if_true_5:</span><br><span class="line">  %26 = load i32, i32* %a_0</span><br><span class="line">  %27 = add i32 %26, 15</span><br><span class="line">  store i32 %27, i32* %a_0</span><br><span class="line">  br label %if_end_5</span><br><span class="line"></span><br><span class="line">if_false_5:</span><br><span class="line">  %28 = load i32, i32* %a_0</span><br><span class="line">  %29 = sub i32 0, %28</span><br><span class="line">  store i32 %29, i32* %a_0</span><br><span class="line">  br label %if_end_5</span><br><span class="line"></span><br><span class="line">if_end_5:</span><br><span class="line">  br label %if_end_3</span><br><span class="line"></span><br><span class="line">if_end_3:</span><br><span class="line">  br label %if_end_0</span><br><span class="line"></span><br><span class="line">if_end_0:</span><br><span class="line">  %30 = load i32, i32* %a_0</span><br><span class="line">  ret i32 %30</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面搞了SSA构建，学了挺久的。搞出来之后发现优化的机会立马出来了。下面是ssa构建后的IR。SSA构建的原理就是，本来变量都是直接load的，使用LLVM的伪ssa形式。SSA构建负责在每个load的地方，确定你到底load是之前store的谁，然后把之前store进去的东西直接拿过来。即load和store都没了，值直接传递到了它该有的地方。明显可以看到，只需要搞一下常量表达式计算，优化一下必定跳转某个分支的条件跳转就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @ifElseIf()&#123;</span><br><span class="line">entry:</span><br><span class="line">  %0 = icmp eq i32 5, 6</span><br><span class="line">  br i1 %0, label %if_true_0, label %or_right_1</span><br><span class="line"></span><br><span class="line">or_right_1:</span><br><span class="line">  %1 = icmp eq i32 10, 11</span><br><span class="line">  br i1 %1, label %if_true_0, label %if_false_0</span><br><span class="line"></span><br><span class="line">if_true_0:</span><br><span class="line">  ret i32 5</span><br><span class="line"></span><br><span class="line">if_false_0:</span><br><span class="line">  %2 = icmp eq i32 10, 10</span><br><span class="line">  br i1 %2, label %and_right_4, label %if_false_3</span><br><span class="line"></span><br><span class="line">and_right_4:</span><br><span class="line">  %3 = icmp eq i32 5, 1</span><br><span class="line">  br i1 %3, label %if_true_3, label %if_false_3</span><br><span class="line"></span><br><span class="line">if_true_3:</span><br><span class="line">  br label %if_end_3</span><br><span class="line"></span><br><span class="line">if_false_3:</span><br><span class="line">  %4 = icmp eq i32 10, 10</span><br><span class="line">  br i1 %4, label %and_right_6, label %if_false_5</span><br><span class="line"></span><br><span class="line">and_right_6:</span><br><span class="line">  %5 = sub i32 0, 5</span><br><span class="line">  %6 = icmp eq i32 5, %5</span><br><span class="line">  br i1 %6, label %if_true_5, label %if_false_5</span><br><span class="line"></span><br><span class="line">if_true_5:</span><br><span class="line">  %7 = add i32 5, 15</span><br><span class="line">  br label %if_end_5</span><br><span class="line"></span><br><span class="line">if_false_5:</span><br><span class="line">  %8 = sub i32 0, 5</span><br><span class="line">  br label %if_end_5</span><br><span class="line"></span><br><span class="line">if_end_5:</span><br><span class="line">  %a_0_5 = phi i32 [ %7, %if_true_5 ], [ %8, %if_false_5 ]</span><br><span class="line">  br label %if_end_3</span><br><span class="line"></span><br><span class="line">if_end_3:</span><br><span class="line">  %a_0_4 = phi i32 [ 25, %if_true_3 ], [ %a_0_5, %if_end_5 ]</span><br><span class="line">  ret i32 %a_0_4</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面我们继续想怎么实现基于SSA的优化。之前理论学习的时候虽然听说过什么常量表达式计算啊，公共子表达式什么的这种简单优化，但是看他们往届参赛队员的经验分享的时候，好像都没怎么提到。但是他们都提到了一个叫GVN GCM的优化。《Global Code Motion Global Value Numbering》这篇论文。刚学完SSA构建看这篇论文感觉挺容易看懂的。推荐去看，直接获取一手资料。</p>
<p>简单介绍一下，GCM能够把计算的代码放到尽可能少被执行到的地方，比如很深的分支判断里。或者放到循环外面，同时保证语义正确。这里我们主要关注GVN。它是一个强大的优化，涵盖了公共子表达式消除，常量计算，控制流优化等等优化手段，即只用这一个就够了。而且还非常系统，通用，直接从之前那些小优化要不要实现，怎么组合的问题里解脱。基本的思路是，程序的任何计算都给他生成一个哈希值，然后每次要做什么计算都去查表，保证不会重复计算。然后放入表前做好常量计算等优化。这里不详细讲了。</p>
<p>GVN和控制流优化迭代优化后的IR如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @ifElseIf()&#123;</span><br><span class="line">entry:</span><br><span class="line">  ret i32 -5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接全给优化没了！！！这时候我才彻底明白编译器到底是怎么优化代码的。总结：SSA构建本身（某种意义上）就有很强的优化能力，加上GVN这样的“高级”优化算法，让编译器有了非常强大的通用优化能力。</p>
<h3 id="ssa-构建">SSA 构建</h3>
<p>《Simple and Efficient Construction of Static Single》这篇论文真的是强。感觉ssa这种理论上也比较简洁的东西也应该有简洁的构建算法。一方面网上大家都说的是最早的那个构建算法，SSA book里面也只提到了那个初始的构建算法，导致这个算法感觉比较先进，而且采用新的算法也可以让自己学新的东西，因为不太会去抄。所以我直接上了这个算法。</p>
<p>（虽然后面还是出现了bug，我对着那个论文里的伪代码实现算法，好像是说，那个replaceBy函数用一个值替换掉某个trivial的Phi指令的时候，在currentDef这个map里可能有些变量还指向这个phi，然后导致了问题。论文里也没细说要replaceBy要怎么实现，感觉就是直接在指令层面replace all use with，没有提到map的问题。直接替换map感觉复杂度太高了。。。我后面是用之前OJ做并查集题目那边的灵感，额外用一个map表示原来被替代的phi被谁替换了，然后readVariable函数查map的时候额外查一下这个表。最后算是解决了问题。。。</p>
<h3 id="寄存器分配与调用约定约束">寄存器分配与调用约定约束</h3>
<p>最开始的时候没怎么学寄存器分配，导致一直有一个疑问：调用约定会规定比如返回值放到r0，参数放到r0-r3，那我寄存器分配怎么考虑这种约束呢？而且如果有这样的场景<code>&#123; int x1 = func1(); func2(0, x1) &#125;</code>那么这个x1因为是func1的返回值，在call指令后会放在r0，那么在冲突图上，就有一个预着色节点x1必须着色为r0，然后我又要传给func2的第二个参数，x1就要放到寄存器r1，那么在冲突图x1作为预着色节点又应该被着色为r1。然后论文里说，预着色节点是必须遵守的，那我这不就完全冲突了吗？怎么回事？预着色节点真的必须遵守？</p>
<p>后面才知道原来有一个阶段叫register coalescing，就是解决这种调用约定约束带来的问题的。当生成冲突图的时候，如果遇到这种调用约定的约束，比如x1作为函数返回值会在call指令后被放到r0，其实会生成两个节点，一个节点代表r0，是预着色节点，然后同时生成一个没有着色节点代表x1，同时会立刻生成一个mov指令，把r0的值mov到x1，使用mov指令解除了x1和r0的绑定关系。。。这个着色了的r0节点才是真正的不可更改颜色的。然后后面register coalescing阶段就是用来尽可能地消除move指令的。。。</p>
<h3 id="我们的编译器">我们的编译器</h3>
<p>毕竟为了答辩都花那么多时间准备PPT了，为什么不水一篇博客让更多人看到呢？我们是2022年的无色透明队，在比赛最后几个小时大佬们的“屯flag”（CTF界说法）的冲击下，最后算是保住了一个三等奖。</p>


	<div class="row">
    <embed src="/2022.assets/编译系统设计赛-答辩.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h3 id="参加编译系统设计赛---架构选型">参加编译系统设计赛 - 架构选型</h3>
<h4 id="前中端">前中端</h4>
<p>不得不说Java应该还是比C++好用的。我们用Java写编译器感觉挺好的。设计IR的时候没这么想，直接对着LLVM IR specification的文本格式，设计成员域，直接toString方法转成LLVM IR。这样直接可以先写前端，然后用clang直接验证我们的正确性。这也是他们经验分享推荐的做法。</p>
<p>唯一可以变的地方可能是，现在流行Basic Block Argument替代Phi节点（<a href="https://mlir.llvm.org/docs/Rationale/Rationale/#block-arguments-vs-phi-nodes">MLIR</a>和北大的那个教程都提到了）。我们最开始的时候完全不熟SSA，所以也不敢乱动，既不知道phi是什么，也不知道如果改用basic block argument了，那些SSA上的算法该怎么改。现在看来，本来Phi指令也必须放在基本块开头，basic block argument也差不多的意思，只不过如果你想从Phi找到Phi指令的操作数的时候，得去前驱基本块那边找它传过来的argument罢了。差别还是不大的。而且确实简化了结构，不用维护Phi指令操作数和前驱基本块的对应关系了。</p>
<h4 id="后端---寄存器分配">后端 - 寄存器分配</h4>
<h5 id="ssa解构后寄存器分配">SSA解构后寄存器分配</h5>
<p>不可能没有走弯路的。我们一开始不熟悉后端，寄存器分配不知道怎么做，于是就参照Engineering a compiler那边实现了一个local寄存器分配（后面被证明是最大的性能瓶颈）。队友他觉得lsra比图着色简单，开始看Java的寄存器分配算法，结果说写了几百行也不太缺点最后能不能写完，同时看到其他队伍也有从lsra转型图着色的。我们最后看了之前“燃烧我的编译器”队的图着色，惊讶他们怎么这么一点代码就实现了图着色分配，有了迅速实现的灵感。他们的做法其实算是，保留两到三个寄存器用于修复一切问题，然后剩余的寄存器直接构建冲突图，然后给每个节点计算权重，然后直接分配。省去了原本反复迭代的复杂步骤。</p>
<p>总之，寄存器分配这边先实现一个简单的寄存器分配还是必要的。我之前看<a href="https://pku-minic.github.io/online-doc/#/lv9p-reincarnation/reg-alloc">北大的那个教程</a>的时候，完全不理解，什么叫不分配寄存器。后面浪费大量时间在我的垃圾Local寄存器分配上之后，才明白。不分配寄存器并不是说真的不分配，而是说，只用最少的寄存器完成分配，每个指令在开始前从栈上把东西加载出来，结束后把东西保存会栈上，即使用最少的寄存器（一般两个寄存器就可以了），把其他的寄存器空出来。</p>
<p>详细来说，是有一个映射表保存已经完成的寄存器分配，然后我们用两个额外留出来的寄存器，完成“修复”工作。也就是说无论你前面怎么分配，甚至完全不分配，我后面只用两个寄存器都可以给你修好。这样不仅实现了一个简单的寄存器分配算法，后面还可以通过增加前置的分配阶段完成简单图着色分配。</p>
<h5 id="基于ssa的寄存器分配">基于SSA的寄存器分配</h5>
<p>寄存器分配方面，（从我看过的里）推荐下面的资料：</p>
<ol type="1">
<li>《Iterated Register Coalescing》这个是传统的思路。学习还是要学的。介绍了基础的迭代式寄存器分配策略，有多个阶段，每个阶段可能会做出一些决策导致又要从头开始分析（毕竟要找最佳的分配），但是往往并不会迭代太多次。编译器比赛里面大多数队伍都是采用的这种策略（或它的简化版）。</li>
<li>基于SSA的（图着色）寄存器分配系列：
<ol type="1">
<li>《SSA Elimination after Register Allocation》</li>
<li>《Register Allocation for Programs in SSA Form》https://publikationen.bibliothek.kit.edu/1000007166/6532 看着像一本书，其实好像是学位论文。写得非常好。里面不仅仅是讲SSA寄存器分配，而是各种都有涉及，而且讲得挺好（浅显易懂）的。强烈推荐，即使不打算用基于SSA的寄存器分配的人也应该看看。</li>
</ol></li>
</ol>
<p>为什么要用基于SSA的（图着色）寄存器分配呢？想象这样的场景，当你苦苦地一天天加班加点写寄存器分配写了很长，比赛结束发现隔壁队伍大佬居然就用了极少的代码量就完成了这一部分，而且性能还比你好很多，这不得直接气晕过去。而基于SSA的寄存器分配可能就是这种神器（虽然我们因为时间原因并没有写出来，不过ayame他们好像就是用了SSA的寄存器分配）。</p>
<p>基于SSA的寄存器分配指的是，在寄存器分配的时候依然保持SSA形式，在分配结束后才解构SSA。先解构SSA再寄存器分配更容易，因为你如果先分配，再去直接解构，往往会发现，我寄存器都没了，但是解构SSA需要做变量复制，我没有寄存器作为中介无法挪动值了。但同样，如果能解决这一问题，那么同样会很好地简化寄存器分配的实现。</p>
<p>更重要的是，基于SSA的寄存器分配在理论上也更优雅。传统的寄存器分配往往会告诉你，寄存器分配已经是NP完全问题了，因为冲突图的图着色是NP完全的。然而，当你在SSA形式上进行寄存器分配时，它构建出的冲突图有特殊的性质，能够在多项式时间内找到解！！！也就是说，传统的思路你先SSA解构然后再寄存器分配，其实SSA解构这一步是增大了寄存器分配的难度的！！完全不需要那种迭代式的解构，整个图着色分配架构直接是线性的！！不仅效率上优于传统方法，代码量也明显可以感觉可以降下来！！唯一需要的就是额外的理论学习，里面有一些图算法需要好好学一下。</p>
<p>总结：现在回顾，寄存器分配在编译器比赛的开发上其实是可以渐进完成的：从最开始的只用两个寄存器去分配，到后面构建冲突图，计算权重，优先分配权重高的，后面分配不了就不分配，让前面只用两个寄存器分配的逻辑去修复，到最后SSA的寄存器分配。我们之前花太多时间在Local寄存器分配还是太亏了。又复杂性能又差</p>
<h3 id="培训经验分享时我的笔记">培训经验分享时我的笔记</h3>
<p>于剑 小林家的编译器队，分享参赛经验</p>
<p>怎样赶紧搭一个能跑的框架：中端优化空着，后端寄存器分配不太能跳过，寄存器不够的时候用栈空间的逻辑还是得写，但是分配可以写简单的版本。</p>
<p>约定IR，前端要比较完整的功能，终端后端优化pass都可以不要，寄存器分配写个简单版本</p>
<p>后端还是要写很多东西才能跑起来，他们那时候就进度有点落后了。</p>
<p><strong>前端</strong> 不是重点，但是却是正确性问题出现最多的地方。隐藏的功能测例：看名字猜内容。</p>
<p>sys-Y里的const的规则，必须是一个编译期常量。当const类型出现在数组长度里，需要它的值才能知道具体大小，尤其是生成数组访存的时候需要知道上一维的长度。处理字面量的时候小心-2147483628，本来是合法的，如果分成一个负号运算和正数就不合法了。</p>
<p>短路运算。变量初始化。全零放入bss，不全零放入data段。如果有运行期计算的值，生成运算代码放在main前执行。数组的变量初始化比较玄妙。</p>
<p><strong>IR</strong> 他们也是先生成load/store然后mem2reg pass变成SSA。前年给的建议：直接用LLVM IR。中间转LLVM IR，可以查哪里的bug，可以对比后端性能。</p>
<p>比较重要的pass：mem2reg、function inline、global value numbering、global code motion、dead code elimination。</p>
<p><strong>后端</strong> 读ARM指令集文档，庞大，先了解整体结构，整数寄存器，调用约定，控制流转移。多写一点汇编代码确认自己的理解，可以调用libc里面的函数。多用godbolt.org，如果不知道怎么做一个算术运算什么的。</p>
<p>后端首先遍历IR，生成机器指令组成的控制流图。一条IR语句不止一条机器指令。SSA destruction要处理Phi指令，前置块点的mov。</p>
<p>寄存器分配之前由于还有接近SSA的性质，有的优化会非常方便，指令合并，常量传播。spill，就是指放不下放到栈上，对spill估价的算法调了非常长的时间。寄存器分配好了可以消除mov，条件码也可以消除一些分支。</p>
<p><strong>自动化测试</strong></p>
<p>还是要搭建自动化测试，push上去等一段时间就可以回来看了。非常方便，甚至可以和gcc、llvm做对比。</p>
<p>触发：特点分支发生更新、手动触发web hook，指定commit id和命令行参数。</p>
<p>结果：一堆json，写个脚本对比效果。</p>
<p>考虑到树莓派性能，不建议把编译编译器和展示结果放到树莓派上。</p>
<p><strong>自动并行化</strong></p>
<p>把循环静态分成num_threads段，每段一个线程来跑。用汇编实现__create_threads和__join_threads函数，使用了clone、waittid、exit三个系统调用。</p>
<p>为了共用栈，所以也不能调用syscall的包装函数，所以要inline syscall。而且还要安排比较奇怪的栈布局。所以不推荐实现为公用栈。</p>
<p><strong>时间</strong> 差不多18号开始写代码，差不多写了两个月。第一个月的时候才基本能完全跑起来，前端在各种功能测试用例调通了。</p>
<h3 id="其他经验分享的笔记">其他经验分享的笔记</h3>
<p><strong>第一次分享：</strong></p>
<p>最后是反思和建议。</p>
<p>IR里最好加一层分析循环的信息。转IR后循环信息可能丢失。重视循环，循环是很重要的部分。非常需要注意循环的优化。</p>
<p>比赛前期以通过功能点为追求。复杂的寄存器分配可以先放一放，跑通为第一追求。跑通修好各种bug再去做寄存器分配。有的优化做起来非常困难，效果也不一定好。做优化之前可以先尝试手写优化后的汇编，然后运行测试一下之后的结果。本来打算做SIMD，跳转表。预期效果不是很好。</p>
<p>做好版本管理。并行化调通了，最后提交的代码没有合并进去。测试的分支上有公共bug，忘了有一个bug的修复没有合进去，忘了在哪里修的。</p>
<p>本地CI不用排队，对开发进度影响很大。JDK编译编译器，和生成文件还是要在高性能的地方跑，生成后再发给树莓派。有的测试点生成的样例特别大，最好树莓派和电脑要网线连接。1分钟编译，5分钟跑完性能。</p>
<p>GCC比LLVM复杂。他们也学习了第一届清华的Trivial compiler的设计，也学习了中科大的特等奖的设计。</p>
<p>https://www.bilibili.com/video/BV17g411d7wj</p>
<p>窥孔优化：融合乘加，临近load store指令对。复制传播，指令调度（效果不是很好），向量化（只对于非常简单的样例，效果不理想）。</p>
<p>测试和调试方面，自动化测试脚本，显示编程错误汇编错误还是执行错误。。。clang测试中间代码的正确性。。。直接生成LLVM。。。gdb调试比较重要。决赛的时候他们创建太多分支了。小组每周两次组会，交流讨论。。。</p>
<p>帮助很大的资料，engeneering a compiler，ssa book，先学习了龙书第九章。然后从虎书，鲸书学习了。</p>
<p>第二个人（ayame作者）比第一个人好多了，第一个人太水了。</p>
<p>通用向量化太难，所以还是放弃。乱序多发射的，所以想搞调度还是算了，效果不是很好。</p>
<p>有些用例是隐藏的，寄存器分配，带来了很多困难。线性扫描最后被放弃了，太复杂了，而且还没有图着色好。图着色调试起来非常困难。推荐同时写一个trivial的分配方式，比如引用计数。codegen后面保证没有bug后再调试寄存器分配。</p>
<p>虚空debug很痛苦。总结在这两个方面。gvn gcm的pass容易出错。AST翻译到中间表示的时候，选择语句if-else结构连接，写不好容易产生bug，循环控制语句，break和continue，多层嵌套翻译的时候要注意对应的是那个循环。短路运算也是问题。不规则数组初始化的时候的问题。</p>
<p>决赛两天通宵的。。。这两天主要就是尝试自动并行化。通用的很难做，后面发现可以针对常见模式的并行化，循环之间没有依赖。通宵调出来，开启之后导致其他部分又错了。。最后决赛阶段也没开启。决赛的本地CI很重要，评测卡死，要自己搭建自己的评测机子。两三个小时才能提交一次。比赛也就两天。</p>
<p>最后分享学习路线。翻译IR的时候用visitor模式，类似递归下降。用antlr的时候要改下文法，比如左递归。中层IR采用SSA，了解什么是SSA，engeneering a compiler 9.3章。SSA构建算法参考LLVM博客和代码。采用LLVM的方案，先生成mem ssa，然后mem2reg。一篇论文：simple and efficient ssa form 13年的。然后构建完会进行一些优化。最后转换成汇编，也参考engeneering a compiler 9.3章，介绍了会遇到的问题。除了转换部分，SSA的一个重点是优化算法，看论文：global code motion global code numbering. 非常强大的优化算法。采用SSA的话，看ssa-book。最后是在底层上面的一些优化，首先是armv7直接读文档，参考。armv7的坑在功能测试点会遇到，比如立即数范围不连续。代码寻址长度有限制。。。这一点在功能测试点会遇到。</p>
<p>寄存器分配会极大影响性能，通常来说，图着色和线扫。图着色可以参考一些论文，我们去年参考的是 iterator register allocating。llvm的是线性扫描的算法，有博客和youtube视频。SSA可以采取面向SSA的算法，图特殊，相比于普通的更快，效率更高。后端窥孔优化主要是人看生成的汇编，哪里可以优化，可以采取一些数据流分析。可以用GCC o3和llvm o3对比。看看他们采取了什么优化模式。</p>
<p>比赛分工：一个人负责HIR和MIR构建。两三个人负责中间代码优化。他们直接用LLVM的MIR。一到两人负责体系结构方面。体系结构上能做的优化不太多。中层优化比较多。CI搭建的问题：一个人兼职。推荐调研阶段搭好。</p>
<p>时间安排：4-5月报名，开始调研工作，完成CI。6-7月初期末考试，做些简单的东西，开始写visitor，设计中层底层架构。7月是主要工作的时间，10天完成visitor，同时完成后端翻译，寄存器分配，中间先不做，争取导出汇编，过一部分功能测试点。下旬做优化。有一些极端的场景，一个代码里几千行代码，大量debug工作。同时做优化。如果这个时候有时间还可以调研更复杂的优化。自动并行化和自动向量化。按照去年的经验特等奖需要尝试自动并行化的。决赛阶段能做的不多，主要是debug，之前没完成的优化紧急突击。</p>
<p>代码管理，非常重要，分出branch不能太多。commit 1000多次。搞好软件工程。要规范好代码提交。明确分支代表的含义。master稳定版本，develop开发版本，日常开发汇总，feature和fix。</p>
<p>合理利用tag标记版本，rebase和pull request保证history。git的常用操作，stash blame。指定命名规范。善于利用issue，发现了bug可以记录一下，修复了直接关掉非常方便。</p>
<p>自动测试的问题。测试流程分为三个部分。官方提供的gitlab平台，高性能x86服务器，运行测试用例的树莓派集群。高性能x86服务器发现CI测所有功能样例，性能样例有很长时间。尤其是编译花的时间长。编译测试半个小时。高性能服务器可以缩短为10几分钟。</p>
<p>gitlab可以触发CI，可以手动指定。gitlab runner，编译测试样例，发送到树莓派终端。树莓派结果反馈回来也给服务器给gitlab。测试数据非常大，直接放到树莓派里面，不要每次传输。好复杂。。。</p>
<p>调试的方法：去年ayami，antlr生成parser，中端翻译成LLVM IR，可以用解释器去调试。后端转LIR，寄存器分配，汇编代码gdb调试，发挥了很大作用。后端调试都是靠gdb。自动并行化，gdb可以调多线程。</p>
<p>最后是参考资料。几篇论文。</p>
<p>对性能不是很关注的测试点可以qemu进行调试。</p>
]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>换电脑-2021</title>
    <url>/2021/%E6%8D%A2%E7%94%B5%E8%84%91-2021/</url>
    <content><![CDATA[<h1 id="换电脑-2021">换电脑-2021</h1>
<p>电脑终于换上5800u了，这里记录一些换电脑系统重装与迁移的过程。</p>
<p>早就意识到QQ使用了驱动进行自我保护，这几天又出现了读取浏览记录的事件，我就感到我的电脑如果腾讯想干什么我是拦不住的。从此就计划新电脑一定要24小时跑一个虚拟机，用来装这些流氓软件。</p>
<p>具体的方案是家庭版安装hyper-v，然后外部通过windows远程桌面连进去。现在用了快一个多月，还挺不错的，CPU占用也不高。唯一的缺点是内部启动腾讯会议，会使用CPU而不是显卡处理视频，CPU占用较高。</p>
<span id="more"></span>
<h2 id="第一季">第一季</h2>
<h2 id="新机处理">新机处理</h2>
<ol type="1">
<li>处理任务栏，改成小任务栏，开始菜单全部unpin，考虑托盘图标全部显示</li>
<li>windows 更新，BIOS更新</li>
<li>安装7-zip</li>
<li><strong>禁用Windows搜索</strong> - DISM++</li>
<li><strong>禁用Windows错误收集</strong> - DISM++</li>
<li><strong>禁用windows defender</strong> - defender control - 不使用任何杀毒软件</li>
<li>禁用各种托盘图标</li>
<li>安装组策略，hyper-v，WSL2</li>
<li>管理员账号配置，hyper-v的win虚拟机</li>
</ol>
<h2 id="hyper-v-安装win-ame">hyper-v 安装win-AME</h2>
<p>explorer要等很久才显示，关闭增强会话，登录之后发送ctrl-alt-delete然后就可以启动cmd了。等了好久好久才打开了桌面。。。</p>
<ol type="1">
<li><p>按照说明换壁纸</p></li>
<li><p>直接给默认用户加到管理员组去了。然后重启，uac设置always notify。</p></li>
</ol>
<h2 id="默认电脑增加管理员用户">默认电脑增加管理员用户</h2>
<p>去控制面板，而不是windows设置。增加用户，设置类型，一气呵成。</p>
<p>可能要重启才能完全生效吧？确实是这样。直接设置可能token还是旧的权限。</p>
<p>密码改成一个空格吧，不，直接改成空密码。算了，还是改成空格。</p>
<h2 id="rdp连接qq微信">RDP连接QQ微信</h2>
<p>虚拟机内IP会变？？最关键的是网关和虚拟机ip不在一个网段。。。增加一个新网卡吧</p>
<p>不用啥dhcp了，自己配一个ip吧。</p>
<p>https://github.com/kimmknight/remoteapptool 新建一个bat，start 微信和qq，作为application的目标。application mode和标准模式不能共存。也就是说如果想要同时拿它做什么的话就还是老实地放弃appMode吧。</p>
<p>另外要增加输入法啊，不然不能打字的。。。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$List</span> = <span class="built_in">New-WinUserLanguageList</span> en<span class="literal">-US</span></span><br><span class="line"><span class="variable">$List</span>.add(<span class="string">&quot;zh-CN&quot;</span>)</span><br><span class="line"><span class="built_in">Set-WinUserLanguageList</span> <span class="variable">$List</span></span><br></pre></td></tr></table></figure>
<p>另外就是微信的托盘图标完全是摆设，无响应。QQ的托盘图标悬浮无法弹出框，可以右键，双击。</p>
<hr />
<p>发现就算是普通的非APP模式也还行，单独放一个桌面，远程桌面的时候选择win键相关的快捷键保留在主机，这样直接Ctrl+Win+方向键直接切换桌面。缺点是虚拟机那边缺失了Win+X这样的快捷键。</p>
<p>确实不错。电脑关机虚拟机自动暂停，开机自动恢复，我只要想用的时候双击rdp连过去就好了。消息要听提示音了。</p>
<h2 id="视频通话的延迟">视频通话的延迟</h2>
<p>开启RemoteFX试试。RDP两边都开启。</p>
<p>主机（RDP客户端）：组策略：计算机配置—管理模板—Windows 组件—远程桌面服务—远程会话客户端—RemoteFX设备重定向。允许管理员和用户</p>
<p>虚拟机（RDP服务端）：组策略：计算机配置—管理模板—Windows 组件—远程桌面服务—远程会话环境—RemoteFX for Windows Server 2008 R2 -- 启用第一个</p>
<p>重启试试</p>
<h2 id="非管理员无法调整屏幕和显卡">非管理员无法调整屏幕和显卡</h2>
<p>屏幕刷新率省电和igpu模式在非管理员的armoury crate这个rog的控制面板里消失。。。</p>
<p>用runas命令运行也不行</p>
<h2 id="窗口半屏总会在另外一边弹出选框">窗口半屏总会在另外一边弹出选框</h2>
<p>设置-系统-多任务处理-贴靠窗口-将窗口对齐的时，显示能够在其旁边对齐的内容 关闭它。</p>
<h2 id="第二季度">第二季度</h2>
<ol type="1">
<li><p>使用下面命令准备系统：然后直接移动硬盘过去。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="variable">%windir%</span>\system32\sysprep\sysprep.exe /generalize /oobe /shutdown</span><br></pre></td></tr></table></figure></li>
</ol>
<p>出现问题：</p>
<ol type="1">
<li>为单个用户安装的appx会造成问题，先卸载</li>
<li>千万要先把微软账户退出改用本地账号啊！！！不然被微软联网登录卡得进不去账号</li>
<li>电脑真的第一次开机要保证不能换任何配件！才能激活。激活之后再换。</li>
</ol>
<p>导入hyper-v的时候先建立起同名网卡再导入。</p>
<p>TODO:</p>
<ol type="1">
<li>如何把旧电脑的微信qq聊天记录导入过去？</li>
</ol>
<h3 id="网络问题">网络问题</h3>
<p>onenote和todo的网络问题还是需要代理，这个需要network isolation设置，然后挂全局代理解决</p>
<p>而现在遇到各种网络问题反而是DNS问题。</p>
<ol type="1">
<li>使用默认DNS想要登录微软账号有问题</li>
<li>使用微软DNS上普通网站非常卡。</li>
<li>前段时间发现禁用ipv6后就能上简书和知乎了。</li>
</ol>
<p>考虑像我的switchy-omega脚本一样，对黑白名单设置对应的DNS。微软部分网站使用微软dns，其他网站都用本地DNS吧。不，这样太麻烦了，维护成本也高。</p>
<p>我就设置一个方便迅速切换的脚本吧。</p>
<ol type="1">
<li>获取当前默认路由的网卡</li>
<li>设置网卡的DNS地址</li>
</ol>
<p>另外现在ipv4已经耗尽，可以拿到完整的ipv4-地区数据。</p>
<h3 id="hp-audio-自动安装chrome插件">hp audio 自动安装chrome插件</h3>
<p>chrome显示被组织管理了。在chrome://policy/页面可以看到，是设置了对应位置的注册表导致的。</p>
<ol type="1">
<li><p>在https://4sysops.com/archives/audit-changes-in-the-windows-registry/#activate-registry-auditing 如何监控注册表的修改 添加审计规则。在event viewer里的security里filter事件id：4657,4660</p>
<p><code>Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome\ExtensionInstallForcelist</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A registry value was modified.</span><br><span class="line"></span><br><span class="line">Subject:</span><br><span class="line">	Security ID:		SYSTEM</span><br><span class="line">	Account Name:		DESKTOP-BDMA890$</span><br><span class="line">	Account Domain:		WORKGROUP</span><br><span class="line">	Logon ID:		0x3E7</span><br><span class="line"></span><br><span class="line">Object:</span><br><span class="line">	Object Name:		\REGISTRY\MACHINE\SOFTWARE\Policies\Google\Chrome\ExtensionInstallForcelist</span><br><span class="line">	Object Value Name:	317</span><br><span class="line">	Handle ID:		0x240</span><br><span class="line">	Operation Type:		New registry value created</span><br><span class="line"></span><br><span class="line">Process Information:</span><br><span class="line">	Process ID:		0x169c</span><br><span class="line">	Process Name:		C:\Windows\System32\SECOMN64.exe</span><br><span class="line"></span><br><span class="line">Change Information:</span><br><span class="line">	Old Value Type:		-</span><br><span class="line">	Old Value:		-</span><br><span class="line">	New Value Type:		REG_SZ</span><br><span class="line">	New Value:		jjnlfodbdchgijlheopgehgnmekbndmf;https://clients2.google.com/service/update2/crx</span><br></pre></td></tr></table></figure>
<p>everything搜索exe发现是驱动附带的程序，在任务管理器里看是SECOMNService 服务的。</p>
<p><code>C:\Windows\System32\DriverStore\FileRepository\seapo64.inf_amd64_057f6b28338feed1</code></p></li>
<li><p>psexec64.exe -s cmd.exe</p>
<p>sc config SECOMNService start= disabled</p>
<p>先禁用看看会不会影响什么。</p>
<p>看了看这个exe，没看到相关的设置逻辑啊，只有一个SEMISCAPI_IsBrowserExtensionInstalled的字符串。。。但是找不到引用。。。</p></li>
</ol>
]]></content>
      <categories>
        <category>Digi</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>自制Ollvm</title>
    <url>/2021/%E8%87%AA%E5%88%B6Ollvm/</url>
    <content><![CDATA[<h1 id="自制ollvm">自制Ollvm</h1>
<p>原本网上没有多少开源的代码混淆器，现在却发现学习OLLVM的人特别多，很多人也有自己的混淆器。</p>
<p>汇编的混淆和LLVM还是挺有意思的。虽然这个项目的进度依然停滞在只学完简单运算混淆的地步，但有时间我应该会回来继续。</p>
<span id="more"></span>
<p>ollvm/armariris/hikari 三个一起学习. <a href="https://www.leadroyal.cn/?p=1072">ollvm/armariris/hikari 适配llvm10</a></p>
<p>http://mayuyu.io/ 这里有很多关于llvm的</p>
<p>https://iosre.com/t/llvm/10610/39 实现字符串加密</p>
<p>llvm提供了很方便地操作二进制代码的api. 自己移植不一定有利于学习, 移植主要解决的是llvm版本更新的各种杂七杂八的变化, 反而那些主要的逻辑不要求理解.</p>
<p>既然是学习，就好好以LLVM的字节码为基础，而不是看最终的机器码汇编了。</p>
<p>计划: 1. 作为使用者, 使用这几个代码混淆器, 成功编译混淆代码(使用移植好到llvm10的代码) 2. 作为开发者, 学习混淆的原理, 学习代码编写的思路, 熟悉llvm的api. 3. 开始考虑混淆的对策</p>
<p>TODO: 1. 如何自己打开自己的 2. 找合适的软件或者片段，调用我的ollvm。 3. 可视化、或者如何方便查看llvm字节码，甚至生成的机器码</p>
<p>和godbolt结合可视化。</p>
<p>TODO:</p>
<ol type="1">
<li>学习llvm中的Annotation</li>
<li>编译debug版本，配好调试环境，方便gdb源码调试</li>
<li>分析opt怎么通过RegisterPass<HelloPass>增加的命令行选项。看看clang是怎么管理和加载Pass的。</li>
<li>探索Windows下llvm的pass的现状</li>
<li>改下代码格式化的格式，看看怎么把大括号不单独起一行。</li>
<li>指令替换方面把llvm的全加进来，改用llvm的随机化函数。</li>
<li>学学C++的匿名函数的具体原理。闭包，捕获什么的具体规则和实现</li>
</ol>
<p>[toc]</p>
<h2 id="杂谈">杂谈</h2>
<p>-m64 选项生成64位的代码，但是int还是32位大小的。long才是64位大小的。似乎没有选项能让int变成64位大小的。而main函数的返回值因此也是32位的</p>
<p>读取函数的Annotation上，ollvm可能还是比较猛的？搜<code>llvm readAnnotate</code> 炸出一大片分析ollvm的。</p>
<h2 id="常用的命令">常用的命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opt -load lib/LLVMHello.so -help</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opt -load lib/LLVMHello.so -hello &lt; hello.bc &gt; out.bc</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clang -Xclang -load -Xclang Obfuscation.dll</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clang -c -emit-llvm $1.c #生成bc</span><br><span class="line">clang -S -emit-llvm $1.c #生成.ll的文本形式</span><br></pre></td></tr></table></figure>
<h2 id="如何编写pass">如何编写pass</h2>
<p>要运行的代码是 https://github.com/LeadroyaL/llvm-pass-tutorial , 这里每个项目是单独的文件夹. 三个项目合在一起, 共用外面的cmake文件. 为了明白这个移植怎么跑起来, 学习源码外的pass项目的建立. 先学下面的项目, 配置好路径. <a href="https://github.com/abenkhadra/llvm-pass-tutorial">pass-skeleton</a></p>
<p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">如何写一个pass llvm.org</a> 确实, 写一个pass就真的是一个pass, 出来一个so文件, 在passmanager里过一遍llvm bytecode. pass的加载和运行暴露在命令行选项.</p>
<ol type="1">
<li>pass项目可以单独在源码外</li>
</ol>
<p>编译的时候需要在 <code>[LLVM_DIR]</code> 找到llvm的配置. 该项目骨架会通过 <code>$LLVM_HOME</code> 环境变量设置好 <code>[LLVM_DIR]</code> 编译出来可以使用opt直接运行pass. 也可以clang编译的时候指定opt加载这个so文件, 然后加上调用so的选项.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-7.0 -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c$</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>pass项目在llvm源码内</li>
</ol>
<p>可以像他们几个项目一样直接在llvm-project源码内的 <code>/lib/Transform</code> 修改. 并且修改默认加载这个pass, 只需要给出使用的选项.</p>
<h3 id="源码外的pass">源码外的pass</h3>
<p><a href="http://llvm.org/docs/CMake.html#developing-llvm-passes-out-of-source">Developing LLVM passes out of source</a></p>
<p>LLVM_HOME 应该是 <code>/usr/lib/llvm-10</code>, 这样就会设置LLVM_DIR为 <code>/usr/lib/llvm-10/lib/cmake/llvm</code> LLVM_DIR里面有LLVMConfig.cmake, 设置了这个环境变量, cmake中调用 <code>find_package(LLVM REQUIRED CONFIG)</code> 就可以找到llvm作为一个cmake的library</p>
<p>为了构建源码外的pass, 重要的cmake语句有 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line">project(llvm-pass-tutorial)</span><br><span class="line"></span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br><span class="line">add_subdirectory(ollvm)  # ollvm</span><br><span class="line">add_subdirectory(Hikari)  # Hikari</span><br><span class="line">add_subdirectory(Armariris)  # Armariris</span><br></pre></td></tr></table></figure> 在每个文件夹内的CMakeList里调用 <code>add_library</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(Armariris MODULE</span><br><span class="line">        # List your source files here.</span><br><span class="line">        CryptoUtils.cpp</span><br><span class="line">        StringObfuscation.cpp</span><br><span class="line">        Substitution.cpp</span><br><span class="line">        Flattening.cpp</span><br><span class="line">        Utils.cpp</span><br><span class="line">        include/Transforms/Obfuscation/Flattening.h</span><br><span class="line">        include/Transforms/Obfuscation/StringObfuscation.h</span><br><span class="line">        include/Transforms/Obfuscation/Substitution.h</span><br><span class="line">        include/Transforms/Obfuscation/Utils.h</span><br><span class="line">        Enter.cpp</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p>
<h3 id="行动">行动</h3>
<p>为了避免编译llvm. 我采用直接apt安装的方式安装llvm, 源码外建立pass项目. 好像安装了llvm-dev 安装后在 <code>/usr/lib/llvm-10</code> 附近有各种编译头文件</p>
<p>在<code>project(llvm-pass-tutorial)</code>之后加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(ENV&#123;LLVM_HOME&#125; /usr/lib/llvm-10)</span><br></pre></td></tr></table></figure>
<h3 id="pass的集成">pass的集成</h3>
<p>我想知道如何无缝集成到clang。</p>
<p>新的passmanager能更细粒度地控制Pass之间的互斥关系。每一个函数都返回了对应invalidate了的其他pass。还没迁移过去。所以可能还是legacy的PM多一些，clang应该还是吧。而legacy的PM，这两种注册方法中</p>
<ol type="1">
<li><p>要有一个ID，初始值不重要，因为是根据ID的地址区别各个函数的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char Hello::ID = 0;</span><br></pre></td></tr></table></figure></li>
<li><p>注册pass，得到一个命令行。这里是通过构造函数注册的，我们只需要初始化一个类。这种方法似乎只对opt有效？？当有这个选项的时候我们的pass才会被加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;,</span><br><span class="line">                             false /* not modify CFG */,</span><br><span class="line">                             false /* pure Analysis Pass */);</span><br></pre></td></tr></table></figure>
<p>这种方法会注册到全局的passRegistry里面。TODO：探索何时被注册了命令行选项。</p></li>
<li><p>加载时自动注册，这里用的是匿名函数，我们可以写一个函数。这种方法对opt无效。对<code>clang -Xclang -load -Xclang Obfuscation.dll</code> 有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static RegisterStandardPasses Y(</span><br><span class="line">    PassManagerBuilder::EP_EarlyAsPossible,</span><br><span class="line">    [](const PassManagerBuilder &amp;Builder,</span><br><span class="line">       legacy::PassManagerBase &amp;PM) &#123; PM.add(new Hello()); &#125;);</span><br></pre></td></tr></table></figure>
<p>TODO：研究原理。它会先调用PassManagerBuilder::addGlobalExtension，这个函数则是Transform/IPO里的，它把<code>std::make_tuple(Ty, std::move(Fn), ExtensionID)</code> 放到GlobalExtensions这个static全局Vector里面。最终是populateFunctionPassManager这里把注册的这些东西放进FPM的</p>
<p>怀疑可能这里把我们的Pass放进内部统一的“Pass数据库”里了，opt根据数据库生成命令行选项，每个选项对应一个Pass的启用和关闭。</p></li>
<li><p>命令行选项，加载后通过参数更详细地控制pass</p>
<p>https://stackoverflow.com/questions/13626993/is-it-possible-to-add-arguments-for-user-defined-passes-in-llvm</p>
<p>https://llvm.org/docs/CommandLine.html#commandline-2-0-library-manual</p>
<p>使用commandline api: ​cl::opt。这个工具是完全独立于llvm的，可以拿出来自己用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  cl::<span class="built_in">ParseCommandLineOptions</span>(argc, argv);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它负责初始化全局变量，选项都反映在全局变量里。因此和opt、clang是否加载使用我们的pass没有关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static cl::opt&lt;int&gt;</span><br><span class="line">ObfProbRate(&quot;bcf_prob&quot;, cl::desc(&quot;Choose the probability [%] each basic blocks will be obfuscated by the -bcf pass&quot;), cl::value_desc(&quot;probability rate&quot;), cl::init(defaultObfRate), cl::Optional);</span><br></pre></td></tr></table></figure>
<p>表示解析一个int类型的命令行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cl::opt&lt;RegisterMyPasses::FunctionPassCtor, <span class="literal">false</span>,</span><br><span class="line">        RegisterPassParser&lt;RegisterMyPasses&gt; &gt;</span><br><span class="line"><span class="built_in">MyPassOpt</span>(<span class="string">&quot;mypass&quot;</span>,</span><br><span class="line">          cl::<span class="built_in">init</span>(&amp;createDefaultMyPass),</span><br><span class="line">          cl::<span class="built_in">desc</span>(<span class="string">&quot;my pass option help&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>llvm::cl::opt&lt; DataType, ExternalStorage, ParserClass &gt;</strong> 这里的cl初始化，声明了一个自定义parser，parser返回的结果是RegisterMyPasses类型的命令行选项。</p></li>
<li><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html#id47">Registering dynamically loaded passes</a></p></li>
<li></li>
</ol>
<h3 id="ubuntu的pass测试">ubuntu的pass测试</h3>
<p>为了方便地测试pass，方便地看到结果。输入是c语言的程序，输出pass前和pass后的llvm ir。</p>
<p>使用makefile文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.ll: %.c</span></span><br><span class="line">	clang -S -emit-llvm <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.obf.ll: %.ll</span></span><br><span class="line">	opt -stats -S -load ../build/myobf/libmyobf.so -hello <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<h2 id="llvm的annotation">LLVM的Annotation</h2>
<h3 id="资料搜寻">资料搜寻</h3>
<p>https://groups.google.com/g/llvm-dev/search?q=llvm.global.annotations</p>
<p>https://groups.google.com/g/llvm-dev/c/IiuO8EOM6dI/m/nQdjQ1qOYIgJ</p>
<p>通过google groups搜索mailing list，最终找到了用法的讨论。在08年的时候有个AnnotationManager，之后被删掉了。2020年11月最近似乎增加了!annotate的新用法，对旧的__attribute__((annotate)) 用法可能也做了什么处理？</p>
<p>有些东西可能真的就没有文档。。。？？仔细学习后我发现我的想法错了，可能只是因为用法没有什么特殊的地方，所以不需要单独成文档。最后只是靠看各种其他文档弄懂的，llvm的mailing list反而用处不大。</p>
<p>主要靠的是：llvm的struct、array类型，getElementPtr指令（复杂结构体的地址计算指令），bitcast指令（类似强制类型转换）</p>
<h3 id="ir解析">IR解析</h3>
<p>tl;dr 全局变量，包括函数的Annotation被放在llvm.global.annotations这个全局变量里。局部变量、函数参数的annotation会产生对<a href="https://llvm.org/docs/LangRef.html#llvm-var-annotation-intrinsic">llvm.var.annotation</a>这个函数的call指令，相关信息放在函数参数里。</p>
<p>数组类型为<code>&#123; i8*, i8*, i8*, i32 &#125;</code>，类似于<code>&#123;char*, char*, char*, int&#125;</code> 依次为 函数地址、annotation字符串地址、源码文件名、源码内的行号。</p>
<p>对参数的annotate会转化为有内存空间的局部变量，然后对内存空间annotate。此外，因为每个函数的局部空间是通过alloca指令分配的，所以llvm.var.annotation的第一个参数会指向分配的内存空间内部。局部变量的变量名会丢失。</p>
<p>可能通过Debug_info能够找回局部变量名？增加-g选项后生成的ll文件内确实会增加dwarf4信息。会通过<code>call void @llvm.dbg.declare(metadata i32* %2, metadata !14, metadata !DIExpression()), !dbg !15</code>的方式声明局部变量，需要分析一下变量。通过<code>!llvm.module.flags</code> 可以判断是否开启了debug。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Annotation.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a __attribute__((annotate((<span class="string">&quot;hello1&quot;</span>)))) = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> __attribute__((annotate((<span class="string">&quot;hello2&quot;</span>)))) c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> c + <span class="number">41</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">d</span><span class="params">(<span class="type">int</span> e)</span> __<span class="title function_">attribute__</span><span class="params">((annotate((<span class="string">&quot;hello&quot;</span>))))</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> e + <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; ModuleID = &#x27;Annotation.c&#x27;</span></span><br><span class="line">source_filename <span class="operator">=</span> <span class="string">&quot;Annotation.c&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">triple</span> <span class="operator">=</span> <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title">@a</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@.str</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">7</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;hello1<span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">section</span> <span class="string">&quot;llvm.metadata&quot;</span></span><br><span class="line"><span class="title">@.str.1</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Annotation.c<span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">section</span> <span class="string">&quot;llvm.metadata&quot;</span></span><br><span class="line"><span class="title">@.str.2</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">7</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;hello2<span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">section</span> <span class="string">&quot;llvm.metadata&quot;</span></span><br><span class="line"><span class="title">@.str.3</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">6</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;hello<span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">section</span> <span class="string">&quot;llvm.metadata&quot;</span></span><br><span class="line"><span class="title">@llvm.global.annotations</span> <span class="operator">=</span> <span class="keyword">appending</span> <span class="keyword">global</span> [<span class="number">2</span> <span class="keyword">x</span> &#123; <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i32</span> &#125;] [&#123; <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i32</span> &#125; &#123; <span class="type">i8</span>* <span class="keyword">bitcast</span> (<span class="type">i32</span>* <span class="title">@a</span> <span class="keyword">to</span> <span class="type">i8</span>*)<span class="punctuation">,</span> <span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">7</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">7</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>)<span class="punctuation">,</span> <span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>)<span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span> &#125;<span class="punctuation">,</span> &#123; <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i32</span> &#125; &#123; <span class="type">i8</span>* <span class="keyword">bitcast</span> (<span class="type">i32</span> (<span class="type">i32</span>)* <span class="title">@d</span> <span class="keyword">to</span> <span class="type">i8</span>*)<span class="punctuation">,</span> <span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">6</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">6</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>)<span class="punctuation">,</span> <span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>)<span class="punctuation">,</span> <span class="type">i32</span> <span class="number">10</span> &#125;]<span class="punctuation">,</span> <span class="keyword">section</span> <span class="string">&quot;llvm.metadata&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@b</span>(<span class="type">i32</span> <span class="variable">%0</span>) <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">bitcast</span> <span class="type">i32</span>* <span class="variable">%2</span> <span class="keyword">to</span> <span class="type">i8</span>*</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.var.annotation</span>(<span class="type">i8</span>* <span class="variable">%3</span><span class="punctuation">,</span> <span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">7</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">7</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>)<span class="punctuation">,</span> <span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span>)<span class="punctuation">,</span> <span class="type">i32</span> <span class="number">5</span>)</span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%5</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="keyword">nsw</span> <span class="type">i32</span> <span class="variable">%4</span><span class="punctuation">,</span> <span class="number">41</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: nounwind willreturn</span></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@llvm.var.annotation</span>(<span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i32</span>) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@d</span>(<span class="type">i32</span> <span class="variable">%0</span>) <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="keyword">nsw</span> <span class="type">i32</span> <span class="variable">%3</span><span class="punctuation">,</span> <span class="number">42</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>llvm.global.annotations的声明中，最开头的<code>[2 x &#123; i8*, i8*, i8*, i32 &#125;]</code>是类型，紧接着的是主体，ConstantExpr，最末尾是section说明<code>, section "llvm.metadata"</code>。</p>
<p>而ConstantExpr部分就利用bitcast把函数类型转换成i8*类型<code>bitcast (i32* @a to i8*)</code>，再<code>getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i32 0, i32 0)</code>。</p>
<h3 id="pass中的解析方法">Pass中的解析方法</h3>
<p>首先获取Module级别的全局变量 llvm.global.annotations</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GlobalVariable *glob =</span><br><span class="line">      f-&gt;getParent()-&gt;getGlobalVariable(&quot;llvm.global.annotations&quot;);</span><br></pre></td></tr></table></figure>
<p>得到全局变量的初始值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConstantArray *ca = dyn_cast&lt;ConstantArray&gt;(glob-&gt;getInitializer())</span><br></pre></td></tr></table></figure>
<p>这是一个数组类型，先进行遍历，长度是<code>ca-&gt;getNumOperands()</code>，取下标使用<code>ca-&gt;getOperand(i)</code>。取了后得到ConstantStruct。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConstantStruct *structAn = dyn_cast&lt;ConstantStruct&gt;(ca-&gt;getOperand(i))</span><br></pre></td></tr></table></figure>
<p>这就是<code>&#123; i8*, i8*, i8*, i32 &#125;</code>结构体，使用<code>structAn-&gt;getOperand(0)</code>这样的方法取0-3的下标得到成员。其中前三个取出来都是ConstantExpr：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConstantExpr *expr = dyn_cast&lt;ConstantExpr&gt;(structAn-&gt;getOperand(0))</span><br><span class="line">ConstantExpr *note = cast&lt;ConstantExpr&gt;(structAn-&gt;getOperand(1));</span><br></pre></td></tr></table></figure>
<p>第一个基本上都是bitcast</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr-&gt;getOpcode() == Instruction::BitCast </span><br><span class="line">expr-&gt;getOperand(0)是Function类型</span><br></pre></td></tr></table></figure>
<p>第二第三个都是getElementPtr，然后先获取GlobalVariable类型的字符串，再获取Initializer得到真正的字符串内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">note-&gt;getOpcode() == Instruction::GetElementPtr</span><br><span class="line">GlobalVariable *annoteStr = dyn_cast&lt;GlobalVariable&gt;(note-&gt;getOperand(0))</span><br><span class="line">ConstantDataSequential *data = dyn_cast&lt;ConstantDataSequential&gt;(annoteStr-&gt;getInitializer())</span><br><span class="line">if (data-&gt;isString()) &#123; annotation += data-&gt;getAsString().lower() + &quot; &quot;; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="annotationhello-在pass中读取annotation实例">AnnotationHello 在Pass中读取Annotation实例</h3>
<p>继承一个ModulePass，对每个模块解析一次Annotation。</p>
<p>继承一个FunctionPass函数，在第一个基本块内解析Annotation。</p>
<p>TODO：能否（简单地）一个命令行开启两个Pass？呃，那个Register决定opt是否启用，而</p>
<h2 id="windows平台下的混淆visual-studio-配置使用pass">Windows平台下的混淆：visual studio 配置使用pass</h2>
<p>经过查阅资料, 没找到, 不能android一样, <a href="https://stackoverflow.com/questions/48947973/use-llvm-in-a-cmake-build">重新编译才能得到cmake库</a> 编译后将build文</p>
<p>在Windows平台编译不是一个简单的问题，需要各种支持。现在虽然难，但似乎有人成功了。</p>
<p>安装了tdm-Gcc之后用如下的选项编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_EXPORT_SYMBOLS_FOR_PLUGINS=On ..\llvm</span><br></pre></td></tr></table></figure>
<p>出现报错，说</p>
<p>cant close file too big</p>
<p>改设置上一些其他的选项试试，看看能不能好一点。可能只能编译release版本的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_EXPORT_SYMBOLS_FOR_PLUGINS=On -DLLVM_INCLUDE_TESTS=Off DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; -DCMAKE_BUILD_TYPE=Release ..\llvm</span><br></pre></td></tr></table></figure>
<p>时间过于漫长，我把环境变量里面的clang提前了，不行的话看看能不能clang自己编译自己。</p>
<p>TODO 描述编译经历</p>
<ol type="1">
<li>坚持使用MSVC编译，使用MSVC自带的开发控制台的x64 native tools</li>
<li>使用上面的方法后，即使用Ninja生成器，不加-hHost=x64，也能正确用上64位的toolchain好像</li>
<li>源码内pass比源码外pass更容易配</li>
</ol>
<p>现在是windows平台，in source编写pass。如果做成DLL，则不能集成进clang里，这样visual studio不好调用。</p>
<h3 id="编写混淆pass">编写混淆pass</h3>
<ol type="1">
<li><p>自己编写的pass编译成dll之后是否只能通过opt运行？不能通过clang自动运行？</p>
<p><a href="https://www.cs.cornell.edu/~asampson/blog/clangpass.html">这里</a> 其实是一种挺Hack的方法，让组件加载dll/so的时候去注册，我在windows上这样加载LLVMHello.dll 会报错 <code>动态链接库(DLL)初始化例程失败。 (0x45A)</code></p>
<p>首先写一个bat自动化进行编译成中间代码和使用pass的过程。</p>
<p>一种方法是源码内编写pass，直接修改相关代码加载pass，这种方法其实挺不容易的，我首先在clang的一些cmakelist里加入了Hello链接进去，但是似乎还是需要注册？需要继续深入了解研究看看源码，看问题4 <a href="https://medium.com/@mshockwave/writing-llvm-pass-in-2018-part-iv-d69dac57171d">内置的方法</a></p>
<p>否则即使在源码内编写，也出来的是动态库，还是只能opt加载。。。</p></li>
<li><p>头文件缺失的问题怎么解决？visual studio是怎么编译的？</p>
<p>visual studio 最近有了llvm支持。而我自己编译的llvm是没有基本的C++头文件的。用微软的安装包安的clang也是一样，所以可能是手动添加了include路径？</p></li>
<li><p>llvm的pass是如何注册命令行选项的？怎样编译成dll，又如何不出dll而是内置到clang里？</p>
<p>想要内置考虑可以通过<a href="https://llvm.org/docs/WritingAnLLVMPass.html#building-pass-plugins">llvm plugin</a>。是否编译成dll和Transform里的自己的pass的CmakeList里的add_llvm_library 里是否加上Module参数有关系。加上就是动态链接，不加上就是静态链接出来。</p></li>
<li><p>Transform的那些pass是怎么加载进clang里的？</p>
<p>lib/CodeGen/CMakeList.txt</p>
<p>tools/driver/CMakeList.txt</p>
<p>这两个地方有clang会link进去的东西。</p>
<p>要去掉自己的MODULE BUILDTREE_ONLY</p>
<p>我编译进去了，但是好像不太行。。</p>
<p>好像要在IPO的PassManagerBuilder::populateFunctionPassManager/populateModulePassManager</p>
<p><a href="https://medium.com/@mshockwave/writing-llvm-pass-in-2018-part-iv-d69dac57171d">内置的方法</a></p></li>
<li><p>bytecode转可执行文件？</p>
<p>可以直接clang编译成可执行文件 <a href="https://blog.csdn.net/pc153262603/article/details/89553688">来源</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clang a.o.bc -o struct</span><br></pre></td></tr></table></figure>
<p>首先llc编译成S的汇编文件，再用gcc什么的生成可执行文件 <a href="https://stackoverflow.com/questions/32523847/how-to-make-llvm-bc-file-executable">来自</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">llc -filetype=obj hello.bc -o hello.o</span><br><span class="line">llc hello.bc -o hello.s</span><br><span class="line">gcc hello.o/s -o hello</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="pass与clang的集成">PASS与Clang的集成</h2>
<h3 id="案例-ollvm做出的修改">案例: ollvm做出的修改</h3>
<p>以下是ollvm4.0和llvm4.0进行对比的不同的文件. 来自<a href="https://magic-king.net/2020/02/27/ollvm-learning/">这里</a> 使用<a href="https://truehumandesign.se/s_diffinity.php">Diffinity</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./include/llvm/Transforms/Obfuscation/ # obfuscation的头文件</span><br><span class="line">./include/llvm/Transforms/CryptoUtils.h # obfuscation的头文件</span><br><span class="line">./lib/Transforms/IPO/LLVMBuild.txt</span><br><span class="line">./lib/Transforms/IPO/PassManagerBuilder.cpp # Pass注册</span><br><span class="line">./lib/Transforms/Obfuscation/ # obfuscation source code</span><br><span class="line">./lib/Transforms/CMakeLists.txt</span><br><span class="line">./lib/Transforms/LLVMBuild.txt</span><br><span class="line">./tools/clang # 集成clang,要在gitignore里取消clang的注释</span><br><span class="line">./.gitignore</span><br><span class="line">./CMakeLists.txt</span><br><span class="line">./CODE_OWNERS.TXT</span><br><span class="line">./LICENSE.TXT</span><br></pre></td></tr></table></figure>
<h2 id="ollvm-实现分析">OLLVM 实现分析</h2>
<h3 id="概述">概述</h3>
<ol type="1">
<li><strong>Instruction substitution:</strong> 将加减与或异或这几个指令通过数学方式变成更复杂但等效的计算。</li>
<li><strong>Bogus Control Flow</strong> 将一个基本块的入口加上虚假分支语句，不会执行的分支指向虚假代码。再在出口加上虚假分支，不会执行的分支指向虚假代码，最后将虚假基本块的出口指向真实基本块，构成类似循环的结构。</li>
<li><strong>Control Flow Flattening</strong> 把整个函数的控制流都收到路由变量和分发块的逻辑里来，类似于switch case。（是不是可以直接做源码级的混淆）更进一步，可以让CRC代码完整性检查的结果参与进来，这样如果代码的CRC不对，就直接影响跳转的逻辑。（但是只有在完全编译链接生成最终的可执行文件的时候才能确定CRC。而如果CRC检查部分的代码是相互依赖的（检查到其他检查部分的代码），则还需要解决依赖关系（利用CRC的线性代数的线性性质））</li>
<li><strong>Basic-block splitting</strong> 这是什么？直接增加虚假分支和基本块？</li>
<li><strong>Code Tamper-Proofing</strong> 有多个check例程，往正常逻辑中插入对它的调用，然后检查值对不对。通过融合进控制流的方法，如果CRC不对的话则之后不会跳转到正确的基本块。</li>
<li><strong>Procedures Merging</strong> 将多个函数合并成一个merged函数，第一个参数用来判断调用的是哪个函数，通过switch case调用对应的函数。原来的函数被wrapper函数替代，使用varg技术像，merged函数提供正确的参数，再跳转到对应的函数。（如果能在链接时处理，则甚至不需要wrapper函数，而是修改每个调用前push参数的过程增加调用号。）merged函数被其他混淆（如控制流平坦化）处理后能大幅增加抗分析能力。此外这种方法还能防止不分析的情况下直接重用汇编的攻击。</li>
</ol>
<p>未来的方向： 特定于平台的反调试代码，对密码学常量和字符串的混淆，代码水印技术</p>
<h3 id="instruction-substitution">Instruction substitution</h3>
<p>指令替换是最简单的。对于加减与或 异或这五种运算，分别有多种替换方法，ollvm随机选一个替换。增加的命令行选项是每个函数替换多少遍。第一遍替换的是原始的指令，后面每次替换的就是混淆后的指令了，通过反复替换增加复杂度。</p>
<p>这个pass明显需要放在优化pass之后。如何让自己的pass在优化后运行？ 可以考虑opt过了pass之后，编译的时候就用 -O0 ?</p>
<p>继承Funcpass的Substitution有几个函数指针数组，在初始化的时候把自己的成员函数填进去，之后通过随机数产生器随机调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Function::iterator bb = tmp-&gt;<span class="built_in">begin</span>(); bb != tmp-&gt;<span class="built_in">end</span>(); ++bb) &#123;</span><br><span class="line">  <span class="keyword">for</span> (BasicBlock::iterator inst = bb-&gt;<span class="built_in">begin</span>(); inst != bb-&gt;<span class="built_in">end</span>(); ++inst) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inst-&gt;<span class="built_in">isBinaryOp</span>()) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (inst-&gt;<span class="built_in">getOpcode</span>()) &#123;</span><br><span class="line">      <span class="keyword">case</span> BinaryOperator::Add:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BinaryOperator::Sub:</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>
<p>真正核心的替换函数，参数只是那个指令<code>BinaryOperator *bo</code>。</p>
<figure>
<img src="image-20200928135000792.png" alt="image-20200928135000792" /><figcaption aria-hidden="true">image-20200928135000792</figcaption>
</figure>
<p>addNeg：增加一个Neg指令，把加法变成减法。addDoubleNeg同理。</p>
<p>精髓在于BinaryOperator::Create的方法的最后一个参数是InsertBefore，这样按顺序插入到那个指令前面，最后的时候再对原来的指令调用replaceAllUsesWith，用最后生成的指令去替换它就好了。意味着用最后一个指令产生的值去替换它产生的值。</p>
<p>binaryOperator成员如下，rem是取余数的运算符 <a href="https://llvm.org/docs/LangRef.html#binary-operations">多找找llvm手册</a> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Standard binary operators...</span><br><span class="line"> FIRST_BINARY_INST(13)</span><br><span class="line">HANDLE_BINARY_INST(13, Add  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(14, FAdd , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(15, Sub  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(16, FSub , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(17, Mul  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(18, FMul , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(19, UDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(20, SDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(21, FDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(22, URem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(23, SRem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(24, FRem , BinaryOperator)</span><br></pre></td></tr></table></figure>
<p>TODO 确实会留下原来被代替的指令。需要在合适的时候调用<code>bo-&gt;eraseFromParent();</code>直接调用会导致iterator出现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = vec.erase(i); </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>南京大学《软件分析》课程笔记</title>
    <url>/2021/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="南京大学软件分析课程笔记">南京大学《软件分析》课程笔记</h1>
<p>（静态分析）</p>
<p>警告：本笔记可能包含错误推论。有待学成后回来检查。</p>
<p>做了实验是因为碰巧从Github上搜到了原本应该不外传的实验代码。</p>
<span id="more"></span>
<p>[toc]</p>
<h2 id="introduction">01 Introduction</h2>
<p>TODO: 复习补充</p>
<p>假如有一群人，里面有好人有坏人，我们需要抓出坏人。我们能找出一个子集，使得包含所有的坏人，这样的结果是Sound的。Sound关注的是完整性，会Over Approximate。找出子集使得只包含坏人，不包含好人，这样的结果是Complete的。Complete提供确信性，保证不会抓错好人。</p>
<p>保证能抓到坏人的Completeness我们可以处理掉，保证不会漏掉坏人的Soundness则能够缩小范围，这样的结果我们都称为是Safe的。</p>
<p>may analysis 对应sound，must analysis对应complete。</p>
<h2 id="ir">02-IR</h2>
<p>静态分析一般都在IR上进行。</p>
<h3 id="ast-vs-ir">AST vs IR</h3>
<p>AST 更侧重于语法结构，比如保留了do_while这样的节点，然后分为Body和条件。适合快速的类型检查。静态分析不太需要关心语法结构。IR离控制流反而更近。</p>
<h3 id="实际的ir-soot的3ac">实际的IR-Soot的3AC</h3>
<p>Soot能分析Java程序，它就是产生typed 3AC.</p>
<p>(Soot？JVM) 中常见的invoke指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokespecial: call constructor, call superclass methods, call private methods</span><br><span class="line">invokevirtual: instance method call (virtual dispatch)</span><br><span class="line">invokeinterface: cannot optimization, checking interface implementation.</span><br><span class="line">invokestatic: call static methods</span><br><span class="line"></span><br><span class="line">Java 7: invoke dynamic -&gt; Java static typing, dynamic language on JVM</span><br></pre></td></tr></table></figure>
<p>多个字符串相加会实例化新的StringBuilder，依次对每个字符串调用append，最后toString。</p>
<p>Java的class，静态成员初始化（静态代码块？）会在生成的<code>&lt;clinit&gt;</code>函数中，比如给static final double pi = 3.14这样的成员赋值。</p>
<h3 id="ssa">SSA</h3>
<p>SSA似乎是3AC的一种形式？如果在分支merge的情况，true分支和false分支对x赋了不同的值，会引入phi-function合并变量，表示定义了哪个就用哪个。</p>
<p>SSA优点：</p>
<ol type="1">
<li><p>能够让Flow insensitive的分析也有一些Flow sensitive的精确性。</p></li>
<li><p>定义和使用的对应关系是显式的。可能就是不怕变量被中途改掉，找到定义的地方即可。</p></li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>引入太多变量和Phi函数</li>
<li>可能导致machine code不够高效，性能问题</li>
</ol>
<h3 id="cfa-cfg">CFA CFG</h3>
<p>BasicBlock的特性：只能从第一条指令进入，只能从最后一条指令离开。最大的集合</p>
<p>构建BB的算法：找到所有BasicBlock的入口指令：1. 第一条指令 2. 跳转的目标 3. 跳转的下一条指令。然后切分开就是所有的BasicBlock。</p>
<p>构建CFG：如果在BB之间添边：每个无条件跳转只添到跳转目标，每个条件跳转添下一条和跳转目标。如果两个BB相邻并且没有跳转语句，直接添顺序执行的边。最后加上两个特殊的节点，Entry和Exit。</p>
<h2 id="data-flow-analysis-application-i">03-Data Flow Analysis-Application I</h2>
<p>属于编译后端优化的基础。application-specific的数据是怎么在CFG上流动的。</p>
<h3 id="基础概念">基础概念</h3>
<p>每段statement将输入态转化为输出态。给每个程序点关联一个对所有可能的程序状态的抽象。</p>
<p>Forward Analysis，Backward Analysis</p>
<p>TODO 复习34:36方面的符号。</p>
<p>没有涉及到的分析：Method Calls，需要跨过程的控制流图，在跨过程分析里学。Aliases：变量没有别名，在指针分析里学。</p>
<h3 id="reaching-definitions-analysis">Reaching Definitions Analysis</h3>
<p>定义到达分析。分析某处定义能不能到达某处而不被杀掉。这里的3AC的定义指要么是初始化要么是赋值，其实还是关注那处的值能否到达。</p>
<p>对应的实际场景假设是空指针分析，把初始化为null的定义收集起来做分析，判断能否到达使用处，这里是May analysis，也就是保证任何可能的到达都要计算出来，不会漏掉任何的可能性。</p>
<p>转换函数的公式：减去kill的，加上生成的 <span class="math display">\[
OUT[B]=gen_B\cup(IN[B] - kill_B)
\]</span> 控制流的转换公式：所有可能的控制流的状态的并集。 <span class="math display">\[
IN[B] = \cup_{P\ a\ predecessor\ of\ B}OUT[P]
\]</span> 定义到达分析的算法：输入CFG（每个基本块的<span class="math inline">\(kill_B\)</span>和<span class="math inline">\(gen_B\)</span>），输出每个基本块的IN[B]和OUT[B]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OUT[entry] = 空集;</span><br><span class="line"><span class="keyword">for</span> (每个除了entry的基本块 B) &#123;</span><br><span class="line">    OUT[B] = 空集;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (本轮有OUT改变) &#123;</span><br><span class="line">    <span class="keyword">for</span> (每个除了entry的基本块 B) &#123;</span><br><span class="line">        IN[B] = 每个B的前驱（P）的OUT[P];</span><br><span class="line">        OUT[B] = gen_B 并(IN[B] - kill_B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的迭代算法模板。反复代入规则，直到结果不变。（不动点）</p>
<p>这次的例子中，对每个变量用一个1bit的值表示能否reach，最终对每个基本块都得到了一个bit vector。</p>
<p>如何证明该算法最终会停下来？</p>
<p>1.gen和kill是不会变的 2. 当IN变大了的时候，增加的要么被kill了，要么存活下来进入OUT，进入OUT的值不会再离开，即OUT是单增的。3. 而最终的OUT集合是有限集合（因为整个程序是有限的）4. 最终总会达到稳定，停下来。（即数列的单增有界必收敛。）</p>
<p>如何证明我们的while条件能保证是最终结果？</p>
<p>只需证本轮无OUT改变的时候即使再迭代也不会改变结果。根据迭代中语句，因为OUT不变，IN也不变，而IN不变，OUT也不会继续变化。</p>
<p>只有一个不动点吗？</p>
<p>无论什么样的分析，都可以归结为Lattice上求解不动点。我们这样求可能会求出最大不动点或者最小不动点。</p>
<h2 id="data-flow-analysis-application-ii">04 Data Flow Analysis-Application II</h2>
<h3 id="live-variable-analysis">Live Variable Analysis</h3>
<p>变量V在P处活跃的定义：存在以P开头的路径到达V的某个被使用处，且中途没有其他V的定义。</p>
<p>这里（整个数据流分析）的definition似乎既包括声明也包括赋值。</p>
<p><strong>注意辨析和Reaching Definition的区别</strong>。当前执行到了程序点P，当前状态下有很多已经被定义的变量。这些变量在当前状态下的值中，之后可能会被用到的，就成为Live的，之后肯定不会被用到的就是dead。从变量的角度看，V从被赋值的地方开始活跃起来，如果（当前的值）之后都不可能再被用到了就死了。但是live variable 中的live，不再是definition的属性，而是variable的属性。我们关心的是variable，而不像Reaching Definition一样关心的是definition了。我们关心的是variable，不再是definition了。</p>
<p>应用：可以用于寄存器分配。当前不再活跃的值就可以从寄存器放弃了。</p>
<p><strong>适合正向分析还是反向分析？</strong> 一个显著的特点是，如果接下来马上被use，那肯定是live的。每个use的地方象征着liveness区域的（可能的）结束。正向想要判断的话，需要碰到use再返回去给前面的p设置liveness。所以适合反向看。</p>
<p>公式就完全反过来了：从后继节点的IN推前一个节点的OUT <span class="math display">\[
OUT[B] = \cup_{S\ a\ successor\ of\ B}IN[S]
\]</span> 而逆向的转换函数如下：重点考虑 <code>v=v-1</code> 先use再def，和 <code>v=2;k=v</code> 先def再use的情况 <span class="math display">\[
IN[B] = use_B\cup(OUT[B] - def_B)
\]</span> 类比之前的情况，基本上是use类似于gen，def类似于kill。使用gen，赋值kill。</p>
<p>这样就有了总体的算法：和之前类似，只是反过来了（类似CFG倒置）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IN[<span class="built_in">exit</span>] = 空集;</span><br><span class="line"><span class="keyword">for</span> (每个除了<span class="built_in">exit</span>的基本块 B) &#123;</span><br><span class="line">    IN[B] = 空集;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (本轮有IN改变) &#123;</span><br><span class="line">    <span class="keyword">for</span> (每个除了<span class="built_in">exit</span>的基本块 B) &#123;</span><br><span class="line">        OUT[B] = 每个B的后继（P）的IN[P];</span><br><span class="line">        IN[B] = use_B 并(OUT[B] - def_B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里进行的是may analysis，一般来说may analysis初始化为空，对应lattice中的botton，must analysis初始化为all，对应lattice中的bottom。</p>
<p>注意控制流分叉的地方。如果分叉两边的IN，各有不同的变量live，那分叉的地方的OUT是什么？既然不知道要跳转到哪，就假设都会跳转（sound的over approximate思想），取交集。因为，假设是寄存器分配的情况，假设变量本来是dead的，你当成了live，那只是浪费了寄存器资源，是over approximate，是可以的。如果变量是live的，你当成了dead，那之后想用的时候就玩完了，这不可取。所以寄存器分配的例子需要的是soundness而不是completeness。</p>
<h3 id="available-expression-analysis">Available Expression Analysis</h3>
<p>表达式<code>x op y</code>在p处活跃的定义：1 从entry开始到p的所有路径都需要计算<code>x op y</code>。2 在最后一次计算<code>x op y</code> 后，x和y的值没有改变。</p>
<p>这意味着1 在p点，已经计算好的<code>x op y</code>依然能代表x和y参与运算的结果。2 可以检测global公共子表达式。</p>
<p>bit Vector，为每个expression定义一个bit，表示当前是否活跃。1表示是Available，0就表示不是</p>
<p>新计算出的表达式被gen了，被定义的变量会kill相关的表达式。所以表达式的转换公式和最开始的Reaching Definitions Analysis相同。</p>
<p>这次就是Foward + Must Analysis的例子了，需要取交集。当两处控制流交汇的时候，一边可能是Available，另外一边不是，则只能认为不是，因为能承担重新计算的代价，却不能容许错误。 <span class="math display">\[
IN[B] = \cap_{P\ a\ predecessor\ of\ B}OUT[P]
\]</span> 算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OUT[entry] = 空集;</span><br><span class="line"><span class="keyword">for</span> (每个除了entry的基本块 B) &#123;</span><br><span class="line">    OUT[B] = all; <span class="comment">// 注意！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (本轮有OUT改变) &#123;</span><br><span class="line">    <span class="keyword">for</span> (每个除了entry的基本块 B) &#123;</span><br><span class="line">        IN[B] = 每个B的前驱（P）的OUT[P];</span><br><span class="line">        OUT[B] = gen_B 交(IN[B] - kill_B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是Must Analysis，初始化为全1，运算采取交集。之前我们都是初始化为空，采取并集，然后迭代增加。而这里我们初始化为全1，然后使用交不断减少。显然不能初始化为全0再采取交集运算，这样始终是全0。</p>
<p>另外注意entry还是初始化为全零的。</p>
<h3 id="对比">对比</h3>
<table>
<thead>
<tr class="header">
<th></th>
<th>Reaching Def</th>
<th>Live Variable</th>
<th>Available Exp</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Domain</td>
<td>Set of Def</td>
<td>Set of Variables</td>
<td>Set of exp</td>
</tr>
<tr class="even">
<td>Direction</td>
<td>Foward</td>
<td>Backward</td>
<td>Forward</td>
</tr>
<tr class="odd">
<td>May/Must</td>
<td>May</td>
<td>May</td>
<td>Must</td>
</tr>
<tr class="even">
<td>Boundary node</td>
<td>OUT[entry] = 空</td>
<td>IN[exit]=空</td>
<td>OUT[entry] = 空</td>
</tr>
<tr class="odd">
<td>Initialization</td>
<td>0</td>
<td>0</td>
<td>all</td>
</tr>
<tr class="even">
<td>Transfer func</td>
<td>减kill并gen</td>
<td>同</td>
<td>同</td>
</tr>
<tr class="odd">
<td>Meet合并</td>
<td>并</td>
<td>并</td>
<td>交</td>
</tr>
</tbody>
</table>
<p>总结来说有4种情况，分别是分析方向，和may/must分析的正交。</p>
<p>分析的方向决定了初始化哪个边界节点，和TransferFunction的方向。may/must决定了是用交还是并，初始化是全0还是全1。</p>
<h2 id="data-flow-analysis---foundations-i">05-Data Flow Analysis - Foundations I</h2>
<h3 id="另一个角度看待迭代">另一个角度看待迭代</h3>
<p>假设是Reaching Def的分析场景，所有的def构成域V（bitVector的值域）。CFG有k个节点。则将所有CFG在OUT里的值组成长度为k的tuple。 <span class="math display">\[
(OUT[n_1],OUT[n_2],...,OUT[n_k])
\]</span> 每次迭代则看作一个函数，输入<span class="math inline">\(V^k\)</span>(所有的OUT)，输出一个新的<span class="math inline">\(V^k\)</span>。不断迭代直到找到不动点。</p>
<p>问题：</p>
<ol type="1">
<li>是否总是能达到不动点？</li>
<li>是否只有一个不动点，我们到达的是最好的那个吗</li>
<li>要花多久到达不动点？</li>
</ol>
<h3 id="偏序">偏序</h3>
<p>偏序集：包含一个集合和一个符号&lt;=。满足1. 自反性Reflectivity x&lt;=x。2. 反对称性Antisymmetry 如果x&lt;=y且y&lt;=x 则x=y。3. 传递性Transitivity：如果x&lt;=y且y&lt;=z，则x&lt;=z。特点是可以允许两个元素不可比较。</p>
<p>例子：1. &lt;=在自然数上 2. 字符串上的子字符串判断。3. 幂集。</p>
<h3 id="上界和下界">上界和下界</h3>
<p>偏序集中子集的S。如果元素u是S的上界（upper bound），则每个S中的元素x都&lt;=u。下界同理，每个S中的元素x都有1&lt;=x关系，则1是下界（lower bound）。</p>
<p>最小上界least upper bound（lub or join）：它&lt;= S的每个上界元素。最大下界greatest lower bound（glb or meet）。</p>
<p>性质：1. 都不一定在S中。2. 不是每个偏序集合都有lub或glb。 3. lub或glb有则唯一。</p>
<p>当S中只有两个元素a、b的时候，可以发现，a join b 是最小上界，a meet b是最大下界。</p>
<h3 id="lattice格">Lattice格</h3>
<p>如果偏序集中任意一对元素都有lub和glb，则这个偏序集称之为格。</p>
<p>如果只满足任意一对元素都有最小上界，则称为join semilattice。同理还有meet semilattice。</p>
<p>全格Complete Lattice：任意子集都存在lub和glb。（任何子集都是格。）</p>
<p>对整数上关于&lt;=的格，不是全格，因为正整数集合不存在最小上界。</p>
<p>幂集则满足全格。格中最大的元素成为top，最小的元素称为bottom。</p>
<p>任意有限格都是全格。我们静态分析一般都是Complete finite lattice。</p>
<p>Product Lattice：n个格的product组成tuple。定义新的偏序关系需要每个对应位置的元素都成立&lt;=关系。全格的product lattice也是全格。</p>
<h3 id="基于格的数据分析框架">基于格的数据分析框架</h3>
<p>数据分析框架由（D-direction，L-Lattice(以及meet join运算符)，F-转换函数）组成。这样数据分析框架就可以看作是反复调用转换函数（IN转换OUT的时候）和meet/join运算符（合并控制流的时候），作用于格上的值。</p>
<h3 id="单调性与不动点定理">单调性与不动点定理</h3>
<p>格上函数的单调性： <span class="math display">\[
x\sqsubseteq y \Rightarrow f(x) \sqsubseteq f(y)
\]</span> 不动点定理：</p>
<p>全格<span class="math inline">\((L,\sqsubseteq)\)</span>，1. L是有限的 2. 函数<span class="math inline">\(f:L\rightarrow L\)</span>是单调的monotonic。则最小不动点可以通过从开始bottom不断迭代得到。最大不动点可以通过从Top开始不断迭代得到。</p>
<ol type="1">
<li><p>证明不动点存在： <span class="math display">\[
\bot \sqsubseteq f(\bot) \sqsubseteq f^2(\bot) \sqsubseteq ... \sqsubseteq f^n(\bot)
\]</span> 而L是有限的，导致总是会达到相等的时候。</p></li>
<li><p>证明不动点最小：</p>
<p>假设有另外一个不动点x，由定义有<span class="math inline">\(\bot \sqsubseteq x\)</span>。反复代用单调性的定义（或者由数学归纳法证）得 <span class="math display">\[
f^{i}(\bot) \sqsubseteq f^{i}(x) = x, i \in N^+
\]</span> 则左边到达不动点的时候还是<span class="math inline">\(\sqsubseteq x\)</span> 的，因此我们的不动点最小。我们证明了我们迭代得到的不动点会&lt;=任意的不动点。还可以证最小不动点唯一。</p></li>
</ol>
<h2 id="data-flow-analysis---foundations-2">06-Data Flow Analysis - Foundations 2</h2>
<h3 id="关联我们的迭代算法">关联我们的迭代算法</h3>
<p>bitVector的表示范围是域，类似于幂集，因为把1看做集合内有该元素，0看作集合内没有该元素。每个BB的OUT，即OUT中的每个元素，都是格上的值。每次迭代的OUT总体来看是格的product。而且Complete Lattice构成的product Lattice也是Complete的。</p>
<p>我们每次迭代的动作：1. 对每个基本块应用状态转换函数。2. 在合并的时候使用join/meet操作。</p>
<h3 id="证明迭代函数单调">证明迭代函数单调</h3>
<ol type="1">
<li><p>gen/kill的状态转换函数是单调的，该gen的总是还在，该被kill的也总是被kill。因此<span class="math inline">\(if\ x_1&lt;x_2,\ f(x_1) &lt; f(x_2)\)</span>。</p></li>
<li><p>join和meet函数，可以描述为<span class="math inline">\(\sqcap/\sqcup: L\times L\rightarrow L\)</span>，如果有多个控制流就两两调用合并。</p>
<p>这里证明<span class="math inline">\(\sqcup\)</span>，即upper bound运算是单调的。 <span class="math inline">\(\forall x,y,z \in L,\ x \sqsubseteq y\)</span>，我们要证明 <span class="math inline">\((x \sqcup z) \sqsubseteq (y \sqcup z)\)</span>。</p>
<ol type="1">
<li>首先由upper bound的定义，<span class="math inline">\(y \sqsubseteq (y \sqcup z)\)</span>。</li>
<li>由传递性，<span class="math inline">\(x \sqsubseteq (y \sqcup z)\)</span>。因此<span class="math inline">\(y \sqcup z\)</span>也是x的上界。</li>
<li>而由于<span class="math inline">\((x \sqcup z)\)</span>是x和z的最小的上界，也就是同时是x和z两个值的上界里最小的那个，由这里最小的定义得<span class="math inline">\((x \sqcup z) \sqsubseteq (y \sqcup z)\)</span>。</li>
</ol></li>
<li><p>由于迭代函数由这两部分组成，迭代函数主要是对一些IN采取join/meet运算，然后对IN进行状态转换计算，因此每个OUT相比上一轮的OUT也是单调的。因此总的迭代函数，也就是product起来也是单调的。</p></li>
</ol>
<p>TODO 为什么这个不动点是best的。</p>
<h3 id="什么时候到达不动点-算法的复杂度">什么时候到达不动点-算法的复杂度</h3>
<p>格的高度：从Top到Bottom最长的路径的长度。可知格的高度是算法复杂度的上界，因为每次迭代至少会走一步。</p>
<p>而我们的情况其实是格的product。假设单个格的高度是h，有k个基本块（k个值的tuple）。最慢情况每次只有tuple中的一个元素走一步，则每个元素轮流走，至少有h*k次迭代。</p>
<h3 id="maymust分析-格的视角">May/Must分析-格的视角</h3>
<p>我们都是从最Unsafe的Result出发，到达最近的Safe Result，所以我们得到的是best result。</p>
<p>最开始初始化为0，表示每个点没有任何def能够到达。这里是May Analysis，关注的是不能漏掉任何null值可能的到达的情况。因此全初始化为0，表示所有null的def都不会到达使用的地方，是一个错误的Unsafe的结果，因为全都漏掉了。</p>
<p>truth，正确的结果，也就是在静态分析的情况下，每个基本块，把真正可能到达的定义标为1。它标志着safe和unsafe的边界，所有满足和truth的偏序大于等于关系的元素就是safe的。因为单独看函数某处，safe的结果就是在truth的基础上，可能会把一些0误报成1的结果。我们的偏序关系就是子集，因此确实safe的结果就是满足有truth这个子集的结果。</p>
<p>如何证明我们停下来的时候是safe的？状态转换函数是精确的，关键就在于这个meet/join函数的选取上我们是over approximation的。TODO</p>
<p>另外一种达到的一定的最小不动点的解释：状态转换函数是固定的，而这个meet/join函数我们选的还是最小上界，因此我们每次走的都是最小的一步，因此第一个遇到的不动点一定是最小的。是不是要证明这个路径是一维的？不用。我们如果不是从bottom出发，则走出的平行路径一定是大于等于从bottom出发的路径的，但是关键在于提前停怎么办？只要拉到无限，当两边都停了后，因为是同轮次的，所以不动点一定小于等于其他地方出发的不动点。</p>
<p>而must分析类似。</p>
<figure>
<img src="image-20210117213246480.png" alt="image-20210117213246480" /><figcaption aria-hidden="true">image-20210117213246480</figcaption>
</figure>
<p>如何记忆？</p>
<ol type="1">
<li>如何设置top和bottom（怕有的时候会反过来）？格中，bottom代表“所有人都不是坏人”，是Complete的，top代表“所有人都是坏人”，是sound的。也就是bottom - No，top - Yes。分析都是从unsafe到safe的。因为如果从另一头开始，结果就不会动了。所以Must analysis是从顶部unsafe 的“All Yes”，不断取交，增加No，直到剩下的都必定是yes。May analysis是从底部 unsafe的“All No”，不断取并，增加Yes，直到所有的Yes都在范围里。都是从最危险的地方开始，向最安全的方向走，半路上停下来，有种危险的感觉。</li>
</ol>
<h3 id="结果有多精确">结果有多精确</h3>
<p>路径汇聚起来的时候就Meet（/join）起来这种策略，称为MOP（Meet-Over-All-Paths Solution）。我们为Path，一系列的路径定义Transfer Function，<span class="math inline">\(F_P\)</span>，为路径上一系列的transfer function的函数迭代。</p>
<p>某个基本块S_i的MOP指的是从Entry到达S_i的每一条路径的转换函数，输入Entry的OUT值后的最小上界。 <span class="math display">\[
MOP[S_i]=\mathop{\sqcup/\sqcap}\limits_{A\ path\ P\ from\ Entry\ to\ S_i} (F_P(OUT[Entry]))
\]</span> 而有一些Path可能是真实情况下不会被执行到的，所以我们的结果不是完全精确的，不是truth。而有一些循环是可能无数次的，不可枚举的，枚举所有情况是不可能的。</p>
<h5 id="我们的迭代方法-vs-mop的方法">我们的迭代方法 vs MOP的方法</h5>
<p>我们的方法和MOP的方法的明显区别在于，MOP的meet是在最后进行的，而我们可能会提前meet结果在带入下一步的转换函数。</p>
<figure>
<img src="image-20210117220047438.png" alt="image-20210117220047438" /><figcaption aria-hidden="true">image-20210117220047438</figcaption>
</figure>
<p>接下来证明<span class="math inline">\(F(x\sqcup y)\)</span>（我们的）和<span class="math inline">\(F(x) \sqcup F(y)\)</span>（MOP）的关系：<span class="math inline">\(F(x) \sqcup F(y) \sqsubseteq F(x\sqcup y)\)</span>，即<span class="math inline">\(MOP \sqsubseteq Ours\)</span>。</p>
<ol type="1">
<li>由F的单调性可得<span class="math inline">\(F(x) \sqsubseteq F(x \sqcup y)\)</span> 并且 <span class="math inline">\(F(y) \sqsubseteq F(x \sqcup y)\)</span>。</li>
<li>由<span class="math inline">\(F(x) \sqcup F(y)\)</span>的最小性，得证<span class="math inline">\(F(x) \sqcup F(y) \sqsubseteq F(x\sqcup y)\)</span>。</li>
</ol>
<p>当函数F满足分配性(distributive)的时候MOP = Ours，此时一样准。而我们之前遇到的Bit-Vector or Gen/Kill problems（用并集和交集操作的）转换函数F都是满足分配性的。而我们下面的这个例子就是不满足分配律的。</p>
<p>仔细想想，MOP代表着程序（在真实场景中）所有可能执行的路径的每种情况都考虑了进来。如果出现了不确定的循环，那路径数量直接变成正无穷。而我们通过在控制流交汇处提前合并，通过将分析结果合并提前到路径叠加之前，类似于运算符交换顺序，极大地降低了复杂度，使得分析变得可行。</p>
<h3 id="constant-propagation-常量传播">Constant Propagation-常量传播</h3>
<p>定义：给定变量x，判断在点p处x的值是否一定是某个常量。</p>
<p>每个节点的OUT值，此时保存的是(x,v)的pair，表示此时某变量可能的值。</p>
<p>特殊的地方：</p>
<ol type="1">
<li><p>Lattice：我们不知道V可能取什么值，而我们只关心是否只会取一个值，于是我们设计域为UNDEF -&gt; 具体值 -&gt; NAC。这样length为3的lattice。</p></li>
<li><p>Meet Operator的情况：另外是设计Meet Operator的时候，当UNDEF遇到具体值的时候，我们认为结果是具体值。其实这里是特殊情况，如果编译器给了所有变量初始值比如0的时候，就甚至不存在UNDEF这样的值。这里感觉像把UNDEF作为未定义行为，不保证有稳定的结果。 或者说我们这个pass不管使用未初始化变量的错误，专注于当前优化，这个错误由前面的pass来查，这样就不会出现这种情况。</p></li>
<li><p>转换函数：kill比较简单，如果x被赋值，就kill掉x的pair。gen比较特殊，如果是由其他变量赋值给x，如<code>x=y</code>，定义val函数，表示取当前y相关的pair的value值。此时<code>gen=&#123;(x,val(y))&#125;</code>。如果是<code>x=y op z</code>的情况，需要分情况：</p>
<ol type="1">
<li>当val(y)和val(z)都是常量的时候，x = val(y) op val(z)</li>
<li>val(y)和val(z)有一个是NAC时，x=NAC</li>
<li>否则x=UNDEF。这里也是边界情况吧。如果UNDEF和一个常量得到一个常量的话，这个函数就不是单调的了。TODO：为什么</li>
</ol>
<p>如果不是赋值语句，就直接传下去就好了。</p></li>
</ol>
<h5 id="为什么不满足分配律">为什么不满足分配律</h5>
<p>提前合并可能导致下面这种情况失去精度，因为NAC+NAC也有可能是Constant的。</p>
<figure>
<img src="image-20210118105438408.png" alt="image-20210118105438408" /><figcaption aria-hidden="true">image-20210118105438408</figcaption>
</figure>
<p>这里还可以看出我们的分析是单调的。</p>
<h3 id="worklist-算法">Worklist 算法</h3>
<p>真正的数据流分析中，往往不是用上面讲的迭代算法，而是这里的Work List算法， 相当于是迭代方法的一个优化。</p>
<p>我们的迭代算法每次OUT变了，就要重新遍历整个CFG中的基本块。其实只需要遍历真正需要更新的基本块，即被本轮OUT变化影响的基本块，这些基本块的IN可能变，从而他们的OUT可能变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OUT[entry] = 空集;</span><br><span class="line"><span class="keyword">for</span> (每个除了entry的基本块 B) &#123;</span><br><span class="line">    OUT[B] = 空集;</span><br><span class="line">&#125;</span><br><span class="line">往Worklist加入所有基本块</span><br><span class="line"><span class="keyword">while</span> (Worklist非空) &#123;</span><br><span class="line">    从Worklist选取基本块B;</span><br><span class="line">    old_OUT = OUT[B];</span><br><span class="line">    IN[B] = 每个B的前驱（P）的OUT[P];</span><br><span class="line">    OUT[B] = gen_B 并(IN[B] - kill_B);</span><br><span class="line">    <span class="keyword">if</span> (old_out != OUT[B])&#123;</span><br><span class="line">        把B的所有后继节点加入Worklist。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验一-constprop">实验一 constprop</h2>
<p>Constant Propagation应该是must analysis。（D，L，F）中，Direction应该是Forward。Lattice是三层的那个。Transfer Function就是注意gen和kill。</p>
<p>关键是</p>
<ol type="1">
<li><p>回忆Must analysis初始值应该是危险的Top“all yes”，（所有变量都是常量）然而这里是UNDEF，而Bottom是“all no”即NAC。</p></li>
<li><p>由1就可判断，三层lattice中，undef和NAC谁在上谁在下了。NAC在下。另外初始化的时候需要初始化为UNDEF。</p></li>
<li><p>merge函数。之前的分析都是每个变量1bit，然后采取交或者并。而我们现在每个变量对应一个数值，合并的情况自然是定义新的运算，由于是must analysis，这里称作交，因为不同的数值合并的时候倾向于全零的bottom，NAC。</p></li>
<li><p>控制流合并的时候是meet（交） operator，binaryOperation的合并是function f。不同之处在于如果运算的两个参与的数都是常量，则返回运算后的结果。而不是NAC。不是两个值相等的时候就返回这个值。</p></li>
</ol>
<p>先实现meetValue，再实现FlowMap meet，再实现computeValue，最后transfer。</p>
<p>需要理解的地方：</p>
<ol type="1">
<li>transfer函数中changed变量指的不是out关于in是不是changed，而是本轮的out关于上一轮的out是否变化了。</li>
<li>Map函数的copyFrom函数调用的是put，会覆盖原来的值，并且会返回boolean表示是否修改了。</li>
</ol>
<h3 id="参数作为nac还是undef">参数作为NAC还是UNDEF？</h3>
<p>参数的Jimple语句是<code>p := @parameter0: int</code>，<code>JIdentityStmt</code>类型，属于<code>DefinitionStmt</code>。且左边的p属于<code>Local</code>。因此右边的<code>getRightOp</code>函数的值会传入<code>ComputeValue</code>函数。</p>
<p>右边的<code>@parameter0: int</code>属于ParameterRef类型，不属于几种我们处理的类型，因此被默认的条件处理，返回NAC了。</p>
<h2 id="实验二-dead-code-elimination">实验二 Dead Code Elimination</h2>
<p>基于实验一的constprop，分析跳转的条件，找出可达的分支。通过标记出可达代码，去除不可达的部分。通过找出live variable，去除dead variable。</p>
<p>首先将实验一的代码复制过来，完善ComputeValue函数，处理其他几种boolean运算。并不是ConstProp自己用到，而是接下来实现的findUnreachableBranches调用这个方法计算condition是不是常量。</p>
<p>接下来就可以实现findUnreachableBranches函数，遍历分支，把不可达的边找出来。</p>
<p>再实现findUnreachableCode函数，遍历图找出可达节点，然后取补集得到不可达节点。</p>
<p>然后实现live variable，</p>
<p>最后实现dead code elimination。</p>
<h3 id="为什么soot用box包裹value">为什么Soot用Box包裹Value？</h3>
<p>References in Soot are called boxes。</p>
<p>TODO</p>
<h3 id="live-variable">live variable</h3>
<p>首先复习live variable analysis。这里使用reversed CFG，从而还是使用旧框架，流入的还是叫IN，流出的还是叫OUT。</p>
<p>live variable方向为reversed，属于may analysis，初始化为bottom而不断上升。每个变量用1bit表示live还是dead，bottom表示全部dead。控制流汇集的时候就使用并。</p>
<p>回忆gen和kill是什么：使用gen，赋值kill。重点考虑 <code>v=v-1</code> 先use再def，和 <code>v=2;k=v</code> 先def再use的情况：后面这种是两个赋值语句，属于正常范围。而前面这种类似于<code>t=v-1;v=t;</code>倒着考虑就是先kill后gen。所以处理赋值语句的时候需要先处理赋值，再处理右边的表达式。此外还要注意changed变量设置得对不对。</p>
<p>记得处理IfStmt，顺便处理了InvokeStmt和AssignStmt中的InvokeExpr。</p>
<h2 id="interprocedural-analysis">07-Interprocedural Analysis</h2>
<p>有了过程间分析，就不必对函数的返回结果做最保守的假设，比如函数结果作为NAC。从而增加精度。</p>
<p>基本的思想是增加call edge和return edge。我们这里关注的是面向对象语言OOPL（java）的调用图构造方法。有Class hieracy analysis(CHA) Rapid type analysis(RTA) Variable type analysis(VTA) Pointer analysis (k-CFA)这几种方法，依次速度越来越慢，但是越来越精确。我们本次课学第一个方法。</p>
<h3 id="java中的方法调用">Java中的方法调用</h3>
<table>
<thead>
<tr class="header">
<th>-</th>
<th>static call</th>
<th>special call</th>
<th>Virtual call</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>指令</td>
<td>invokestatic</td>
<td>invokespecial</td>
<td>invokeinterface<br/>invokevirtual</td>
</tr>
<tr class="even">
<td>Receiver object</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>目标方法</td>
<td>静态方法</td>
<td>构造函数，私有实例方法，父类实例方法等</td>
<td>其他实例方法</td>
</tr>
<tr class="even">
<td>相关方法数量</td>
<td>1</td>
<td>1</td>
<td>&gt;=1</td>
</tr>
<tr class="odd">
<td>确定性</td>
<td>编译时确定</td>
<td>编译时确定</td>
<td>运行时确定</td>
</tr>
</tbody>
</table>
<p>virtual call在C++里面是通过虚函数表实现的，子类可以修改表中的函数指针，指向重载的方法。因为即使把receiver object看作是父类的对象，对它调用某个方法我们也希望调用到子类的方法，所有关键是让子类的方法先于父类的方法调用。</p>
<p>构造调用图的关键在于Virtual Call。Soot中使用下面这种格式的"signature"：<code>&lt;C: T foo(P,Q,R)&gt;</code>。Virtual call调用的时候，基于1. receiver object的真正类型-c。2. 调用处的method signature-m。我们设这一过程为Dispatch(c,m)。调用处的m之所以不准确，因为如果c是m中类型的子类，又重载了它的方法，就需要调用c对应的方法。 <span class="math display">\[
Dispatch(c,m)=
\begin{cases} 
    m&#39; &amp; c中非抽象方法里有1.相同名字\ 2. 相同descriptor的方法 \\
    Dispatch(c&#39;,m), &amp; otherwise
\end{cases}
\\
c&#39;是c的父类
\]</span> <a href="https://stackoverflow.com/questions/7526483/what-is-the-difference-between-descriptor-and-signature">descriptor和signature的区别</a>：descriptor反映参数和返回值，不含名字。signature反映名字和参数，不包含返回值。</p>
<p>dispatch的公式描述了查找策略，就是从子类开始，不断向上找同名同descriptor的方法。</p>
<h3 id="class-hieracy-analysis">Class hieracy analysis</h3>
<p><code>A a = ...;a.foo()</code>既然我们不知道会调用到哪个子类的方法，那就假设可能会调用到任何一个子类中的对应方法。</p>
<p>分析情景：假设我们在Soot中遇到了一个invoke称为cs，参数有一个"signature"称为m：<code>&lt;C: T foo(P,Q,R)&gt;</code>，如果是virtual call还会多一个Receiver object。Class hieracy analysis的Call Resilution算法描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Resole(cs) &#123;</span><br><span class="line">    T = &#123;&#125;;</span><br><span class="line">	m = cs指令的“signature”参数;</span><br><span class="line">    <span class="keyword">if</span> cs is a <span class="type">static</span> call &#123;</span><br><span class="line">        T = &#123; m &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cs is a special call &#123;</span><br><span class="line">        定义C^m为m的<span class="class"><span class="keyword">class</span>信息;</span></span><br><span class="line">        T = &#123; Dispatch(c^m,m) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cs is a virtual call &#123;</span><br><span class="line">        c = cs的receiver object在声明的时候的类型;</span><br><span class="line">        对c的每个子类 c<span class="number">&#x27;</span>（包括c自己） &#123;</span><br><span class="line">        	往T添加Dispatch(c<span class="number">&#x27;</span>,m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是static call，则直接可以找到对应的方法。如果是special call有三种情况，其中私有方法，自己的构造函数，则就是签名中的m，第三种情况是父类的方法（super关键字），这种情况需要不断回溯，因此我们统一也使用Dispatch函数来处理。（这里可以发现Dispatch的参数c^m是编译器确定的，因此返回的结果也是编译期能够确定的。）</p>
<p>这里是从那个变量声明时的类型向下找每个子类可能调用到的方法，而jvm运行的时候使用dispatch是从当前真正的类型向上找定义的方法，这就说明了对声明为C的类型的变量调用virtual call，那么被调用的函数所在的类，在继承树上最高不会超过C，最低不会低于变量真正的类型。错了，可能会高过C，但是此时C肯定也“有”这个方法，结果会等于Dispatch(C,m)。</p>
<p>CHA的优点：速度快，只考虑声明时的信息，但是忽略了数据和控制流的信息。缺点：不精确。很容易引入过多的目标函数。之后会通过指针分析的方法改善。</p>
<h3 id="cha构造全程序的调用图">CHA构造全程序的调用图</h3>
<p>我们从出发点开始构造（main函数）。有点类似树（图？）的遍历。从entry开始遍历所有的invoke指令，然后不断加入边，把发现的新方法加入处理队列。</p>
<p><font face="Consolas">BuildCallGraph(<span class="math inline">\(m^{entry}\)</span>)<br/> WL=[<span class="math inline">\(m^{entry}\)</span>], CG={}, RM={}<br/> <strong>while</strong> WL 非空 <strong>do</strong><br/> <strong>if</strong> m <span class="math inline">\(\not \in\)</span> RM <strong>then</strong><br/> 把m加入RM;<br/> <strong>foreach</strong> m中的每个invoke语句cs <strong>do</strong><br/> T = Resolve(cs)<br/> <strong>foreach</strong> T中每个函数<span class="math inline">\(m&#39;\)</span> <strong>do</strong><br/> 向CG中加入边 <code>cs -&gt; m'</code>;<br/> 向WL中加入<span class="math inline">\(m&#39;\)</span>;<br/> return CG;</font></p>
<h3 id="interprocedual-cfg-过程间的控制流图">Interprocedual CFG-过程间的控制流图</h3>
<p>把所有的CFG放到一起，然后加入call edge和return edge。return edge指向call之后的下一条语句。没有栈保存返回地址，那return到谁？通过Context-sensetive的分析可以解决，把数据流分开。如果有多个target，则会有多个call edge和return edge，这里也有merge的情况。如果有递归函数，则类似之前过程内分析的循环情况，还是一样的分析，沿着边走，直到值稳定下来。</p>
<figure>
<img src="image-20210118145111232.png" alt="image-20210118145111232" /><figcaption aria-hidden="true">image-20210118145111232</figcaption>
</figure>
<p>这里我们保留调用语句指向下一条语句的边，用于传递函数自己的local数据流。让call edge代表参数的流动，return edge代表返回值的流动。call的时候kill掉被赋值的变量，让它的值随着return edge流回来。</p>
<h2 id="实验三-cha">实验三 CHA</h2>
<h3 id="遍历invoke-interface和invoke-virtual的不同">遍历invoke-interface和invoke-virtual的不同</h3>
<p>在resolve invoke interface的时候，是否需要遍历子类？应该不需要，因为getAllImplementersOfInterface的时候应该就增加了所有的子类了？</p>
<p>那要不要考虑subinterface？？</p>
<h3 id="从invokeexpr中获取调用出变量的class">从InvokeExpr中获取调用出变量的class</h3>
<p>原本是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SootClass</span> <span class="variable">current</span> <span class="operator">=</span> method.getDeclaringClass()</span><br></pre></td></tr></table></figure>
<p>表示该方法定义所在的class。但是在下面这个例子里，返回的是A。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class VirtualCall &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        B b = new B();</span><br><span class="line">        b.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    void foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是其实b的定义处的类型是B，我想要从B开始向下遍历类，通过调试搞出了下面这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SootClass</span> <span class="variable">current</span> <span class="operator">=</span> ((RefType)((InstanceInvokeExpr)invoke).getBase().getType()).getSootClass();</span><br></pre></td></tr></table></figure>
<p>VirtualInvokeExpr和InterfaceInvokeExpr这两个interface都是InstanceInvokeExpr的subInterface。多了getBase这个方法获取Local类型的变量（b），然后用getType，强转为RefType，调用getSootClass得到类型（b的类型B）。</p>
<p>但是这真的是正确的答案吗？感觉不应该这么复杂的。。。如果是从A开始遍历子类确实容易遍历到是A的子类而不是B的子类的类型。</p>
<h3 id="观察intra-和interprocedural-constant-propagation">观察Intra-和Interprocedural constant propagation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    CHACP x = new CHACP();</span><br><span class="line">    a = 6;</span><br><span class="line">    b = x.addOne(a);</span><br><span class="line">    c = b - 3;</span><br><span class="line">    b = x.ten();</span><br><span class="line">    c = a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实能够优化到addOne函数和ten函数。</p>
<h2 id="指针分析">08-指针分析</h2>
<p>CHA的一个重大问题就是如果是interface，则所有implement了这个interface的类都可能是目标。OO中的指针分析分析的就是某个类的变量，指向的到达是什么实例。指针分析的是指向的对象的性质，更应该叫指向分析。指针分析几乎是静态程序分析的基础。Dagstuhl Seminar 2013的对指针分析的研讨会里这么说。</p>
<p>指针分析：计算一个指针可能指向哪些内存地址。它是一种may analysis，可以over approximation。</p>
<p>而别名分析分析的是两个指针是否会指向同一个值，它则不怎么关系指针的范围，所有指针分析和别名分析还是很不一样的。而别名分析可以由指针分析结果推导出来。</p>
<h3 id="指针分析的关键要素">指针分析的关键要素</h3>
<table>
<thead>
<tr class="header">
<th>Factor</th>
<th>Problem</th>
<th>Choice</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>堆抽象</td>
<td>对堆建模</td>
<td>Allocation-site/Storeless</td>
</tr>
<tr class="even">
<td>上下文敏感性</td>
<td>对调用上下文建模</td>
<td>Context-sensitive/insensitive</td>
</tr>
<tr class="odd">
<td>控制流敏感Flow sensitivity</td>
<td>对控制流建模</td>
<td>Flow-sensitive/insensitive</td>
</tr>
<tr class="even">
<td>分析的scope</td>
<td>分析哪些部分</td>
<td>全程序分析、按需分析</td>
</tr>
</tbody>
</table>
<p>上下文敏感技术，不同位置向同一个函数发起的调用，这个函数会分开分析。这个技术对指针分析效果提升非常显著。</p>
<p>流敏感：如何对控制流建模。我们之前的分析全都是数据流敏感的，需要对程序中每个点维护一个结果。流不敏感的方法则非常粗略，相当于只要可能指向就加过来，不管是程序中哪个点。目前Java中的很多分析都是Flow insensitive的。</p>
<p>Flow insensitive，意味着无需考虑程序中复杂多样、数量无限的数据流，另外也意味着我们的分析的结果是程序中所有的语句按照任意顺序执行的所有结果的上界。</p>
<h3 id="堆抽象">堆抽象</h3>
<figure>
<img src="image-20210118153134258.png" alt="image-20210118153134258" /><figcaption aria-hidden="true">image-20210118153134258</figcaption>
</figure>
<p>我们只学习最常用的Store based model中的Allocation-site技术。表示为每个创建点创建一个对象，即使创建点在循环里，被执行了多次，但是都抽象成一个对象。</p>
<h3 id="java中的指针分析">Java中的指针分析</h3>
<p>Java中有四种指针，局部变量，静态域（全局变量），实例成员，数组元素。数组元素建模为一个能指向多出的域，忽略index。取出的时候也是忽略index。</p>
<p>接下来的分析都是Flow-insensetive的。我们只需要关心会影响到值的语句，不需要考虑所有语句。需要关系的语句有1. new <code>x = new T()</code>2. Assign <code>x = y</code>3. Store <code>x.f =y</code>4. Load <code>y = x.f</code>5. Call <code>r = x.k(a, ...)</code>。其中最复杂的是Call里面三种情况中的Virtual Call</p>
<h2 id="指针分析基础-1">09-指针分析基础-1</h2>
<h3 id="处理简单语句">处理简单语句</h3>
<p>程序中所有指针包括变量域V，和成员域<span class="math inline">\(O\times F\)</span>两部分： <span class="math display">\[
Pointers = V \cup(O\times F)
\]</span> 其中O代表所有的对象，由于采取了Allocation-site的方式，对象的数量在编译期就确定了。F代表了所有的成员组成的域，因此所有的实例域就是O和F的Product。</p>
<p>指向关系 pt：是Pointer到O的幂集的有序对：同时引入pt(p)函数表示p的指向集合。 <span class="math display">\[
pt = Poniter \rightarrow \mathcal{P}(O)
\]</span></p>
<ol type="1">
<li><p>New语句：对于<code>x = new T()</code>，<span class="math inline">\(\overline{o_i \in pt(x)}\)</span>表示将<span class="math inline">\(o_i\)</span>加入x的指向的集合里。这里<span class="math inline">\(o_i\)</span>既表示某个对象，又表示的是allocation site。</p></li>
<li><p>Assign语句：对应<code>x = y</code>，有<span class="math inline">\(\frac{o_i\in pt(y)}{o_i\in pt(x)}\)</span>，表示所有是y的指向范围的值，也都是x的指向范围。意味着x的指向范围大于y。</p></li>
<li><p>Store语句：<code>x.f = y</code>，有 <span class="math display">\[
\frac{o_i\in pt(x),\ o_j\in pt(y)}{o_j\in pt(o_i.f)}
\]</span> 表示把x指向范围中每个值，的f域都做一遍Assign的操作。这范围有点大啊。</p></li>
<li><p>Load：<code>y = x.f</code>，有 <span class="math display">\[
\frac{o_i \in pt(x),\ o_j \in pt(o_i.f)}{o_j \in pt(y)}
\]</span> x指向范围内的每个值的f，它们的指向范围全部合起来放到y的指向范围里。还是有点大...</p></li>
</ol>
<h3 id="课程视频没了-----------">-------------课程视频没了-----------</h3>
<p>伤心</p>
<h3 id="pointer-flow-graph-pfg">Pointer Flow Graph (PFG)</h3>
<p>以上只是规则，并没有给出具体的算法。我们面临的相当于约束求解问题。我们用图组织描述出数据间的依赖关系，这样当某个数据变化的时候就可以沿着图更新被依赖的数据。</p>
<p>指针流图PFG是有向图。<span class="math inline">\(Pointers=V\cup(O\times F)\)</span> 作为Nodes。边，则是<span class="math inline">\(Pointer \times Pointer\)</span>上的值。</p>
<table>
<thead>
<tr class="header">
<th>Kind</th>
<th>Statement</th>
<th>Rule</th>
<th>PFG edge</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>New</td>
<td>x = new T()</td>
<td><span class="math inline">\(\overline{o_i \in pt(x)}\)</span></td>
<td>无</td>
</tr>
<tr class="even">
<td>Assign</td>
<td>x = y</td>
<td><span class="math inline">\(\frac{o_i\in pt(y)}{o_i\in pt(x)}\)</span></td>
<td><span class="math inline">\(x\leftarrow y\)</span></td>
</tr>
<tr class="odd">
<td>Store</td>
<td>x.f = y</td>
<td><span class="math inline">\(\frac{o_i\in pt(x),\ o_j\in pt(y)}{o_j\in pt(o_i.f)}\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>Load</td>
<td>y = x.f</td>
<td><span class="math inline">\(\frac{o_i \in pt(x),\ o_j \in pt(o_i.f)}{o_j \in pt(y)}\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p>New语句需要将对应Allocation site加入x的指向范围，但是不引入依赖关系，因此对PFG没有影响。Assign语句<code>x=y</code>蕴含着无论y内有什么，都也要放到x内。因此每当y更新，也要更新x。而x变化却不会影响y。因此需要加入y指向x的边。Store语句和Load语句，增加了取属性的这个不确定的操作，因此采取保守策略，对每个可能被指向的对象，取f属性，执行Assign的操作。例如<code>x.f = y</code>就是对任何x可能的对象，加入y的值，因此需要y指向每个x可能指向的对象的f属性。</p>
<figure>
<img src="image-20210119134315358.png" alt="image-20210119134315358" /><figcaption aria-hidden="true">image-20210119134315358</figcaption>
</figure>
<p><del>TODO:如何理解这里的<span class="math inline">\(O_i.f\)</span>。我觉得拆开更好吧。设<span class="math inline">\(O_i \in pt(c)\)</span>，设<span class="math inline">\(O_k \in pt(d)\)</span>。由于<span class="math inline">\(pt(c)\subseteq pt(d)\)</span>，因此会存在属于d而不属于c的部分。所以应该单独拆出来一条边，<span class="math inline">\(O_k.f\rightarrow e\)</span>，这样更全面。ppt的写法多增加了a指向属于d而不属于c的部分的边，但我们是May analysis，多增加依赖关系只是会扩大范围，可以接受。ppt中的<span class="math inline">\(O_i.f\)</span>应该是合并起来了对所有f的域的引用节点。</del></p>
<p>这里没必要太看懂，继续往后学就好了。之后会为每个Allocation site的object的每个域建立节点的。</p>
<h3 id="pfg上流动指向信息">PFG上流动指向信息</h3>
<p>指向信息可以顺着PFG流动，从而就直接获得了所有的指向关系pt。</p>
<p>然而这一过程和PFG的构建是相互依赖的。</p>
<h3 id="算法">算法</h3>
<figure>
<img src="image-20210119174158894.png" alt="image-20210119174158894" /><figcaption aria-hidden="true">image-20210119174158894</figcaption>
</figure>
<p>之后学Datalog处理指针分析的时候我被震惊了，为什么我花大力气学的算法居然能被这种通用的引擎处理。我们之前学习了指针分析的规则，只需要填入初始数据，然后根据规则推导出最终结果即可，复杂之处在于各种规则间互相依赖，根据规则更新了这个数据又影响了那个数据，又要更新。仔细想想，这个算法的本质，就是处理规则间的互相依赖的关系，即当一个数据更新的时候会影响到其他什么数据，不断处理达到最终结果。</p>
<p>首先介绍工作的数据结构：PFG，保存依赖关系。S，程序中所有的语句。指向关系的增加通过Propagate函数中的pt(n) 并等于运算增加，也就是说最终还是反映到pt，这个算法内部没写出来的数据结构内。</p>
<p>WorkList WL最特殊。每当某个指针需要增加指向的元素的时候，都要组成pair先放到WL里，有点递归的感觉。它是一个List，元素类型为(pointer, pts)，其中pts是指针需要增加的指向的目标。即<span class="math inline">\(WL \subseteq &lt;Pointer,\mathcal{P}(O)&gt;\)</span>。</p>
<p>Solve函数中的处理工作队列的循环，就是负责处理某个指针需要增加元素的情况，也就是负责让增加的元素在PFG上流动，同时处理属性f TODO。</p>
<p>结合Assign分支理解AddEdge函数：1. 去重：如果边已经存在，则直接返回。2. 让指向集合顺着PFG流动一步，不过也只是先加入工作队列。</p>
<p>主体函数Solve，首先处理掉了所有的普通变量Assign，和New语句。New语句：填了一些工作队列。Assign语句：向PFG中增加了普通变量关系的边，注意此时不会向工作队列增加新的内容，因为pt还是空的。</p>
<h5 id="differential-propagation">Differential Propagation</h5>
<p>工作队列循环，取出一个需要增加的pointer，对象集合的pair，然后找出真正增加的delta，调用Propagate函数，Propagate函数首先把增加的放到pt，也就是最终的结果集合中，然后找出受影响被更新的变量加入工作队列。这里只找出delta的技术称为Differential Propagation。</p>
<p>这里Worklist的工作方法来看应该是广度优先的。虽然可能Worklist内还是会有冗余，但是在每次处理的这个关卡把住，去除掉重复的，那就能减少很多工作量。</p>
<h5 id="store-and-load">Store and Load</h5>
<p>来到WL工作循环的后半部分。忘掉执行顺序，把各种语句当作一条条约束需要理顺。这个for循环其实就是描述的一种约束关系：当某个变量的指向增加的时候，1. <code>x.f = y</code>和<code>y = x.f</code>中的<code>x.f</code>会出现新的节点，需要增加PFG的边。</p>
<p>当给一个变量x增加了新的指向可能性的时候，我们开始处理相关的Store和Load情况。第一次执行到此处的时候，pt刚刚从空增加了x对应的对象。其他情况则是x增加了delta内的指向关系。对于delta内的每一个值，我们开始处理x的属性语句，对每个<code>x.f = ?</code>和<code>? = x.f</code>，我们需要假装每个delta里的对象是o_i内的元素，然后像Assign一样调用AddEdge。</p>
<p>理解<code>if n represents a variable x then</code>：这里if什么时候会不成立？当是属性的时候就不成立。1. 属性增加指向的时候意味着Store指令，即<code>x.f = y</code>这种形式，而不会是Load（<code>y= x.f</code>）。2. 我们处理的是3AC，不会有连续的取属性存在<code>x.f1.f2</code>。 =&gt; 这意味着某个变量的属性增加指向的时候，不会增加PFG的依赖关系。一方面<code>x.f=a</code>和<code>a=x.f</code>这两种语句的依赖关系已经被处理过了，另一方面不会存在<code>x.f1.f2=a</code>和<code>a=x.f1.f2</code>这样的语句。</p>
<p>总体来说就是多次取属性的操作会被临时变量拆分开。例如<code>b = new T(); a = b.f; c = a.f</code>，处理到具体Object（Allocation site）节点的邻居也就是b节点的时候会先增加<span class="math inline">\(T_1.f\)</span>节点和<span class="math inline">\(T_1.f\rightarrow a\)</span>， <strong>TODO</strong>。</p>
<p>是处理某个节点的时候增加和这个节点相邻的节点和相应的边吗？不完全是。处理<code>x.f=y</code>这样的语句，就是为o_i.f增加节点和指向它的边。毕竟不能在程序中直接写<code>o_i.f</code>这种，因为程序又不是基于Allocation site的，所以必然会有<code>x.f=y</code>这样的x，代表各种allocation site。于是在x增加指向的时候，就需要处理对应属性节点的增加。此外，还会增加<code>e=x.f</code>这样的数据边，从而增加e这样的新变量。</p>
<p>如何结合Java的分析来理解？我们现在是Context insensitive的。把每个局部变量加上类和函数的前缀做区分，应该就对应着我们的Variable？</p>
<p>TODO：多对着例子自己推导几遍。多把公式总结几遍。</p>
<h3 id="总结">总结</h3>
<ol type="1">
<li>所有New</li>
<li>所有Assign</li>
<li>Loop：
<ol type="1">
<li>Propagate：增加指向 -&gt; 流动一步</li>
<li>遍历Δ × {Store, Load} 执行Assign操作</li>
</ol></li>
</ol>
<h2 id="指针分析基础-2">10-指针分析基础-2</h2>
<p>本节课的任务只有一个：掌握跨函数的指针分析的算法。</p>
<p>对于语句<code>r = x.foo(a1, a2)</code>，公式基本上是说，如何解决参数指向，如何解决this指向，如何解决返回值的流向。特别注意this指针，不添加PFG边，而是直接暂时传过去？TODO</p>
<figure>
<img src="image-20210119202248454.png" alt="image-20210119202248454" /><figcaption aria-hidden="true">image-20210119202248454</figcaption>
</figure>
<h3 id="公式分析">公式分析</h3>
<p>公式可以拆分来看，把相同的元素如O_i先看条件中关于O_i的部分，再看结论中关于o_i的部分。</p>
<ol type="1">
<li><p><span class="math display">\[
\frac{o_i\in pt(x), m = Dispath(o_i,k)}{o_i \in pt(m_{this})}
\]</span></p>
<p>因为Allocation site的Object是真实的，所以每个o_i也是真实的，不再需要像CHA那样猜测每个子类。所以Dispatch一次就可以得到真正被调用的方法。</p>
<p>这个公式给出了method的查找方法，以及this指针的指向。</p></li>
<li><p><span class="math display">\[
\frac{o_u \in pt(aj), 1\le j\le n}{o_u \in pt(m_{pj}), 1\le j\le n}
\]</span></p>
<p>这个比较直观？描述了argument传递变成parameter。即 <span class="math display">\[
a1\rightarrow m_{p1},a2\rightarrow m_{p2},...,an\rightarrow m_{pn},
\]</span></p></li>
<li><p><span class="math display">\[
\frac{o_v\in pt(m_{ret})}{o_v\in pt(r)}
\]</span></p>
<p>也简单，描述了函数返回值的指向传递给调用处接收的变量，即<span class="math inline">\(r\leftarrow m_{ret}\)</span>。</p></li>
</ol>
<h3 id="pfg不增加x-m_this">PFG不增加x-&gt;m_{this}</h3>
<figure>
<img src="image-20210120114313716.png" alt="image-20210120114313716" /><figcaption aria-hidden="true">image-20210120114313716</figcaption>
</figure>
<p>PFG中增加边表示的是依赖关系，<code>m_this = x</code>，如果增加了，那x的所有可能指向都会流向那个函数的指针，如图中，画横线的部分是明显不合适的，因为this指针不可能是那个类型。</p>
<p>从公式的角度讲，关键在于m是依赖于o_i取值的。也就是先外层遍历o_i，确定了o_i的具体值之后，才能确定m，从而让此时的m_this会指向o_i。如果增加PFG边，则当o_i确定了后，pt(x)中的其他值也可能是this的指向，这明显不对。</p>
<p>所以虚线代表什么意思？表示需要分情况考虑，x中只有部分值能够流过去。只有Dispath后确实会返回该method的o_i才会沿着虚线流过去，即<span class="math inline">\(for\ o_i\in pt(x), if\ m == Dispath(o_i,k)\)</span>。</p>
<p>而如果方法是静态的，那么就没有this指针。</p>
<p>是否是Context-sensetive了？不，每个method只考虑了一次，而并不是随着每次调用考虑。</p>
<h3 id="算法-1">算法</h3>
<figure>
<img src="image-20210120115755652.png" alt="image-20210120115755652" /><figcaption aria-hidden="true">image-20210120115755652</figcaption>
</figure>
<p>ProcessCall就是增加一个foreach处理call的语句。call语句其实就是一个“大型”拓展CFG和赋值的语句。同时算法增加了从entry函数开始的探索方式，不可达的函数不会被分析，最终生成Call Graph</p>
<p>给节点增加指向的时候要考虑沿着PFG的流动，因此要先加入工作队列，进行复杂的操作。那给当前可达语句集合增加一整个新函数的语句的时候，是否会对已有的结果产生影响？一方面由于函数作用域导致其他函数中的变量不会影响到这个函数，另外，不会增加已有的两个节点之间的边，因为<code>g1.f = g2.f2</code>这样的语句会被临时变量拆分开。所以增加一个可达函数的时候只是普通地处理New和Assign语句一次性解决，让新的边随着节点的增加而增加，不像增加指向的时候那么麻烦。</p>
<p>当某个变量的指向增加的时候，1. <code>x.f = y</code>和<code>y = x.f</code>中的<code>x.f</code>会出现新的节点，需要增加PFG的边。2. call调用的目标会增加：当x的指向范围更新了，那么此处就可能有新的方法被调用。因此像处理Load和Store一样，继续处理相关的call。有点类似<code>y= x.f</code>，但是拓展成了一整个函数。</p>
<p>算法和公式是对应的，算法的处理步骤为：1. 由于o_i已经确定，通过Dispatch计算得到m。2. <del>增加当前o_i到m_this的边。</del>给m_this增加指向范围o_i到WorkList。这条边是独立于当前情况的，而之后的边都是每个（调用点，目标方法）只需要添加一次的。3. 判断是否加入Call Graph（同时去重），没有则加入Call Graph，AddReachable并增加参数传递边，增加返回值传递边。</p>
<h3 id="总结-1">总结</h3>
<p>初始化新函数“大陆”AddReachable：不在可达函数列表则：加入可达函数列表，语句全部加入可达语句，处理New语句：增加队列，处理Assign语句：加边，流动。</p>
<p>处理调用语句：依次处理可达语句中所有的x.k：1. Dispatch找到m，增加m_this的指向范围到队列。2. 若次处调用不在CallGraph（当前的（调用点，目标函数）对是新出现的）则：一. 增加CallGraph。2. 初始化新函数大陆。3. 加入参数边和返回值边。</p>
<p>总算法：1. 初始化entry函数大陆 2. 进入工作循环：</p>
<ol type="1">
<li><p>获取当前工作，计算Δ</p></li>
<li><p>Propagate：增加指向pt -&gt; 流动一步</p></li>
<li><p>遍历Δ × {Store, Load, Call}。其中Store和Load作为Assign处理：加边，流动</p>
<p>Call指令单独处理。</p></li>
</ol>
<p>加入可达语句列表是为了接下来遍历变量x的Store, Load, Call的时候会在里面找。由于变量都是局部变量（非局部变量都是域，需要先保存到局部变量），所有基本上只要在当前函数找行了？</p>
<p>普通函数调用怎么处理？是采取内联？不，应该只是call语句的不需要this指针的特殊情况。<code>r=x.f()</code>是在处理x的时候处理，但是静态函数调用没有x这样的对象，应该在初始化时处理参数和返回值的传递。</p>
<h2 id="实验四">实验四</h2>
<p>确实和讲的算法很对应。</p>
<ol type="1">
<li><p>回忆几种语句的规则处理</p></li>
<li><p>回忆几种数据结构</p>
<p>利用PFG指针流图辅助，最终的目标是计算pt。</p>
<p>其他辅助的数据结构：WL work list，S reachable statement，RM reachable Method，CG call graph。</p></li>
<li><p>回忆算法流程</p>
<p>主循环把关好节点指向的增加，把指向沿着PFG传播。增加edge的时候也需要传播。传播由worklist负责。</p></li>
</ol>
<p>代码量挺小的。</p>
<h2 id="context-sensetive-指针分析-1">11-12-Context-Sensetive 指针分析-1</h2>
<p>不同的调用上下文中变量有不同的值，当C.I.的时候，会被混合并传播，进而形成假的数据流。</p>
<h3 id="不同的上下文">不同的上下文</h3>
<ol type="1">
<li>Call-Site Sensitivity：调用链作为上下文标识。衍生：k-Limiting Context Abstraction</li>
<li>Object Sensitivity：Allocation site序列标识区分。衍生：Type Sensitivity。在类似Java这样的OO语言中，比Call-Site Sensitive的效果好。</li>
</ol>
<p>call-site sensitivity是最古老的，最广为人知的方法。通过从entry开始的调用序列区分每次调用，仿佛每次执行到该函数的时候看一下backtrace区分不同的函数。在面向对象语言（如Java）中，Object Sensitivity通常比Call-Site Sensitivity表现更好。如果追求速度，可以进而选用Type Sensitivity。</p>
<figure>
<img src="image-20210121195350997.png" alt="image-20210121195350997" /><figcaption aria-hidden="true">image-20210121195350997</figcaption>
</figure>
<p>如图中，静态方法调用传参的时候，需要将两次调用区分开，否则数据流就会在同一个参数n上汇聚交错。</p>
<p><strong>Cloning-Based Context Sensitivity</strong></p>
<p>每个方法由context区分，每个context clone出来一个方法，仿佛是不同的方法似的单独考虑。而每个变量也继承方法的context标识，区分开。</p>
<h3 id="c.s.-heap">C.S. heap</h3>
<p>Java这样的方法非常依赖堆。Context标识也同样需要应用到堆分配上，即Allocation site分配出的Object也要随着不同的Context区分开。想象有一个method专门用来分配对象，只有<code>return New A()</code>。则只有一个Allocation site。如果所有的这样分配得到的Object只用一个Object表示，则会导致数据流在这个Object的field上混在一起。</p>
<p>Context-Sensetive不仅需要对不同的调用点利用上下文标识区分开分析，还需要Context-Sensetive heap，区分在不同上下文中分配的对象。</p>
<p>然而C.S heap只有在C.S的时候才能提高精度。C.I.+ C.S. heap进行分析时，C.S. heap就不能提高精度了。因为。C.I.意味着不对函数做区分，C.S. heap意味着依然对New出来的object依照backtrace做区分。但是由于不对函数和变量做区分，导致即使分配出来的object不同，也直接在allocation site处被接收的临时变量混在一起，没有任何效果。</p>
<figure>
<img src="image-20210121204017858.png" alt="image-20210121204017858" /><figcaption aria-hidden="true">image-20210121204017858</figcaption>
</figure>
<p>即图中虽然8行new X();返回了不同的对象，但是直接在变量x上混在一起，即使区分出来了对象，对它们做的操作也是完全相同的，多出来的对象没有任何效果。</p>
<p>C.S. heap和真正的堆的辨析： TODO</p>
<p>C.S. heap随着Context对调用链的区分而区分不同Context分配的对象。</p>
<p>还是无法区分单次函数调用多次分配的对象，即循环中的Allocation site的多次调用，Allocation site的固有限制。</p>
<h3 id="公式">公式</h3>
<figure>
<img src="image-20210121160102510.png" alt="image-20210121160102510" /><figcaption aria-hidden="true">image-20210121160102510</figcaption>
</figure>
<p>Fields不用加Context表示，是因为它所附属的Object已经有了Context标识，毕竟Fields不能单独存在。</p>
<figure>
<img src="image-20210121160536010.png" alt="image-20210121160536010" /><figcaption aria-hidden="true">image-20210121160536010</figcaption>
</figure>
<ol type="1">
<li>New语句：分配的Object的Context标记，和被赋值的变量一样，继承自当前函数调用的context c。</li>
<li>Assign：object的传递保持Context标识不变。寻找变量y的时候，找的是当前context的变量。</li>
<li>Store、Load：object的传递保持Context标识不变。c,c'和c''表示当前函数，x指向的某个object，和这个object的域可能指向的object的Context都可能不一样。</li>
</ol>
<p>Call的公式如下： $$  {c':o_ipt(c:x)，\ m = Dispatch(o_i,k), c^t=Select(c,l,c':o_i)\ c'':o_upt(c:aj),1jn\ c''':o_v pt(c^t:m_{ret})}</p>
<p>{c':o_ipt(c^t:m_{this})\ c'':o_upt(c^t:m_{pj})\ c''':o_vpt(c:r)} $$ 和之前Call的公式差不多，先遍历o_i然后Dispatch得到m，传递this指针。传递参数和返回值。</p>
<p>但是call也是生成新的Context标记的地方。Select的参数如下：</p>
<ol type="1">
<li>当前context：c。</li>
<li>call site的行号：l。</li>
<li>调用的接收对象：c':o_i。</li>
</ol>
<h3 id="算法-2">算法</h3>
<p>PFG自此也是带context的，称为Pointer Flow Graph with C.S. 体现在节点是带context标记的（变量或对象的域）。加边还是一样的加，只不过对同一个方法可能会clone出各种只有context不同的节点。</p>
<figure>
<img src="image-20210121190345121.png" alt="image-20210121190345121" /><figcaption aria-hidden="true">image-20210121190345121</figcaption>
</figure>
<h3 id="object-sensitivity">Object Sensitivity</h3>
<p>每次函数调用的时候，首先拿来receiver object的context作为基础，加上receiver object自身。由于我们是allocation site的堆模型，因此这里的object其实就对于allocation site。</p>
<figure>
<img src="image-20210121201818813.png" alt="image-20210121201818813" /><figcaption aria-hidden="true">image-20210121201818813</figcaption>
</figure>
<p>和Call-site Sensitivity对比：TODO</p>
<ol type="1">
<li>Object-sensetive还真就只关心Object。对同一个Object调用两次某方法无法区别。保持当前Object不变，把目标Object保存到域中，在另外一个方法里获取再调用，这样也无法区分。</li>
</ol>
<p>有没有任意长Call-site无法识别，而object sensitivity能够识别的？</p>
<p>任意长Call-site能否完全区分object sensitivity的所有情况？</p>
<h3 id="type-seneitivity">Type Seneitivity</h3>
<p>做实验才发现自己没弄清楚。</p>
<p>这是一种随着allocation增长的context。每次函数调用的时候，首先拿来receiver object的context作为基础，加上receiver object的allocation site这个语句所在的类。</p>
<p>类似于allocation的时候把所在的类拿过来增长一下，暂时存在object里，调用方法的时候拿出来。</p>
<p>context序列代表的是一路alloc的Object的语句所在的类型。</p>
<figure>
<img src="image-20210215110334026.png" alt="image-20210215110334026" /><figcaption aria-hidden="true">image-20210215110334026</figcaption>
</figure>
<p>TODO：对比</p>
<h2 id="实验五">实验五</h2>
<p>Cloning-Based Context Sensitivity具体在代码中如何体现？在heap model和调用时生成标签中，返回了不同的object，则会在PFG和最终的pt上产生不同的节点，从而增加精确性。</p>
<p>指针分析的类实例化后，通过下面的方式设置了heap model和contex selector。我们需要的就是返回合适的context标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pta.setHeapModel(<span class="keyword">new</span> <span class="title class_">AllocationSiteBasedModel</span>());</span><br><span class="line">pta.setContextSelector(<span class="keyword">new</span> <span class="title class_">ContextInsensitiveSelector</span>());</span><br></pre></td></tr></table></figure>
<p>谁应该被包裹在context里面？根据实验指导，是Callsite、Obj、Type(Method.getClassType)。另外还有两点需要注意，call-site sensitivity对静态方法的处理和成员方法的处理相同。而对Object和Type sensitivity来说则是不额外处理，直接传递context。</p>
<p>例如实现k=2的情况，当context没有那么多的时候，还是需要实验DefaultContext和OneContext。</p>
<p>初始化entry函数的时候，当前的Context就是default context。</p>
<p>生成Context标记就是函数调用的过程。可以想象一个函数调用，可能是静态调用，有Method，Callsite，还可能是成员函数，这样还有receiver Object。</p>
<p>另外一个需要重视的地方就是Heap Context。CS分析对堆分配也需要区分开来。分配的堆对象需要带上调用的函数的标记。在callsite-s里，不关心object，所以堆对象的context没什么影响。在object、type里，。。。</p>
<p>callsite也带Context吗？语句的context是不是就是Method的Context？</p>
<p>sootclasses-trunk-jar-with-dependencies.jar里面为什么带了bam**o，吓死人了，以为bam**o真的是soot的组成部分。可能是实验不得不用，而不想暴露实验的答案吧。不过jetbrains真是厉害啊，直接反编译了。</p>
<p>最后被坑的原因是：每个k-limiting的context selector，heap context的limit是k-1。TODO：为什么</p>
<h2 id="安全相关的静态分析">13-安全相关的静态分析</h2>
<h3 id="访问控制-vs-信息流安全">访问控制 vs 信息流安全</h3>
<p>访问控制只是限制访问数据的对象，而信息流安全可以跟踪信息的处理，分配。感觉有点类似污点分析。</p>
<p>信息流，有点像指针分析里面的数据依赖关系PFG图。<code>x=y</code>这样就表示y的信息流向了x。</p>
<p>为信息分配密级，有点像访问控制，但不是访问的时候判断，拒绝，而是分析审计然后警报。</p>
<p>关键在于两点：</p>
<ol type="1">
<li><p>把信息分成不同的安全级别</p>
<p>复杂的级甚至可以是Lattice结构的，只有顺着图方向的流动才被允许。</p></li>
<li><p>信息流动策略：不可影响策略</p>
<p>高密级的变量不能影响到低密级的变量。</p></li>
</ol>
<h3 id="机密性和完整性">机密性和完整性</h3>
<p>机密性保证秘密数据不会泄露，代表了不允许低密级Read高密级。完整性保证重要数据不会被篡改，代表高完整度不可访问低完整度。</p>
<p>直接赋值这样的情况属于显式流动。然而还存在隐藏信道（Covert Channels）。如：通过控制流影响其他变量，程序时间，触发异常等等信息。但是我们主要关注显式信道</p>
<h3 id="污点分析指针分析">污点分析+指针分析</h3>
<p>常规的污点分析似乎是指动态分析。而我们静态分析通过充分理解程序从而理解程序动态运行的行为，也可以用信息流来做污点分析。污点分析是使用最广泛的信息流分析，既可以分析机密性的泄露，也可以分析完整性是否被部分数据影响。</p>
<p>首先将我们感兴趣的信息标记为Tainted，信息源称为source（如把一些函数的返回值设置为source），其他数据是untainted。我们标记危险的函数为sink。我们分析就是试图找出从source流向sink的可能的路径。</p>
<p>把Source作为Allocation site，把Tainted data作为(artificial)Object，作为所有Object中的一部分。并且增加新的生成tainted Object的规则和收集Sink函数参数指向的规则。然后基于指针分析进行推导。</p>
<figure>
<img src="image-20210119215254928.png" alt="image-20210119215254928" /><figcaption aria-hidden="true">image-20210119215254928</figcaption>
</figure>
<h2 id="datalog-based-program-analysis">14 Datalog-Based program analysis</h2>
<h3 id="动机">动机</h3>
<p>如何让程序分析也能用描述式的方法，而不必关心具体实现？</p>
<h3 id="datalog">Datalog</h3>
<p>是Prolog的一个子集。没有副作用，没有控制流，没有函数，不是图灵完备的。由数据表Facts和逻辑Rules组成。Datalog不断推导出数据，因此是单调的。而由于规则是<code>安全</code>的，因此总的结果是有限的，所以最终总能停下来。</p>
<p>Predicates意为（谓词、判断）。一个谓词对应一个关系，代表一个数据表。对谓词带上参数成为一个fact，代表对参数中数据属于表中的断言。</p>
<p>Atoms 是Datalog中最基本的元素，形如<code>P(X1,X2,...,Xn)</code>的称为relational atom。如果<code>(“Xiaoming”,18)</code>在表中，则<code>Age(“Xiaoming”,18)</code>为真。还有arithmetic atoms，如<code>age &gt;= 18</code>这种变量判断。</p>
<p>Datalog Rules形如<code>H &lt;-B1,B2,…,Bn.</code>，由Head，箭头，Body组成。意思是当body为true的时候Head也为true。其中<code>,</code>为与逻辑，<code>;</code>为或逻辑，<code>!</code>为非逻辑，复杂逻辑最好多加加括号。</p>
<p>考虑如下规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adult(person) &lt;- Age(person,age), age &gt;= 18.</span><br></pre></td></tr></table></figure>
<p>Datalog可能会遍历Age表赋值person和age变量，然后推导，得到每个Person的Adult是否为true。</p>
<p>谓词分为EDB（extensional database）、IDB（intensional database）。EDB为给定的数据，IDB是推导出的数据。</p>
<p>Datalog最关键的是支持递归：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reach(from, to) &lt;- Edge(from, to).</span><br><span class="line">Reach(from, to) &lt;- Reach(from, node), Edge(node, to).</span><br></pre></td></tr></table></figure>
<h3 id="规则安全性">规则安全性</h3>
<p>A rule is safeif every variable appears in at least one non-negatedrelationalatom</p>
<p>每个变量至少要出现在右侧relational atom一次，被取反的不算。</p>
<p>为了防止自我矛盾：<code>A(x) &lt;- B(x), !A(x)</code>，被取反的不能是当前被递归的。</p>
<h3 id="datalog进行指针分析">Datalog进行指针分析</h3>
<figure>
<img src="image-20210121225505327.png" alt="image-20210121225505327" /><figcaption aria-hidden="true">image-20210121225505327</figcaption>
</figure>
<figure>
<img src="image-20210121225653380.png" alt="image-20210121225653380" /><figcaption aria-hidden="true">image-20210121225653380</figcaption>
</figure>
<p>同理，函数调用也被拆分成了三个规则，分别处理this指针，参数，返回值。</p>
<h3 id="datalog进行污点分析">Datalog进行污点分析</h3>
<p>在指针分析的基础上，增加Source表，Sink表，Taint表（call site -&gt; tainted data）。最终推导出Taint Flow。</p>
<figure>
<img src="image-20210121225956439.png" alt="image-20210121225956439" /><figcaption aria-hidden="true">image-20210121225956439</figcaption>
</figure>
<p>在指针分析的基础上处理好Source和Sink的情况。把Sink的情况收集起来。</p>
<h3 id="总结-2">总结</h3>
<p>Datalog类似于我们把表格里的公式输入进去，而不管算法部分。</p>
<p>我们学习的算法的好处主要在于精确知道每一步推导对下一步推导的影响是什么。每一步都精确知道下一步该做什么，从而提升效率。</p>
<h2 id="soundness-and-soundiness">15 Soundness and Soundiness</h2>
<p>Soundness关注的是能完全包含真正程序运行的所有可能行为。而实际生活中很难实现。难点如下：</p>
<ol type="1">
<li>Java：反射，native汇编代码，动态类加载</li>
<li>JavaScript：eval函数，DOM等</li>
<li>C/C++：指针的运算，函数指针</li>
</ol>
<p>这些特性过于灵活，强行加以分析只能过度估计，导致过于不精确的结果。因此非专业人士可能过度相信结果（在sound core上的），专业人士也无法精确解释分析结果到底有多准确。</p>
<h3 id="避开的方法">避开的方法</h3>
<ol type="1">
<li>sound core：部分特性能够Sound分析，特定部分或者太难分析的部分会 under-approximate。提取出适合的作为语言的sound core。</li>
<li>难以分析的特性考虑采取临时策略。</li>
</ol>
<h3 id="soundy">Soundy</h3>
<p>soundy的分析能在unsound处理部分特性的基础上，尽可能抓住所有程序可能的行为。unsound的分析是为了速度或效率等因素，存在忽视部分unsound的行为。</p>
<h3 id="java-reflection">Java Reflection</h3>
<p>最难处理的特性。如果碰到了不分析，肯定会损失一些函数调用、变量赋值。</p>
<ol type="1">
<li>StringConstantanalysis+PointerAnalysis：如果class名，method名，field名是静态字符串，则可以进行分析。</li>
<li>TypeInference+Stringanalysis+PointerAnalysis：调用点看看有没有已知类型的参数（借助指针分析），缩小被调用方法的范围。另外看返回值如果被强制类型转换通过返回值类型推断。getFiled操作通过object的类型，也可以通过返回值的强制类型转换。setField操作通过object类型和传入的类型判断。</li>
<li>Assisted by Dynamic Analysis：custom class loader。</li>
</ol>
<h3 id="native-code">Native code</h3>
<p>感觉native code，除了实现功能，操作起java来就是reflection式的操作。</p>
<ol type="1">
<li>手动对关键native代码建模：分析时使用Java代码模拟、描述JNI的效果。</li>
<li>BinaryScanning</li>
</ol>
<h2 id="cfl-reachability-and-ifds">16 CFL-Reachability and IFDS</h2>
<p>一方面通过定义Realizable的路径，通过识别并去除un-Realizable的路径，CFL-Reachability，达到了函数调用路径匹配的效果，而不需要Context-sensetive。 TODO CFL-Reachability不太懂</p>
<p>另外学习怎么构造Exploded Supergraph，构造出来就可以发现，可以将部分程序分析问题表达在图上，通过图可达性解决程序分析问题。</p>
<h3 id="函数调用流匹配">函数调用流匹配</h3>
<p>回忆Meet-Over-all-path，是将所有可能的路径找出，依次计算每个路径，再合并。在函数调用过程中的调用边和return边匹配，导致走return边的时候只有一条真正路径<code>RealizablePaths</code>，其他的并不是真正可执行的路径。</p>
<p>这种调用边导致的问题，可以通过类似括号匹配的算法识别不对的路径并避免。这里引入context-free language，若某路径在该语言中，称为有CFL-Reachability。调用边作为左括号，加上特有标号，只和同样标号的return边匹配。中间可以有任意的普通边。这里识别的是任意点到任意点的路径，不一定是完整的路径，因此可能会留下待之后被匹配的左括号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realizable -&gt; matched realizable</span><br><span class="line">-&gt; (_i realizable</span><br><span class="line">-&gt; ε</span><br><span class="line">matched -&gt; (_i matched )_i</span><br><span class="line">-&gt; e</span><br><span class="line">-&gt; ε</span><br><span class="line">-&gt; matched matched</span><br></pre></td></tr></table></figure>
<h3 id="ifdsinterproceduralfinitedistributivesubset-problem">IFDS(Interprocedural,Finite,Distributive,Subset Problem)</h3>
<p>IFDS处理跨函数的数据流分析，在有限域上，基于distributive的flow function。提供meet-over-all-realizable-paths(MRP)的结果。主要步骤：</p>
<ol type="1">
<li>构建super graph<span class="math inline">\(G^*\)</span>（即带call边和return边）</li>
<li>根据需要分析的问题，定义edge的flow function</li>
<li>构建exploded supergraph <span class="math inline">\(G^\#\)</span>，将流函数转换为graph。TODO</li>
<li>将需要分析的问题Q通过图可达性解决：在<span class="math inline">\(G^\#\)</span> 上用Tabulation algorithm。</li>
</ol>
<p>Path function 记作 <span class="math inline">\(pf_P\)</span>，是某条path p上所有Flow Function的复合。 <span class="math display">\[
pf_P=f_n\circ...\circ f_2\circ f_1
\]</span> MOP和MRP的区别就在于只取了部分realizable的path。 <span class="math display">\[
MOP_n =\mathop{\sqcup}\limits_{P\in Paths(start,n)} pf_p(\bot)
\]</span></p>
<p><span class="math display">\[
MRP_n =\mathop{\sqcup}\limits_{P\in RPaths(start,n)} pf_p(\bot)
\]</span></p>
<h3 id="supergraph">Supergraph</h3>
<p><span class="math display">\[
G^*=(N^*,E^*)
\]</span></p>
<p>将每个函数的flow graph <span class="math inline">\(G_1,G_2,...\)</span>放在一起，每个唯一的入口点为<span class="math inline">\(s_p\)</span>，唯一的出口点为<span class="math inline">\(e_p\)</span>。每个函数调用点设置node为call node <span class="math inline">\(Call_p\)</span>，return的点设置node<span class="math inline">\(Ret_p\)</span>。</p>
<p>每个函数调用有三条边：</p>
<ol type="1">
<li>call-to-return-site edge：<span class="math inline">\(Call_p\)</span>到 <span class="math inline">\(Ret_p\)</span>的短边</li>
<li>call-to-start edge：<span class="math inline">\(Call_p\)</span>到<span class="math inline">\(s_p\)</span>的调用边</li>
<li>exit-to-return-site edge：<span class="math inline">\(e_p\)</span> 到<span class="math inline">\(Ret_p\)</span>的返回边。</li>
</ol>
<p>最后要给每条边加上lambda函数，首先明确研究的问题</p>
<p>我们定义研究的问题是未初始化的变量被使用的问题。S表示为初始化的变量集合。初始的时候设置为所有变量：<code>λS.&#123;x,g&#125;</code>，每次初始化变量<code>x=0</code>就删去对应的变量：<code>λS.S-&#123;x&#125;</code>。</p>
<p>加上lambda函数的要点：</p>
<ol type="1">
<li>虚线（调用边和返回边）不传递当前的局部变量，只传递参数（和全局变量）。由call to return 小短边传递局部变量。全局变量也从call边流入，让未初始化的全局变量从return边流回。</li>
<li>调用边的lambda函数需要将传入的参数重命名。返回边需要删去离开作用域的局部变量</li>
<li>使用已有的变量运算需要注意未初始化变量的污染性，运算如果有未初始化值参与，结果也是未初始化的。</li>
</ol>
<figure>
<img src="image-20210128124537981.png" alt="image-20210128124537981" /><figcaption aria-hidden="true">image-20210128124537981</figcaption>
</figure>
<h3 id="exploded-supergraph">exploded supergraph</h3>
<p>representation relation <span class="math inline">\(R_f\)</span>指的是之前讲到的lambda函数的关系形式的表示，用于构建Exploded Supergraph。Exploded Supergraph将原有的Supergraph的每个节点变成（"explode into"）D+1个节点，每条边变成对应λ函数的关系表示而得到的巨大的图。</p>
<ol type="1">
<li>边merge的时候怎么办？当然是直接将输出使用同一套节点，此时节点会被多次指向。这差不多是并运算吧。</li>
</ol>
<h4 id="representation-relation">representation relation</h4>
<p>D+1个输入节点，D+1个输出节点。关系就是这（D+1）×（D+1）上有序对的集合。 <span class="math display">\[
R_f = \{(0,0)\} \qquad Edge: 0 \rightarrow 0 \\
\cup \{(0,y)|y\in f(\phi) \} \qquad Edge: 0 \rightarrow d_1 \\
\cup \{ (x,y)\ |\ y \not\in f(\phi)\ and\ y \in f(\{x\}) \} \qquad Edge: d_1 \rightarrow d_2
\]</span> 公式含义：</p>
<ol type="1">
<li>首先一定有（0，0）边。</li>
<li><span class="math inline">\(f(\phi)\)</span>指即使输入空集（从0节点进入）也能增加的元素。即gen。 TODO check</li>
<li><span class="math inline">\(f(\phi)\)</span>和<span class="math inline">\(f(\phi)\)</span>之外的元素分开考虑。意味着如果存在（0，y1），则不会有其他元素也指向y1。</li>
<li>接下来看<span class="math inline">\(f(\phi)\)</span>之外的元素，是否存在输入x的时候的输出<span class="math inline">\(f(\{x\})\)</span>是对应的y，有则加入（x,y）边。</li>
<li>可以发现，去掉某个元素时（kill），则没有任何边指向它（以它为终点）。</li>
</ol>
<figure>
<img src="image-20210128152531750.png" alt="image-20210128152531750" /><figcaption aria-hidden="true">image-20210128152531750</figcaption>
</figure>
<h4 id="flow-function表达data-fact">Flow Function表达data fact</h4>
<p>看单个flow function的图，如果能走到下方的某个点，则表示此处的OUT包含它。</p>
<p>TODO</p>
<ol type="1">
<li>为什么traditional flow function不能复合到一起？</li>
<li>将多个连接起来的图中入口到出口的可达关系，压缩成单个图，就是将多个flow function复合起来？</li>
</ol>
<figure>
<img src="image-20210128160132226.png" alt="image-20210128160132226" /><figcaption aria-hidden="true">image-20210128160132226</figcaption>
</figure>
<p>此外，此时再回顾之前unrealizable的path的识别，就会发现派上用场了。不只要可达，还要realizable。因此该问题也不是简单的图可达性问题。</p>
<h4 id="tabulation-algorithm">Tabulation Algorithm</h4>
<p>如果存在realizable路径，从&lt;s_main,0&gt;到&lt;n,d&gt;，则表示在n这点处有d这个data fact，此时d会被涂成蓝色。而且提供的是MRP的方案。</p>
<p>简单来说：从起始点开始，把可达的点标记成蓝色。不详细学习算法</p>
<ol type="1">
<li>处理返回的时候，需要找到对应的调用边返回</li>
<li>第一次处理的时候将函数调用总结成一个summary edge。（把整个函数的调用到结束点的可达关系总结起来？？TODO）之后再次调用相同函数的时候复用结果</li>
<li>可达的点都标蓝</li>
</ol>
<h3 id="distributivity">Distributivity</h3>
<ol type="1">
<li><p>能否做常数传播（constant propagation）？它是之前那个比较特殊的，域是无限的。那我只考虑有限的常量可以吗？NO</p>
<p>TODO</p></li>
<li><p>能否做指针分析？NO</p></li>
</ol>
<p>Distributivity（分配性）：F(X^Y) = F(X) ^ F(Y)。</p>
<p>仔细想想flow function的图表示，可以发现无法表示both逻辑，即需要两个输入同时成立，才会成立结果。</p>
<p>如果需要多个input data facts得出一个新的结果，则此时该分析就不满足分配性，不能用IFDS。因为IFDS将每个data fact，和它的传播（每个edge）分开单调考虑了。</p>
<p>思考题：</p>
<figure>
<img src="image-20210128165511145.png" alt="image-20210128165511145" /><figcaption aria-hidden="true">image-20210128165511145</figcaption>
</figure>
<p>TODO</p>
<h4 id="ifds与指针分析">IFDS与指针分析</h4>
<p>看下面的例子：</p>
<figure>
<img src="image-20210128165817475.png" alt="image-20210128165817475" /><figcaption aria-hidden="true">image-20210128165817475</figcaption>
</figure>
<p>这个例子说明通过IFDS进行指针分析的致命问题是别名信息。假设x和y是别名，为了得到正确的结果，需要同时考虑x和y，因此最后分析起来还是不满足分配律的。</p>
<p>TODO</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>PL</tag>
      </tags>
  </entry>
</search>
