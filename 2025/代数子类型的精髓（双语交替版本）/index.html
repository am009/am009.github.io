<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>代数子类型的精髓（双语交替版本） | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一篇论文的中英文翻译版本： 《The Simple Essence of Algebraic Subtyping. Principal Type Inference with Subtyping Made Easy (Functional Pearl)》 --- LIONEL PARREAUX, EPFL, Switzerland">
<meta property="og:type" content="article">
<meta property="og:title" content="代数子类型的精髓（双语交替版本）">
<meta property="og:url" content="https://wjk.moe/2025/%E4%BB%A3%E6%95%B0%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%88%E5%8F%8C%E8%AF%AD%E4%BA%A4%E6%9B%BF%E7%89%88%E6%9C%AC%EF%BC%89/">
<meta property="og:site_name">
<meta property="og:description" content="一篇论文的中英文翻译版本： 《The Simple Essence of Algebraic Subtyping. Principal Type Inference with Subtyping Made Easy (Functional Pearl)》 --- LIONEL PARREAUX, EPFL, Switzerland">
<meta property="og:locale">
<meta property="article:published_time" content="2025-12-09T03:11:12.000Z">
<meta property="article:modified_time" content="2025-12-09T12:04:01.118Z">
<meta property="article:author" content="am009@github.com">
<meta property="article:tag" content="StaticAnalysis">
<meta property="article:tag" content="Decompile">
<meta property="article:tag" content="PL">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/rss.xml" title="" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          
            <a class="nav-icon" target="_blank" rel="noopener" href="https://github.com/am009"><span class="fa fa-github"></span></a>
          
        
        
          <a class="nav-icon" href="/rss.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wjk.moe"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2025/代数子类型的精髓（双语交替版本）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/%E4%BB%A3%E6%95%B0%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%88%E5%8F%8C%E8%AF%AD%E4%BA%A4%E6%9B%BF%E7%89%88%E6%9C%AC%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-12-09T03:11:12.000Z" itemprop="datePublished">2025-12-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Read/">Read</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      代数子类型的精髓（双语交替版本）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一篇论文的中英文翻译版本：</p>
<p>《The Simple Essence of Algebraic Subtyping. Principal Type Inference
with Subtyping Made Easy (Functional Pearl)》 --- LIONEL PARREAUX, EPFL,
Switzerland</p>
<span id="more"></span>
<p>本文使用了 <a
target="_blank" rel="noopener" href="https://tool.latexdiff.cn/">https://tool.latexdiff.cn/</a>
进行OCR与LLM翻译，然后放在这里不断校对和改进翻译。下面是正文。</p>
<p>MLsub extends traditional Hindley-Milner type inference with
subtyping while preserving compact principal types, an exciting new
development. However, its specification in terms of
<em>biunification</em> is difficult to understand, relying on the new
concepts of bisubstitution and polar types, and making use of advanced
notions from abstract algebra. In this paper, we show that these are in
fact not essential to understanding the mechanisms at play in MLsub. We
propose an alternative algorithm called <em>Simple-sub</em>, which can
be implemented efficiently in under 500 lines of code (including
parsing, simplification, and pretty-printing), looks more familiar, and
is easier to understand.</p>
<p>MLsub在保留紧凑主类型的同时，扩展了传统的Hindley-Milner类型推断并引入了子类型，这是一个令人兴奋的新发展。然而，它在<em>biunification</em>方面的具体操作难以理解，依赖于bisubstitution和polar
types的新概念，并使用了抽象代数中的高级概念。我们在本文中展示，这些实际上并非理解MLsub中运作机制的必要条件。我们提出了一种替代算法，称为<em>Simple-sub</em>，它可以在不到500行代码（包括解析、简化和美化打印）的情况下高效实现，显得更加熟悉，且易于理解。</p>
<blockquote>
<p>译者注：这里的Hindley-Milner类型推理算法是一种针对ML语言的类型推理算法。ML语言是一个用于编程语言和类型系统学习和教学的语言。即，《Types
and Programming
Languages》TAPL这本书里就有相关的讲解。了解相关内容对理解本文有帮助，但不是必须的。</p>
</blockquote>
<blockquote>
<p>译者注：不太了解类型系统的，可能不太看得懂这个对MLsub的评价。类比一下的话，ML语言就像是课本里的C语言。子类型是一个非常常用的概念，比如说接口或者继承。MLsub还是很不错的，它在类型推理领域做到的事情，类比一下的话，类似于在编程语言里面引入了接口或者继承。</p>
</blockquote>
<p>We present an experimental evaluation of Simple-sub against MLsub on
a million randomly-generated well-scoped expressions, showing that the
two systems agree. The mutable automaton-based implementation of MLsub
is quite far from its algebraic specification, leaving a lot of space
for errors; in fact, our evaluation uncovered several bugs in it. We
sketch more straightforward soundness and completeness arguments for
Simple-sub, based on a syntactic specification of the type system.</p>
<p>我们对Simple-sub和MLsub在百万个随机生成的良好作用域表达式上的实验评估，展示了这两个系统的一致性。基于自动机的MLsub实现与其代数规范相距甚远，留下了许多出错的空间；实际上，我们的评估发现了其中的几个bug。我们基于类型系统的句法规范，简要概述了Simple-sub更直接的正确性和完备性论证。</p>
<p>This paper is meant to be light in formalism, rich in insights, and
easy to consume for prospective designers of new type systems and
programming languages. In particular, no abstract algebra is inflicted
on readers.</p>
<p>本文旨在保持形式上的简洁，提供丰富的见解，并易于新类型系统和编程语言潜在设计者消化。特别是，未对读者施加任何抽象符号的负担。</p>
<p>The ML family of languages, which encompasses Standard ML, OCaml, and
Haskell, have been designed around a powerful “global” approach to type
inference, rooted in the work of Hindley [1969] and Milner [1978], later
closely formalized by Damas and Milner [1982]. In this approach, the
type system is designed to be simple enough that types can be
unambiguously inferred from terms without the help of any type
annotations. That is, for any well-typed unannotated term, it is always
possible to infer a <em>principal type</em> which subsumes all other
types that can be assigned to this term. For instance, the term <span
class="math inline">\(\lambda x. x\)</span> can be assigned types <span
class="math inline">\(bool \rightarrow bool\)</span> and <span
class="math inline">\(int \rightarrow int\)</span>, but both of these
are subsumed by the polymorphic type <span class="math inline">\(\forall
\alpha. \alpha \rightarrow \alpha\)</span>, also written '<span
class="math inline">\(a \rightarrow &#39;a\)</span>, which is the
principal type of this term.</p>
<p>ML语言家族，包括Standard
ML、OCaml和Haskell，围绕一种强大的“全局”类型推断方法进行设计，这种方法源于Hindley
[1969]和Milner [1978]的工作，后来由Damas和Milner
[1982]进行了紧密的形式化。在这种方法中，类型系统的设计足够简单，以至于可以从术语中不借助任何类型注释不明确地推断出类型。也就是说，对于任何良构的未注释术语，总是可以推断出一个<em>主类型</em>，该主类型包含所有可以分配给该术语的其他类型。例如，术语<span
class="math inline">\(\lambda x. x\)</span>可以被分配类型<span
class="math inline">\(bool \rightarrow bool\)</span>和<span
class="math inline">\(int \rightarrow
int\)</span>，但是这两者都被多态类型<span class="math inline">\(\forall
\alpha. \alpha \rightarrow \alpha\)</span>所包含，也可以写作'<span
class="math inline">\(a \rightarrow
&#39;a\)</span>，这是该术语的主类型。</p>
<p>This “Hindley-Milner” (HM) type inference approach contrasts with
more restricted “local” approaches to type inference, found in languages
like Scala, C#, and Idris, which often require the types of variables to
be annotated explicitly by programmers. On the flip side, abandoning the
principal type property allows these type systems to be more expressive,
and to support features like object orientation and dependent types.
Even ML languages like OCaml and Haskell have adopted type system
features which, when used, break the principal type property<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> and sometimes require explicit type
annotations. Supporting principal types is a delicate tradeoff.</p>
<p>这种“Hindley-Milner”（HM）类型推断方法与更受限制的“局部”类型推断方法形成对比，后者在像Scala、C#和Idris这样的语言中常常需要程序员显式地注释变量的类型。另一方面，放弃主要类型属性使这些类型系统能够更加表达性，并支持像面向对象和依赖类型一样的特性，即使是像
OCaml 和 Haskell 这样的 ML
语言也采纳了类型系统的特性，当这些特性被使用时，会打破主类型属性<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>，有时需要显式的类型注释。支持主类型是一种微妙的权衡。</p>
<p><strong>Subtyping</strong> is an expressive approach allowing types
to be structured into hierarchies — usually a subtyping <em>lattice</em>
— with the property that types can be <em>refined</em> or
<em>widened</em> implicitly following this hierarchy. This lets one
express the fact that some types are more precise (contain more
information) than others, but still have a compatible runtime
representation, so that no coercions between them are needed. For
instance, in a system where the type ‘nat’ is a subtype of ‘int’, one
can transparently use a ‘nat list’ in place where an ‘int list’ is
expected, without having to apply a coercion function on all the
elements of the list. Subtyping can be emulated using somewhat heavy
type system machinery (which both OCaml and Haskell do, to some extent<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>), but first-class support for
subtyping gives the benefit of simpler type signatures and better type
inference.</p>
<p><strong>子类型化</strong>是一种表达能力强的方法，允许将类型结构化为层次——通常是一个子类型
<em>格</em>——其特性是类型可以在这个层次下被<em>细化</em>或<em>扩展</em>，而不需要显式转换。这让人们能表达某些类型比其他类型更精确（包含更多信息），但仍然具有兼容的运行时表示，这样就不需要在它们之间进行任何强制转换。例如，在一个类型‘nat’是‘int’的子类型的系统中，可以透明地在预期为‘int
list’的地方使用‘nat
list’，而无需对列表的所有元素应用强制转换函数。子类型化可以通过一些较复杂的类型系统机制进行模拟（OCaml
和 Haskell 在某种程度上都这样做<a href="#fn4" class="footnote-ref"
id="fnref4"
role="doc-noteref"><sup>4</sup></a>），但是对子类型化的第一类支持则带来了更简单的类型签名和更好的类型推断的好处。</p>
<p>While subtyping is a staple of object-oriented programming (being
used to mirror class inheritance hierarchies), it is by no means limited
to that paradigm, and has found vast domains of applications in
functional programming too, including refinement types for ML data types
[Freeman and Pfenning 1991], lightweight verification [Rondon et al.
2008; Rushby et al. 1998; Vazou et al. 2014], full dependent types
[Hutchins 2010], first-class modules [Amin et al. 2016; Rossberg 2015],
polymorphic variants [Castagna et al. 2016], XML transformations [Hosoya
et al. 2005], and higher-rank polymorphism [Dunfield and Krishnaswami
2013; Odersky and Läufer 1996].</p>
<p>虽然子类型是面向对象编程的基本概念（用于反映类继承层次），但这绝不是该范式的唯一应用，它在函数式编程中也找到了广泛的应用领域，包括
ML 数据类型的细化类型 [Freeman and Pfenning 1991]、轻量级验证 [Rondon et
al. 2008；Rushby et al. 1998；Vazou et al. 2014]、全依赖类型 [Hutchins
2010]、一类模块 [Amin et al. 2016；Rossberg 2015]、多态变体 [Castagna et
al. 2016]、XML 转换 [Hosoya et al. 2005] 和高阶多态 [Dunfield and
Krishnaswami 2013；Odersky and Läufer 1996]。</p>
<p>For a long time, it was widely believed that implicit subtyping got
in the way of satisfactory global type inference. Indeed, previous
approaches to inferring subtypes failed to support principal types, or
resulted in the inference of large types containing sets of unwieldy
constraints, making them difficult to understand by programmers.</p>
<p>长期以来，人们普遍认为隐式子类型妨碍了令人满意的全局类型推断。事实上，以前的推断子类型的方法未能支持主要类型，或者导致推断出包含一组难以处理的约束的大类型，使得程序员难以理解。</p>
<p><strong>MLsub</strong> was introduced by Dolan and Mycroft [2017] as
an ML-style type system supporting subtyping, polymorphism, and global
type inference, while still producing compact principal types. Here,
<em>compact</em> refers to the fact that the inferred types are
relatively simple type expressions without any visible constraints,
making them easy to read and understand. This was achieved by carefully
designing the semantics of the subtyping lattice using an
<em>algebra-first</em> approach, also referred to as <strong>algebraic
subtyping</strong> [Dolan 2017].</p>
<p><strong>MLsub</strong> 是由 Dolan 和 Mycroft [2017] 提出的 ML
风格类型系统，支持子类型、多态和全局类型推断，同时仍然生成紧凑的主类型。这里的
<em>compact</em>
指的是推断出的类型是相对简单的类型表达式，且没有任何明显的约束，使得它们易于阅读和理解。这是通过精心设计子类型格的语义，采用
<em>algebra-first</em> 方法实现的，这也被称为 <strong>algebraic
subtyping</strong> [Dolan 2017]。</p>
<p>However, the specification of MLsub’s type inference algorithm as
<em>biunification</em> is difficult to understand for experts and
non-experts alike. On the surface, it looks more complicated than the
<em>algorithm W</em> traditionally used for HM type systems, requiring
additional concepts such as bisubstitution, polar types, and advanced
notions from abstract algebra. Although its elegant presentation will
appeal to mathematically-minded researchers, experience has shown that
grasping an understanding of the approach complete enough to reimplement
the algorithm required reading Dolan’s thesis in full, and sometimes
more [Courant 2018].</p>
<p>然而，MLsub 的类型推断算法的规范被称为 <em>biunification</em>
对于专家和非专家来说都很难理解。从表面上看，它看起来比传统上用于 HM
类型系统的 <em>algorithm W</em> 更复杂，要求引入诸如
bisubstitution、polar types
和抽象代数中的高级概念等额外概念。尽管其优雅的呈现方式将吸引有数学思维的研究人员，但经验表明，要完全掌握该方法以重新实现算法，通常需要通读
Dolan 的论文，有时还需要更多的阅读 [Courant 2018]。</p>
<p>Thankfully, it turns out that the essence of algebraic subtyping can
be captured by a much simpler algorithm, <strong>Simple-sub</strong>,
which is also more efficient than biunification (or at least, than the
basic syntax-driven form of biunification used as a specification for
MLsub<a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>). In this paper, we show that
inferring MLsub types is surprisingly easy, and can be done in under 300
lines of Scala code, with an additional 200 lines of code for
simplification and pretty-printing. Simple-sub is available online at <a
target="_blank" rel="noopener" href="https://github.com/LPTK/simple-sub">https://github.com/LPTK/simple-sub</a>.
While the implementation we present is written in Scala, it is
straightforward to translate into any other functional programming
languages.</p>
<p>值得庆幸的是，代数子类型的本质可以通过一个更简单的算法<strong>Simple-sub</strong>来捕获，该算法在效率上也优于双一化（至少优于作为MLsub<a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>规范使用的基本语法驱动形式）。在本文中，我们展示了推导MLsub类型是出乎意料的简单，并且可以在不到300行的Scala代码中完成，另外再增加200行代码用于简化和美化输出。Simple-sub可以在<a
target="_blank" rel="noopener" href="https://github.com/LPTK/simple-sub">https://github.com/LPTK/simple-sub</a>
在线获取。尽管我们提出的实现是用Scala编写的，但将其转换为其他功能性编程语言是非常简单的。</p>
<p><strong>Our main contribution</strong> is to recast MLsub into a
simpler mold and to disentangle its algebraic construction of types from
the properties actually needed by the type inference and type
simplification processes. We believe this will allow future designers of
type systems and programming languages to benefit from some of the great
insights of the approach, without having to delve too deeply into the
theory of algebraic subtyping. In the rest of this paper, we:</p>
<p><strong>我们的主要贡献</strong>
是将MLsub重新塑造为一个更简单的模型，并将其类型的代数构造与类型推理和类型简化过程实际需要的属性解开。我们相信将使未来的类型系统和编程语言设计者能够从这种方法的一些重要见解中受益，而无需深入研究代数子类型理论。在本文的其余部分，我们：</p>
<ul>
<li>present MLsub and the <em>algebraic subtyping</em> discipline on
which it is based (Section 2);</li>
<li>describe our new Simple-sub type inference algorithm (Section
3);</li>
<li>explain how to perform basic simplification on the types inferred by
Simple-sub (Section 4);</li>
<li>sketch the correctness proofs of Simple-sub through
<em>soundness</em> and <em>completeness</em> theorems, formalizing the
minimal subtyping relation needed to carry out these proofs. (Section
5);</li>
<li>describe our experimental evaluation: we verified that Simple-sub
and MLsub agreed on the results of type inference for over a million
automatically-generated programs (Section 6).</li>
</ul>
<hr />
<ul>
<li>介绍 MLsub 及其所基于的 <em>algebraic subtyping</em> 学科（第 2
节）；</li>
<li>描述我们新的 Simple-sub 类型推断算法（第 3 节）；</li>
<li>解释如何对由 Simple-sub 推断出的类型进行基本简化（第 4 节）；</li>
<li>通过 <em>soundness</em> 和 <em>completeness</em> 定理勾勒 Simple-sub
的正确性证明，形式化进行这些证明所需的最小子类型关系。（第 5 节）；</li>
<li>描述我们的实验评估：我们验证了 Simple-sub 和 MLsub
在超过一百万个自动生成的程序的类型推断结果上是一致的（第 6 节）。</li>
</ul>
<h1 id="algebraic-subtyping-and-mlsub">Algebraic Subtyping and
MLsub</h1>
<h1 id="代数子类型和mlsub">2 代数子类型和MLsub</h1>
<p>Let us first describe MLsub and the algebraic subtyping philosophy
that underlies its design.</p>
<p>让我们首先描述 MLsub 及其设计所依据的代数子类型哲学。</p>
<h2 id="background-on-algebraic-subtyping">2.1 Background on Algebraic
Subtyping</h2>
<h2 id="代数子类型的背景">2.1 代数子类型的背景</h2>
<p>There are at least three major schools of thought on formalizing
subtyping. <em>Syntactic approaches</em>, as in this paper, use direct
specifications (usually given as inference rules) for the subtyping
relationship, closely following the syntax of types. <em>Semantic
approaches</em> [Frisch et al. 2008] view types as sets of values which
inhabit them, and define the subtyping relationship as set inclusion
between these sets. <em>Algebraic approaches</em> [Dolan 2017] define
types as abstract elements of a distributive lattice, whose algebraic
properties are carefully chosen to yield good properties, such as
“extensibility” and principal types.</p>
<p>Syntactic approaches somehow pay for their simplicity by forcing type
system designers to consider the consequences and interactions of all
their inference rules, having to manually verify that they result in a
subtyping relationship with the desired algebraic properties.</p>
<p>The semantic approach is probably the most intuitive, and is also
very powerful; however, it suffers from difficulties related to
polymorphism – an understanding of type variables as <em>ranging</em>
over ground types can lead to paradoxes and a lack of extensibility
[Dolan 2017].</p>
<p>关于形式化子类型，至少有三种主要的思想流派。<em>语法方法</em>，如本文所述，使用直接的规范（通常以推理规则的形式给出）来描述子类型关系，紧密跟随类型的语法。<em>语义方法</em>
[Frisch et al. 2008]
将类型视为其所占用的值的集合，并将子类型关系定义为这些集合之间的集合包含关系。<em>代数方法</em>
[Dolan 2017]
将类型定义为分布格的抽象元素，其代数性质经过精心选择，以产生良好的性质，如“可扩展性”和主类型。</p>
<p>句法方法在某种程度上因其简单性而付出了代价，使类型系统设计者必须考虑所有推理规则的后果和相互作用，手动验证它们是否产生具有所需代数性质的子类型关系。</p>
<p>语义方法可能是最直观的，且也非常强大；然而，它受到与多态性相关的困难的困扰——将类型变量理解为<em>范围</em>在基础类型上可能导致悖论和缺乏可扩展性
[Dolan 2017]。</p>
<p>As a response to these perceived shortcomings, Dolan argues that
<em>algebra</em> (not <em>syntax</em>) should come first, in order to
guarantee from the start that type systems are well-behaved, as opposed
to ensuring it as a sort of afterthought. In particular, he emphasizes
the concept of <em>extensibility</em> of type systems, the idea being
that existing programs should remain well-typed when new type forms are
added. While the practical usefulness of this notion of extensibility is
unclear,<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a> the general approach of making the
subtyping lattice <em>distributive</em> does help simplify types
aggressively and construct algorithms for checking subsumption
effectively (i.e., checking whether one type signature is as general as
another).</p>
<p>In the rest of this section, we explain the basics of MLsub and its
static semantics, to set the stage for the presentation of Simple-sub in
Section 3.</p>
<p>作为对这些被认为的不足之处的回应，Dolan 认为 <em>algebra</em>（而不是
<em>syntax</em>）应该优先考虑，以确保从一开始就保证类型系统的良好行为，而不是将其视为一种事后考虑。尤其是，他强调了类型系统的
<em>extensibility</em>
概念，核心思想是当添加新的类型形式时，现有程序应该保持良好的类型。虽然这种可拓展性的实际有用性尚不明确，<a
href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a> 但使子类型格 <em>distributive</em>
的一般方法确实有助于有效地简化类型并构建检查包含关系的算法（即检查一个类型签名是否与另一个一样通用）。</p>
<p>在本节的其余部分，我们将解释 MLsub 的基础及其静态语义，为第 3 节中
Simple-sub 的介绍奠定基础。</p>
<h2 id="basics-of-mlsub">2.2 Basics of MLsub</h2>
<p>2.2.1 Term Language. The term syntax of MLsub is given in Figure 1.
We make some simplifications compared to the original MLsub
presentation: first, we omit boolean literals and if-then-else, as they
can easily be typed as primitive combiners; second, we use only one form
of variables x (MLsub distinguished between lambda-bound and let-bound
variables, for technical reasons).</p>
<p><span class="math display">\[t ::= x | \lambda x. t | t t | \{ l_0 =
t; \dots; l_n = t \} | t.l | \text{let rec } x = t \text{ in }
t\]</span></p>
<p>Fig. 1. Syntax of MLsub terms, for which we want to infer types.</p>
<h2 id="mlsub基础">2.2 MLsub基础</h2>
<p>2.2.1
项语言。MLsub的项语法如图1所示。与原始的MLsub介绍相比，我们进行了一些简化：首先，我们省略布尔字面量和if-then-else，因为它们可以很容易地被归类为原始组合子；第二，我们仅使用一种形式的变量x（MLsub在技术原因上区分了lambda绑定和let绑定的变量）。</p>
<p><span class="math display">\[ t ::= x | \lambda x. t | t t | \{ l_0 =
t; \dots; l_n = t \} | t.l | \text{let rec } x = t \text{ in } t
\]</span></p>
<p>图1. MLsub项的语法，我们希望推导其类型。</p>
<p>2.2.2 Type Language. The type syntax of MLsub, summarized in Figure
2, consists in primitive types (such as int and bool) function types,
record types, type variables, top <span
class="math inline">\(\top\)</span> (the type of all values — supertype
of all types), bottom <span class="math inline">\(\bot\)</span> (the
type of no values — subtype of all types), type union <span
class="math inline">\(\sqcup\)</span>, type intersection <span
class="math inline">\(\sqcap\)</span>, and recursive types <span
class="math inline">\(\mu\alpha.\tau\)</span>.</p>
<p><span class="math display">\[\tau ::= \text{primitive} | \tau \to
\tau | \{ l_0 : \tau; \dots; l_n : \tau \} | \alpha | \top | \bot | \tau
\sqcup \tau | \tau \sqcap \tau | \mu\alpha.\tau\]</span></p>
<p>Fig. 2. Syntax of MLsub types.</p>
<p>2.2.2 类型语言。MLsub 的类型语法如图 2 所示，包含基本类型（如 int 和
bool）、函数类型、记录类型、类型变量、上界 <span
class="math inline">\(\top\)</span>（所有值的类型——所有类型的超类型）、下界
<span
class="math inline">\(\bot\)</span>（没有值的类型——所有类型的子类型）、类型并
$ $、类型交 $ $ 和递归类型 $ .$。</p>
<p><span class="math display">\[
\tau ::= \text{primitive} | \tau \to \tau | \{ l_0 : \tau; \dots; l_n :
\tau \} | \alpha | \top | \bot | \tau \sqcup \tau | \tau \sqcap \tau |
\mu\alpha.\tau
\]</span></p>
<p>图 2. MLsub 类型的语法。</p>
<p>2.2.3 Type System. The declarative type system of MLsub is given in
Figure 3. It is mostly as presented by Dolan and Mycroft [2017]. We
support recursive let bindings explicitly for clarity, though recursion
could also be factored out into a combinator [Damas and Milner 1982]. We
write <span class="math inline">\(\overline{E}^i\)</span> for a
repetition of elements E indexed by i. Of particular interest are the
rules T-SUB, which takes a term from a subtype to a supertype implicitly
(without a term-level coercion), T-LET, which types x in its recursive
right-hand side in a monomorphic way, but types x in its body
polymorphically, and T-VAR, which instantiates polymorphic types using
the substitution syntax <span
class="math inline">\([\tau_0/\alpha_0]\tau\)</span>.</p>
<p>We appeal to the reader's intuition and leave the precise definition
of subtyping unspecified for now, as it requires some technicalities
around recursive types. In contrast to MLsub, which gives an algebraic
account of subtyping, we will present a syntactic subtyping system in
Section 5.1.</p>
<p><span class="math display">\[
\text{T-LIT:} \quad \frac{}{\Gamma \vdash n : \text{int}}
\]</span></p>
<p><span class="math display">\[
\text{T-VAR:} \quad \frac{\Gamma(x) = \overline{\forall \alpha_i.\,
\tau}^i}{\Gamma \vdash x : [\tau_i / \alpha_i]^i \tau}
\]</span></p>
<p>2.2.3 类型系统。MLsub 的声明性类型系统如图 3 所示。它大部分与 Dolan
和 Mycroft [2017] 的介绍相同。为了清晰起见，我们显式支持递归 let
绑定，尽管递归也可以被抽象为一个组合子 [Damas 和 Milner 1982]。我们用
<span class="math inline">\(\overline{E}^i\)</span> 表示索引为 i 的元素
E 的重复。特别值得关注的是规则
T-SUB，它隐式地将一个子类型的项转换为超类型（没有项级的强制转换），规则
T-LET，它以单一类型的方式类型化其递归右侧的
x，但在其主体中以多态的方式类型化 x，以及规则 T-VAR，它使用替换语法
<span class="math inline">\([\tau_0/\alpha_0]\tau\)</span>
实例化多态类型。</p>
<p>我们借用读者的直觉，目前暂时不对子类型的精确定义进行说明，因为这涉及到递归类型的一些技术细节。与
MLsub 提供的代数子类型描述相比，我们将在第 5.1
节中展示一个语法子类型系统。</p>
<p><span class="math display">\[
\text{T-LIT:} \quad \frac{}{\Gamma \vdash n : \text{int}}
\]</span></p>
<p><span class="math display">\[
\text{T-VAR:} \quad \frac{\Gamma(x) = \overline{\forall \alpha_i.\,
\tau}^i}{\Gamma \vdash x : [\tau_i / \alpha_i]^i \tau}
\]</span></p>
<p><span class="math display">\[
\text{T-ABS:} \quad \frac{\Gamma, x : \tau_1 \vdash t : \tau_2}{\Gamma
\vdash \lambda x.\, t : \tau_1 \to \tau_2}
\]</span></p>
<p><span class="math display">\[
\text{T-APP:} \quad \frac{\Gamma \vdash t_0 : \tau_1 \to \tau_2 \quad
\Gamma \vdash t_1 : \tau_1}{\Gamma \vdash t_0\, t_1 : \tau_2}
\]</span></p>
<p><span class="math display">\[
\text{T-RCD:} \quad \frac{\Gamma \vdash t_i : \tau_i^i}{\Gamma \vdash \{
l_i = t_i \}^i : \{ l_i : \tau_i \}^i}
\]</span></p>
<p><span class="math display">\[
\text{T-PROJ:} \quad \frac{\Gamma \vdash t : \{ l : \tau \}}{\Gamma
\vdash t.l : \tau}
\]</span></p>
<p><span class="math display">\[
\text{T-SUB:} \quad \frac{\Gamma \vdash t : \tau_1 \quad \tau_1 \leq
\tau_2}{\Gamma \vdash t : \tau_2}
\]</span></p>
<p><span class="math display">\[
\text{T-LET:} \quad \frac{\Gamma, x : \tau_1 \vdash t_1 : \tau_1 \quad
\Gamma, x : \overline{\forall \alpha_i.\, \tau_1}^i \vdash t_2 :
\tau_2}{\Gamma \vdash \mathbf{let}\ \mathbf{rec}\ x = t_1\ \mathbf{in}\
t_2 : \tau_2}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{succ} &amp;: \text{int} \to \text{int} \\
\text{iszero} &amp;: \text{int} \to \text{bool} \\
\text{true} &amp;: \text{bool} \\
\text{false} &amp;: \text{bool} \\
\text{if} &amp;: \forall \alpha.\, \text{bool} \to \alpha \to \alpha \to
\alpha
\end{align*}
\]</span></p>
<p>Fig. 3. Declarative typing rules of MLsub (and Simple-sub).</p>
<h2 id="informal-semantics-of-types">2.3 Informal Semantics of
Types</h2>
<p><span class="math display">\[
\text{T-ABS:} \quad \frac{\Gamma, x : \tau_1 \vdash t : \tau_2}{\Gamma
\vdash \lambda x.\, t : \tau_1 \to \tau_2}
\]</span></p>
<p><span class="math display">\[
\text{T-APP:} \quad \frac{\Gamma \vdash t_0 : \tau_1 \to \tau_2 \quad
\Gamma \vdash t_1 : \tau_1}{\Gamma \vdash t_0\, t_1 : \tau_2}
\]</span></p>
<p><span class="math display">\[
\text{T-RCD:} \quad \frac{\Gamma \vdash t_i : \tau_i^i}{\Gamma \vdash \{
l_i = t_i \}^i : \{ l_i : \tau_i \}^i}
\]</span></p>
<p><span class="math display">\[
\text{T-PROJ:} \quad \frac{\Gamma \vdash t : \{ l : \tau \}}{\Gamma
\vdash t.l : \tau}
\]</span></p>
<p><span class="math display">\[
\text{T-SUB:} \quad \frac{\Gamma \vdash t : \tau_1 \quad \tau_1 \leq
\tau_2}{\Gamma \vdash t : \tau_2}
\]</span></p>
<p><span class="math display">\[
\text{T-LET:} \quad \frac{\Gamma, x : \tau_1 \vdash t_1 : \tau_1 \quad
\Gamma, x : \overline{\forall \alpha_i.\, \tau_1}^i \vdash t_2 :
\tau_2}{\Gamma \vdash \mathbf{let}\ \mathbf{rec}\ x = t_1\ \mathbf{in}\
t_2 : \tau_2}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{succ} &amp;: \text{int} \to \text{int} \\
\text{iszero} &amp;: \text{int} \to \text{bool} \\
\text{true} &amp;: \text{bool} \\
\text{false} &amp;: \text{bool} \\
\text{if} &amp;: \forall \alpha.\, \text{bool} \to \alpha \to \alpha \to
\alpha
\end{align*}
\]</span></p>
<p>图 3. MLsub（和 Simple-sub）的声明性类型规则。</p>
<h2 id="类型的非正式语义">2.3 类型的非正式语义</h2>
<p>While most MLsub type forms are usual and unsurprising, two kinds of
types require our special attention: set-theoretic types (especially
unions and intersections), and recursive types.</p>
<h3 id="set-theoretic-types.">2.3.1 Set-Theoretic Types.</h3>
<p>To a first approximation, union and intersection types can be
understood in set-theoretic terms: <span class="math inline">\(τ_0 ⊔
τ_1\)</span> (resp. <span class="math inline">\(τ_0 ⊕ τ_1\)</span>)
represents the type of values that are either (resp. both) of type <span
class="math inline">\(τ_0\)</span> or (resp. and) of type <span
class="math inline">\(τ_1\)</span>.</p>
<p>MLsub uses these types to indirectly constrain type variables: When a
type variable <span class="math inline">\(α\)</span> is supposed to be a
<em>subtype</em> of some type <span class="math inline">\(τ\)</span>
(i.e., values of type <span class="math inline">\(α\)</span> may be used
at type <span class="math inline">\(τ\)</span>), MLsub substitutes all
occurrences of <span class="math inline">\(α\)</span> in input position
with <span class="math inline">\(α ⊔ τ\)</span>, making sure that any
arguments passed in as <span class="math inline">\(α\)</span> values are
also <span class="math inline">\(τ\)</span> values. Similarly, when
<span class="math inline">\(α\)</span> is supposed to be a
<em>supertype</em> of some <span class="math inline">\(τ\)</span> (i.e.,
values of type <span class="math inline">\(τ\)</span> may be used at
type <span class="math inline">\(α\)</span>), MLsub substitutes all
occurrences of <span class="math inline">\(α\)</span> in output position
with <span class="math inline">\(α ⊔ τ\)</span>, making sure that
results returned as <span class="math inline">\(α\)</span> values are
also <span class="math inline">\(τ\)</span> values.</p>
<p>虽然大多数 MLsub
类型形式是常见且不令人惊讶的，但有两种类型需要我们特别关注：集合论类型（尤其是并集和交集）和递归类型。</p>
<h3 id="集合论类型">2.3.1 集合论类型</h3>
<p>初步来看，联结类型和交集类型可以用集合论术语来理解：<span
class="math inline">\(τ_0 ⊔ τ_1\)</span>（分别为 <span
class="math inline">\(τ_0 ⊕
τ_1\)</span>）表示的值的类型要么是（分别是）<span
class="math inline">\(τ_0\)</span> 类型，要么是（分别是）<span
class="math inline">\(τ_1\)</span> 类型。</p>
<p>MLsub 使用这些类型来间接约束类型变量：当一个类型变量 <span
class="math inline">\(α\)</span> 应该是某类型 <span
class="math inline">\(τ\)</span> 的 <em>子类型</em> 时（即，类型为 <span
class="math inline">\(α\)</span> 的值可以在类型 <span
class="math inline">\(τ\)</span> 中使用），MLsub 会用 <span
class="math inline">\(α ⊔ τ\)</span> 替换输入位置中所有 <span
class="math inline">\(α\)</span> 的出现，确保作为 <span
class="math inline">\(α\)</span> 值传入的任何参数也是 <span
class="math inline">\(τ\)</span> 值。类似地，当 <span
class="math inline">\(α\)</span> 应该是某个 <span
class="math inline">\(τ\)</span> 的 <em>超类型</em> 时（即，类型为 <span
class="math inline">\(τ\)</span> 的值可以在类型 <span
class="math inline">\(α\)</span> 中使用），MLsub 会用 <span
class="math inline">\(α ⊔ τ\)</span> 替换输出位置中所有 <span
class="math inline">\(α\)</span> 的出现，确保作为 <span
class="math inline">\(α\)</span> 值返回的结果也是 <span
class="math inline">\(τ\)</span> 值。</p>
<p>As an example, one type inferred for the term <span
class="math inline">\(λx. \{ L = x - 1; R = x \}\)</span> could be <span
class="math inline">\(α ⊕ int → \{ L : int; R : α \}\)</span>, assuming
operator <span class="math inline">\((-)\)</span> has type <span
class="math inline">\(int → int → int\)</span>. This type reflects the
fact that the original argument, of some type <span
class="math inline">\(α\)</span>, is returned in the R field of the
result record (as the input of the function ends up in that position),
but also that this argument should be able to be treated as an int,
expressed via the type intersection <span class="math inline">\(α ⊕
int\)</span> on the left-hand side of the function type. Keeping track
of the precise argument type <span class="math inline">\(α\)</span> is
important: it could be later substituted with a more specific type than
int, such as <span class="math inline">\(α = nat\)</span>, which would
give us <span class="math inline">\(nat → \{ L : int; R : nat
\}\)</span>. On the other hand, there may be type signatures where <span
class="math inline">\(α\)</span> becomes undistinguishable from int. For
instance, consider the term '<span class="math inline">\(λx. if true
then x - 1 else x\)</span>', whose simplified inferred type would be
just int → int, as the seemingly-more precise type <span
class="math inline">\(α ⊕ int → α ⊔ int\)</span> does not actually
contain more information (we expand on this in Section 4.3.1).</p>
<p>作为一个例子，术语 <span class="math inline">\(λx. \{ L = x - 1; R =
x \}\)</span> 推断出的一个类型可以是 <span class="math inline">\(α ⊕ int
→ \{ L : int; R : α \}\)</span>，假设运算符 <span
class="math inline">\((-)\)</span> 的类型为 <span
class="math inline">\(int → int →
int\)</span>。这个类型反映了一个事实，即原始参数，某个类型为 <span
class="math inline">\(α\)</span> 的值，被返回在结果记录的 R
字段中（因为函数的输入最终位于这个位置），同时也表明这个参数应该能够被视为一个
int，通过函数类型左侧的类型交集 <span class="math inline">\(α ⊕
int\)</span> 表达。跟踪精确的参数类型 <span
class="math inline">\(α\)</span> 是重要的：它可以在后面用比 int
更具体的类型替代，例如 <span class="math inline">\(α =
nat\)</span>，这将给我们 <span class="math inline">\(nat → \{ L : int; R
: nat \}\)</span>。另一方面，可能存在某些类型签名，其中 <span
class="math inline">\(α\)</span> 变得与 int 无法区分。例如，考虑术语
'<span class="math inline">\(λx. if true then x - 1 else
x\)</span>，其简化后的推断类型将只是 int → int，因为看似更精确的类型
<span class="math inline">\(α ⊕ int → α ⊔ int\)</span>
实际上并未包含更多信息（我们将在第 4.3.1 节中对此进行扩展）。</p>
<p>The beauty of MLsub is that this sort of reasoning scales to
arbitrary flows of variables and higher-order functions; for instance,
the previous example can be generalized by passing in a function <span
class="math inline">\(f\)</span> to stand for the <span
class="math inline">\(· - 1\)</span> operation, as in <span
class="math inline">\(λf. λx. \{ L = f x; R = x \}\)</span> whose type
could be inferred as <span class="math inline">\((β → γ) → α ⊕ β → \{ L
: γ; R : α \}\)</span> and further simplified to <span
class="math inline">\((α → γ) → α → \{ L : γ; R : α \}\)</span>.
Applying this function to argument <span class="math inline">\((λx. x -
1)\)</span> yields the same type (after simplification) as in the
example of the previous paragraph.</p>
<h3 id="recursive-types.">2.3.2 Recursive Types.</h3>
<p>A recursive type <span class="math inline">\(μα. τ\)</span>
represents a type we can unroll as many times as we want; for instance,
<span class="math inline">\(μα. (T → α)\)</span>, which we write just
<span class="math inline">\(μα. T → α\)</span>, is equivalent to <span
class="math inline">\(T → μα. T → α\)</span>, which is equivalent to
<span class="math inline">\(T → T → μα. T → α\)</span>, etc., and is the
type of a function that can be applied to any arguments (any subtypes of
<span class="math inline">\(T\)</span>) indefinitely. A recursive type
is conceptually infinite — if we unrolled the above fully, it would
unfold as an infinitely-deep tree <span class="math inline">\(T → T → T
→ ...\)</span></p>
<p>MLsub
的美在于这种推理可以扩展到任意的变量流和高阶函数；例如，之前的例子可以通过传递一个函数
<span class="math inline">\(f\)</span> 来代表 <span
class="math inline">\(· - 1\)</span> 操作进行广义化，如 <span
class="math inline">\(λf. λx. \{ L = f x; R = x
\}\)</span>，其类型可以推断为 <span class="math inline">\((β → γ) → α ⊕
β → \{ L : γ; R : α \}\)</span>，进一步简化为 <span
class="math inline">\((α → γ) → α → \{ L : γ; R : α
\}\)</span>。将此函数应用于参数 <span class="math inline">\((λx. x -
1)\)</span> 产生与前一段示例相同的类型（经过简化后）。</p>
<h3 id="递归类型">2.3.2 递归类型。</h3>
<p>递归类型 <span class="math inline">\(μα. τ\)</span>
代表一个我们可以展开任意次的类型；例如，<span class="math inline">\(μα.
(T → α)\)</span>，我们简写为 <span class="math inline">\(μα. T →
α\)</span>，它等同于 <span class="math inline">\(T → μα. T →
α\)</span>，进一步等同于 <span class="math inline">\(T → T → μα. T →
α\)</span>，等等，这就是一个可以无限期应用于任何参数（T
的任何子类型）的函数的类型。递归类型在概念上是无限的——如果我们完全展开上述内容，它将展现为一个无限深的树
<span class="math inline">\(T → T → T → ...\)</span></p>
<p>If this sounds confusing, that's perfectly fine. We will get some
deeper intuition on recursive types and <em>why</em> we need them in
Section 3.4.1, and we will give them a formal treatment in Section 5.1.
The high-level idea is that recursive types are sometimes necessary to
give principal types to MLsub terms. The example given by Dolan [2017]
is that of the term <span class="math inline">\(Y(λf. λx. f)\)</span>
where <span class="math inline">\(Y\)</span> is the call-by-value <span
class="math inline">\(Y\)</span> combinator. This term represents a
function which ignores its parameter and returns itself. It can be given
type <span class="math inline">\(T → T\)</span> as well as <span
class="math inline">\(T → T → T\)</span>, and <span
class="math inline">\(T → T → T → T\)</span>, etc. Its principal type is
the recursive type shown in the previous paragraph.</p>
<h3 id="typing-surprises.">2.3.3 Typing Surprises.</h3>
<p>It is worth noting that inferring recursive types can lead to typing
terms which <em>appear</em> ill-typed, and would in fact not be
well-typed in ML.<a href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a> This kind of surprises can also
arise simply due to subtyping. For instance, in MLsub, the
strange-looking term <span class="math inline">\(\lambda x. x
x\)</span>, which takes a function in parameter and applies it to
itself, can be typed as <span class="math inline">\(\forall \alpha,
\beta. (\alpha \to \beta) \sqcap \alpha \to \beta\)</span>. Indeed, if
the input <span class="math inline">\(x\)</span> passed to the function
has type <span class="math inline">\((\alpha \to \beta) \sqcap
\alpha\)</span>, that means it has type <span
class="math inline">\(\alpha \to \beta\)</span> (a function taking an
<span class="math inline">\(\alpha\)</span> argument) and type <span
class="math inline">\(\alpha\)</span>, meaning that it can be passed as
an argument to itself.</p>
<p>如果这听起来让人困惑，那是完全可以理解的。我们将在第3.4.1节中深入理解递归类型以及<em>我们为什么需要它们</em>，并将在第5.1节中对它们进行正式处理。总体思路是，递归类型有时是必要的，以便为MLsub术语提供主类型。Dolan
[2017]给出的例子是术语<span class="math inline">\(Y(λf. λx.
f)\)</span>，其中<span class="math inline">\(Y\)</span>是按值调用的<span
class="math inline">\(Y\)</span>组合子。这个术语表示一个忽略其参数并返回自身的函数。它可以被赋予类型<span
class="math inline">\(T → T\)</span>以及<span class="math inline">\(T →
T → T\)</span>，还有<span class="math inline">\(T → T → T →
T\)</span>，等等。它的主类型是前一段中所示的递归类型。</p>
<h3 id="类型意外">2.3.3 类型意外</h3>
<p>值得注意的是，推断递归类型可能导致出现<em>看起来</em>类型不正确的术语，实际上在ML中并不会是良好类型的。<a
href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a>
这类意外也可能简单地源于子类型。例如，在 MLsub 中，奇怪的术语 <span
class="math inline">\(\lambda x. x
x\)</span>，它以一个函数作为参数并将其应用于自身，可以被类型化为 <span
class="math inline">\(\forall \alpha, \beta. (\alpha \to \beta) \sqcap
\alpha \to \beta\)</span>。事实上，如果传递给函数的输入 <span
class="math inline">\(x\)</span> 的类型是 <span
class="math inline">\((\alpha \to \beta) \sqcap
\alpha\)</span>，这意味着它具有类型 <span class="math inline">\(\alpha
\to \beta\)</span>（一个接受 <span class="math inline">\(\alpha\)</span>
参数的函数）和类型 <span
class="math inline">\(\alpha\)</span>，意味着它可以作为自身的参数传递。</p>
<h2 id="expressiveness">2.4 Expressiveness</h2>
<h2 id="表达能力">2.4 表达能力</h2>
<p>There is an important caveat to add to the definition of types we
gave above: these types cannot actually be used freely within type
expressions. The true syntax of MLsub is segregated between
<em>positive</em> and <em>negative</em> types. In particular, unions are
positive types (and may not appear in negative position) and
intersections are negative types (and may not appear in positive
position).</p>
<h3 id="polarity-of-type-positions.">2.4.1 Polarity of Type
Positions.</h3>
<p>Positive positions correspond to the types that a term
<em>outputs</em>, while negative positions correspond to the types that
a term <em>takes in</em> as input. For instance, in <span
class="math inline">\((\tau_0 \to \tau_1) \to \tau_2\)</span>, type
<span class="math inline">\(\tau_2\)</span> is in positive position
since it is the output of the main function, and the function type <span
class="math inline">\((\tau_0 \to \tau_1)\)</span> is in negative
position, as it is taken as an input to the main function. On the other
hand, <span class="math inline">\(\tau_1\)</span>, which is returned
<em>by the function taken as input</em> is in negative position (since
it is provided by callers via the argument function), and <span
class="math inline">\(\tau_0\)</span> is in positive position (since it
is provided by the main function when calling the argument
function).</p>
<p>需要在上述类型定义中添加一个重要的警告：这些类型实际上不能在类型表达式中被自由使用。MLsub
的真实语法在 <em>正</em> 类型和 <em>负</em>
类型之间是分隔的。特别地，联合是正类型（不能出现在负位置），而交集是负类型（不能出现在正位置）。</p>
<h3 id="类型位置的极性">2.4.1 类型位置的极性。</h3>
<p>正位置对应于一个术语 <em>输出</em> 的类型，而负位置对应于一个术语
<em>作为输入接收</em> 的类型。例如，在 <span
class="math inline">\((\tau_0 \to \tau_1) \to \tau_2\)</span> 中，类型
<span class="math inline">\(\tau_2\)</span>
位于正位置，因为它是主函数的输出，而函数类型 <span
class="math inline">\((\tau_0 \to \tau_1)\)</span>
位于负位置，因为它作为主函数的输入。另一方面，<span
class="math inline">\(\tau_1\)</span> 是由 <em>作为输入的函数返回</em>
的，所以它位于负位置（因为它是通过调用者提供的参数函数提供的），而 <span
class="math inline">\(\tau_0\)</span>
位于正位置（因为它是由主函数在调用参数函数时提供的）。</p>
<h3 id="consequence-of-the-polarity-restriction.">2.4.2 Consequence of
the Polarity Restriction.</h3>
<p>These <em>polarity</em> restrictions mean that the full syntax of
types we saw above cannot actually be used as is; programmers cannot
write, in their own type annotations, types that violate the polarity
distinction. In fact, in MLsub, one <em>cannot</em> express the type of
a function which takes “either an integer or a string”: type
<code>int</code> <span class="math inline">\(\sqcup\)</span>
<code>string</code> <span class="math inline">\(\to\)</span> <span
class="math inline">\(\tau\)</span> is illegal because it has the
<code>int</code> <span class="math inline">\(\sqcup\)</span>
<code>string</code> union in negative position. On the other hand, MLsub
may assign the legal type <span class="math inline">\(\tau \to\)</span>
<code>int</code> <span class="math inline">\(\sqcup\)</span>
<code>string</code> to functions which may return either an integer or a
string... but this is not a very useful type, since one cannot do
anything useful with an <code>int</code> <span
class="math inline">\(\sqcup\)</span> <code>string</code> value in
MLsub.<a href="#fn11" class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a></p>
<p>What this all comes down to, perhaps surprisingly, is that the MLsub
language is fundamentally no more expressive<a href="#fn12"
class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>
than a “structurally-typed Java”, by which we mean a hypothetical Java
dialect with structural records and lower as well as upper bounds for
type variables. To understand this, consider the following function:</p>
<p><span class="math display">\[ \lambda x. \{ L = x - 1; R = \text{if }
x &lt; 0 \text{ then } 0 \text{ else } x \} \]</span></p>
<h3 id="极性限制的后果">2.4.2 极性限制的后果。</h3>
<p>这些 <em>极性</em>
限制意味着我们上面看到的类型的完整语法实际上无法按原样使用；程序员不能在自己的类型注释中编写违反极性区分的类型。事实上，在
MLsub 中，人们 <em>无法</em>
表达一个接受“整数或字符串”的函数的类型：类型 <code>int</code> <span
class="math inline">\(\sqcup\)</span> <code>string</code> <span
class="math inline">\(\to\)</span> <span
class="math inline">\(\tau\)</span> 是非法的，因为它在负位置上有
<code>int</code> <span class="math inline">\(\sqcup\)</span>
<code>string</code> 的并集。另一方面，MLsub 可以将合法类型 <span
class="math inline">\(\tau \to\)</span> <code>int</code> <span
class="math inline">\(\sqcup\)</span> <code>string</code>
分配给可能返回整数或字符串的函数……但这并不是一个非常有用的类型，因为在
MLsub 中，人们无法对 <code>int</code> <span
class="math inline">\(\sqcup\)</span> <code>string</code>
值进行任何有用的操作。<a href="#fn13" class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a></p>
<p>这一切归结起来，也许令人惊讶的是，MLsub
语言在表达能力上根本不比“结构类型的 Java”更强<a href="#fn14"
class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a>，我们指的是一种假设的 Java
方言，具有结构记录以及类型变量的下限和上限。要理解这一点，请考虑以下函数：</p>
<p><span class="math display">\[ \lambda x. \{ L = x - 1; R = \text{if }
x &lt; 0 \text{ then } 0 \text{ else } x \} \]</span></p>
<p>which could be given the following <em>unsimplified</em> type by
MLsub or Simple-sub:</p>
<p><span class="math display">\[ \alpha \sqcap \text{int} \to \{ L :
\text{int}; R : \beta \sqcup \text{nat} \sqcup \alpha \} \]</span></p>
<p>or equivalently, after simplification:</p>
<p><span class="math display">\[ \alpha \sqcap \text{int} \to \{ L :
\text{int}; R : \text{nat} \sqcup \alpha \} \]</span></p>
<p>The <span class="math inline">\(\beta\)</span> type variable is
introduced to represent the result type of the <em>if</em> expression.
During type inference, both constraints <span
class="math inline">\(\text{nat} \le \beta\)</span> and <span
class="math inline">\(\alpha \le \beta\)</span> are registered, which is
handled by replacing all occurrences of <span
class="math inline">\(\beta\)</span> in positive positions (there is
only one here) by <span class="math inline">\(\beta \sqcup \text{nat}
\sqcup \alpha\)</span>. In this simple example, the <span
class="math inline">\(\beta\)</span> type variable turns out to be
redundant, and is later removed during simplification.</p>
<p>Now, recall that Java allows users to quantify types using type
variables, and also allows bounding these type variables with subtypes
and supertypes.<a href="#fn15" class="footnote-ref" id="fnref15"
role="doc-noteref"><sup>15</sup></a> The insight is that unions and
intersections,</p>
<p>可以通过 MLsub 或 Simple-sub 给出以下 <em>未简化</em> 类型：</p>
<p><span class="math display">\[ \alpha \sqcap \text{int} \to \{ L :
\text{int}; R : \beta \sqcup \text{nat} \sqcup \alpha \} \]</span></p>
<p>或者等价地，在简化后：</p>
<p><span class="math display">\[ \alpha \sqcap \text{int} \to \{ L :
\text{int}; R : \text{nat} \sqcup \alpha \} \]</span></p>
<p><span class="math inline">\(\beta\)</span> 类型变量被引入以表示
<em>if</em> 表达式的结果类型。在类型推断期间，两个约束 <span
class="math inline">\(\text{nat} \le \beta\)</span> 和 <span
class="math inline">\(\alpha \le \beta\)</span>
被记录，这通过将所有正位置上（这里只有一个）的 <span
class="math inline">\(\beta\)</span> 替换为 <span
class="math inline">\(\beta \sqcup \text{nat} \sqcup \alpha\)</span>
来处理。在这个简单的例子中，<span class="math inline">\(\beta\)</span>
类型变量被证明是多余的，并在简化过程中被移除。</p>
<p>现在，回想一下 Java
允许用户使用类型变量来量化类型，同时也允许用子类型和超类型来限制这些类型变量。<a
href="#fn16" class="footnote-ref" id="fnref16"
role="doc-noteref"><sup>16</sup></a> 这个见解是，联合和交叉，</p>
<p>when used at the appropriate polarity, are only a way of indirectly
bounding type variables. For instance, the unsimplified MLsub type seen
above is equivalent to the following Java-esque type, where type
parameters are written between <code>⟨</code> and <code>⟩</code>:</p>
<p><span class="math display">\[ \langle \alpha \ extends \ int, \ \beta
\ super \ nat \mid \alpha \rangle(\alpha) \to \{ L : int; R : \beta \}
\]</span></p>
<p>meaning that <span class="math inline">\(\alpha\)</span> should be a
<em>subtype</em> of int and that <span
class="math inline">\(\beta\)</span> should be a <em>supertype</em> of
both nat and <span class="math inline">\(\alpha\)</span>. Moreover, the
simplified type is equivalent to:</p>
<p><span class="math display">\[ \langle \alpha \ super \ nat \ extends
\ int \rangle(\alpha) \to \{ L : int; R : \alpha \} \]</span></p>
<p>当在适当的极性下使用时，仅仅是在间接限制类型变量的一种方式。例如，上面未简化的MLsub类型等同于以下Java风格的类型，其中类型参数写在<code>⟨</code>和<code>⟩</code>之间：</p>
<p><span class="math display">\[ \langle \alpha \ extends \ int, \ \beta
\ super \ nat \mid \alpha \rangle(\alpha) \to \{ L : int; R : \beta \}
\]</span></p>
<p>这意味着<span
class="math inline">\(\alpha\)</span>应该是int的<em>子类型</em>，而<span
class="math inline">\(\beta\)</span>应该是nat和<span
class="math inline">\(\alpha\)</span>的<em>超类型</em>。此外，简化后的类型等同于：</p>
<p><span class="math display">\[ \langle \alpha \ super \ nat \ extends
\ int \rangle(\alpha) \to \{ L : int; R : \alpha \} \]</span></p>
<p>meaning that <span class="math inline">\(\alpha\)</span> should be a
supertype of nat and also a subtype of int.</p>
<p>As for MLsub's recursive types, they are expressible via F-bounded
polymorphism, which Java also supports. F-bounded polymorphism allows a
type variable <span class="math inline">\(\alpha\)</span> to be bounded
by a type expression that contains occurrences of <span
class="math inline">\(\alpha\)</span> itself.</p>
<p>The fact that type intersections can be used to encode upper bounds
on type variables was originally remarked by Castagna and Xu [2011,
footnote 4]. Naturally, the same goes for type unions and lower bounds
respectively. What we proposed above is, in a sense, the <em>reverse
direction</em> of this translation: stating that <em>polar</em> usages
of unions and intersections can be encoded as lower and upper bounds on
type variables.</p>
<h2 id="essence-of-mlsub-type-inference">2.5 Essence of MLsub Type
Inference</h2>
<p>Reading Dolan [2017]; Dolan and Mycroft [2017], one could be led to
think that MLsub is all about:</p>
<ul>
<li>supporting unions and intersections in the type language, forming a
distributive lattice;</li>
<li>a new algorithm called biunification as an alternative to
traditional unification;</li>
<li>separating the syntax of types between positive and negative
types.</li>
</ul>
<p>意味着 <span class="math inline">\(\alpha\)</span> 应该是 nat
的超类型，同时也是 int 的子类型。</p>
<p>至于 MLsub 的递归类型，它们可以通过 F-bounded polymorphism
来表达，Java 也支持这一点。F-bounded polymorphism 允许一个类型变量 <span
class="math inline">\(\alpha\)</span> 受到一个包含 <span
class="math inline">\(\alpha\)</span> 本身的类型表达式的限制。</p>
<p>类型交集可用于编码类型变量的上界这一事实最初是由 Castagna 和 Xu
[2011, footnote 4]
提出的。自然，类型并集和下界同样适用。我们上面所提的在某种意义上是这种翻译的<em>反向方向</em>：即表明<em>极性</em>使用的并集和交集可以作为类型变量的下界和上界进行编码。</p>
<h2 id="mlsub-类型推断的本质">2.5 MLsub 类型推断的本质</h2>
<p>阅读 Dolan [2017]; Dolan 和 Mycroft [2017]，人们可能会认为 MLsub
全部是关于：</p>
<ul>
<li>在类型语言中支持并集和交集，形成一个分布格；</li>
<li>一种名为 biunification 的新算法，作为传统统一的替代方案；</li>
<li>将类型的语法分为正类型和负类型。</li>
</ul>
<p>However, we argue that this is not the most helpful way of
understanding the processes at work in this type inference algorithm;
instead, we argue that the essence of the approach is:</p>
<ul>
<li>making the semantics of types simple enough that all inferred
subtyping constraints can be reduced to constraints on type variables,
which can be recorded efficiently (for instance using mutation, as done
in this paper and in MLsub's actual implementation);</li>
<li>using intersection, union, and recursive types to express compact
type signatures where type variables are indirectly constrained,
avoiding the need for separate constraint specifications.</li>
</ul>
<h1 id="the-simple-sub-type-inference-algorithm">3 THE SIMPLE-SUB TYPE
INFERENCE ALGORITHM</h1>
<p>然而，我们认为这并不是理解这种类型推导算法中运行过程的最有帮助的方法；相反，我们认为该方法的本质是：</p>
<ul>
<li>使类型的语义足够简单，以便所有推导出的子类型约束都可以简化为对类型变量的约束，这些约束可以高效记录（例如使用变异，如本文和MLsub的实际实现所做的那样）；</li>
<li>使用交集、并集和递归类型来表达紧凑的类型签名，其中类型变量受到间接约束，避免了单独约束规范的需要。</li>
</ul>
<h1 id="simple-sub-类型推导算法">3 SIMPLE-SUB 类型推导算法</h1>
<p>We now present Simple-sub. We start with the internal Scala syntax
used in the algorithms (Section 3.1); we then describe the basic
mechanisms of type inference, at first omitting let bindings for
simplicity (Section 3.2); we show how to produce user-facing type
representations from the results of type inference (Section 3.3); we
discuss some insights on recursive types and unroll an example of type
inference (Section 3.4); and we explain how to support let polymorphism
and recursive let bindings (Section 3.5). Finally, we summarize the full
Simple-sub algorithm (Section 3.6).</p>
<h2 id="simple-sub-syntax">3.1 Simple-sub Syntax</h2>
<p>3.1.1 <em>Term Syntax.</em> The Scala implementation of the term
syntax is shown in Figure 4. We derive it directly from Figure 1, except
that we add a construct for integer literals.</p>
<p>As mentioned before, there is no need for an if-then-else feature,
since we can just add one as a combinator: our parser actually parses
code of the form "if <span class="math inline">\(e_0\)</span> then <span
class="math inline">\(e_1\)</span> else <span
class="math inline">\(e_2\)</span>" as if it were written</p>
<p>我们现在介绍 Simple-sub。我们首先介绍算法中使用的内部 Scala 语法（第
3.1 节）；然后描述类型推断的基本机制，最初省略 let 绑定以简化问题（第
3.2 节）；接着展示如何从类型推断的结果生成用户可见的类型表示（第 3.3
节）；我们讨论一些关于递归类型的见解，并演示一个类型推断的例子（第 3.4
节）；最后，我们解释如何支持 let 多态性和递归 let 绑定（第 3.5
节）。最后，我们总结完整的 Simple-sub 算法（第 3.6 节）。</p>
<h2 id="simple-sub-语法">3.1 Simple-sub 语法</h2>
<p>3.1.1 <em>项语法。</em> Scala 对项语法的实现如图 4 所示。我们直接从图
1 中推导出来，除了我们添加了一个整数字面量的构造。</p>
<p>如前所述，实际上不需要 if-then-else
特性，因为我们可以将其作为一个组合子添加：我们的解析器实际上将形式为 "if
<span class="math inline">\(e_0\)</span> then <span
class="math inline">\(e_1\)</span> else <span
class="math inline">\(e_2\)</span>" 的代码解析为它被写成的样子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Term</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lit</span> (value: <span class="type">Int</span>)                 <span class="comment">// as in: 27</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Var</span> (name: <span class="type">String</span>)              <span class="comment">// as in: x</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lam</span> (name: <span class="type">String</span>, rhs: <span class="type">Term</span>)  <span class="comment">// as in: λx. t</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">App</span> (lhs: <span class="type">Term</span>, rhs: <span class="type">Term</span>)     <span class="comment">// as in: s t</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Rcd</span> (fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Term</span>)]) <span class="comment">// as in: &#123;a: 0; b: true; ...&#125;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sel</span> (receiver: <span class="type">Term</span>, fieldName: <span class="type">String</span>) <span class="comment">// as in: t.a</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Let</span> (isRec: <span class="type">Boolean</span>, name: <span class="type">String</span>, rhs: <span class="type">Term</span>, body: <span class="type">Term</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>Fig. 4. Scala syntax for MLsub terms (using the <code>enum</code>¹⁰
keyword for defining algebraic data types).</p>
<p>“<span class="math inline">\(\text{if } e_0 e_1 e_2\)</span>,” and we
perform type checking starting from a context which assigns to the ‘if’
identifier the type <span class="math inline">\(\forall \alpha\)</span>.
<span class="math inline">\(bool \to \alpha \to \alpha \to
\alpha\)</span>.<a href="#fn17" class="footnote-ref" id="fnref17"
role="doc-noteref"><sup>17</sup></a></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">SimpleType</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Variable</span> (st: <span class="type">VariableState</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Primitive</span> (name: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Function</span> (lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Record</span> (fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">SimpleType</span>)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Term</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lit</span> (value: <span class="type">Int</span>)                 <span class="comment">// 例如: 27</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Var</span> (name: <span class="type">String</span>)              <span class="comment">// 例如: x</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lam</span> (name: <span class="type">String</span>, rhs: <span class="type">Term</span>)  <span class="comment">// 例如: λx. t</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">App</span> (lhs: <span class="type">Term</span>, rhs: <span class="type">Term</span>)     <span class="comment">// 例如: s t</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Rcd</span> (fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Term</span>)]) <span class="comment">// 例如: &#123;a: 0; b: true; ...&#125;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sel</span> (receiver: <span class="type">Term</span>, fieldName: <span class="type">String</span>) <span class="comment">// 例如: t.a</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Let</span> (isRec: <span class="type">Boolean</span>, name: <span class="type">String</span>, rhs: <span class="type">Term</span>, body: <span class="type">Term</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>图 4. Scala 语法用于 MLsub 术语（使用 <code>enum</code>¹⁰
关键字定义代数数据类型）。</p>
<p>“<span class="math inline">\(\text{if } e_0 e_1
e_2\)</span>，”并且我们从一个上下文开始进行类型检查，该上下文将 'if'
标识符分配类型为 <span class="math inline">\(\forall \alpha\)</span>.
<span class="math inline">\(bool \to \alpha \to \alpha \to
\alpha\)</span>.<a href="#fn18" class="footnote-ref" id="fnref18"
role="doc-noteref"><sup>18</sup></a></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">SimpleType</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Variable</span> (st: <span class="type">VariableState</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Primitive</span> (name: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Function</span> (lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Record</span> (fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">SimpleType</span>)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-syntax.">3.1.2 Type Syntax.</h3>
<p>We start from the realization that union, intersection, top, bottom,
and recursive types are all not really core to the type inference
approach. Therefore, we focus on type variables, basic type constructors
(primitive types), function types, and record types as the cornerstone
of the algorithm. Their Scala syntax is shown above.</p>
<p>The state of a type variable is simply given by all the bounds that
are recorded for it:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableState</span>(<span class="params">var lowerBounds: <span class="type">List</span>&lt;<span class="type">SimpleType</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    var upperBounds: <span class="type">List</span>&lt;<span class="type">SimpleType</span>&gt;</span>)</span></span><br></pre></td></tr></table></figure>
<p>Notice that we use mutable variables (<code>var</code> instead of
<code>val</code>) in order to hold the current state of the algorithm —
these lists will be mutated as the algorithm proceeds.</p>
<p>All we need to do in order to perform type inference now is to find
all subtyping constraints entailed by a given program, and to propagate
these constraints until they reach type variables, which we can
constrain by mutating their recorded bounds.</p>
<h2 id="basic-type-inference">3.2 Basic Type Inference</h2>
<h3 id="类型语法">3.1.2 类型语法。</h3>
<p>我们从意识到联合、交集、上界、下界和递归类型实际上并不是类型推断方法的核心开始。因此，我们将焦点放在类型变量、基本类型构造（原始类型）、函数类型和记录类型上，作为算法的基石。它们的
Scala 语法如上所示。</p>
<p>类型变量的状态仅由为其记录的所有约束给出：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableState</span>(<span class="params">var lowerBounds: <span class="type">List</span>&lt;<span class="type">SimpleType</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    var upperBounds: <span class="type">List</span>&lt;<span class="type">SimpleType</span>&gt;</span>)</span></span><br></pre></td></tr></table></figure>
<p>请注意，我们使用可变变量（<code>var</code> 而非
<code>val</code>）来保持算法的当前状态——这些列表将在算法进行过程中被修改。</p>
<p>为了执行类型推断，我们现在需要做的就是找到给定程序所涉及的所有子类型约束，并传播这些约束，直到它们达到类型变量，然后我们可以通过修改其记录的约束来限制它们。</p>
<h2 id="基本类型推断">3.2 基本类型推断</h2>
<h3 id="typing.">3.2.1 Typing.</h3>
<p>The core function for type inference is <code>typeTerm</code>, which
assigns a type to a given term in some context of type <code>Ctx</code>;
it is complemented by a <code>constrain</code> function to imperatively
constrain one type to be a subtype of another, raising an error if that
is not possible:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Ctx</span> </span>= <span class="type">Map</span> <span class="type">String</span>, <span class="type">SimpleType</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(term: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>): <span class="type">SimpleType</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span></span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>): <span class="type">Unit</span> = ...</span><br></pre></td></tr></table></figure>
<p>Above, we made the <code>ctx</code> parameter in
<code>typeTerm</code> implicit so it does not have to be passed
explicitly into each recursive call if it does not change.</p>
<p>We make use of two small helper functions, <code>freshVar</code> and
<code>err</code>, to generate new type variables and raise errors,
respectively:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freshVar</span></span>: <span class="type">Variable</span> =</span><br><span class="line">    <span class="type">Variable</span>(<span class="keyword">new</span> <span class="type">VariableState</span>(<span class="type">Nil</span>, <span class="type">Nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">err</span></span>(msg: <span class="type">String</span>): <span class="type">Nothing</span> =</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;type error: &quot;</span> + msg)</span><br></pre></td></tr></table></figure>
<h3 id="类型推断">3.2.1 类型推断。</h3>
<p>类型推断的核心功能是 <code>typeTerm</code>，它在某个类型为
<code>Ctx</code> 的上下文中为给定的术语分配类型；它由一个
<code>constrain</code>
函数补充，该函数用于强制一个类型是另一个类型的子类型，如果不可能，则抛出错误：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Ctx</span> </span>= <span class="type">Map</span>[<span class="type">String</span>, <span class="type">SimpleType</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(term: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>): <span class="type">SimpleType</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span></span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>): <span class="type">Unit</span> = ...</span><br></pre></td></tr></table></figure>
<p>在上面，我们将 <code>typeTerm</code> 中的 <code>ctx</code>
参数设为隐式的，这样如果它不变，就不必在每个递归调用中显式传入。</p>
<p>我们使用两个小辅助函数 <code>freshVar</code> 和
<code>err</code>，分别用于生成新的类型变量和引发错误：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freshVar</span></span>: <span class="type">Variable</span> =</span><br><span class="line">    <span class="type">Variable</span>(<span class="keyword">new</span> <span class="type">VariableState</span>(<span class="type">Nil</span>, <span class="type">Nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">err</span></span>(msg: <span class="type">String</span>): <span class="type">Nothing</span> =</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;类型错误: &quot;</span> + msg)</span><br></pre></td></tr></table></figure>
<p>Remember that <code>VariableState</code> is a class and not a case
class (also called <em>data class</em>). This means that each
<code>VariableState</code> instance, created with <code>new</code>, is
unique and distinct from other instances.</p>
<p>Now that we have established the necessary premises, we can start
writing the core of the basic type inference algorithm:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(term: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>): <span class="type">SimpleType</span> = term <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="comment">// integer literals:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lit</span>(n) =&gt; <span class="type">Primitive</span>(<span class="string">&quot;int&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Below, the <code>ctx.getOrElse(k, t)</code> function is used to
access the <code>ctx</code> map at a given key <code>k</code>,
specifying a chunk <code>t</code> to execute in case that key is not
found:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// variable references:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Var</span>(name) =&gt; ctx.getOrElse(name, err(<span class="string">&quot;not found: &quot;</span> + name))</span><br><span class="line"></span><br><span class="line"><span class="comment">// record creations:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Rcd</span>(fs) =&gt; <span class="type">Record</span>(fs.map &#123; <span class="keyword">case</span> (n, t) =&gt; (n, typeTerm(t)) &#125;)</span><br></pre></td></tr></table></figure>
<p>In order to type a lambda abstraction, we create a fresh variable to
represent the parameter type, and we type the body of the lambda in the
current context extended with a binding for this parameter, where
<code>name -&gt; param</code> is another syntax for the pair
<code>(name, param)</code>:</p>
<p>请记住，<code>VariableState</code> 是一个类，不是一个案例类（也称为
<em>data class</em>）。这意味着每个通过 <code>new</code> 创建的
<code>VariableState</code> 实例都是唯一的，与其他实例不同。</p>
<p>现在我们已经建立了必要的前提，我们可以开始编写基本类型推断算法的核心部分：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(term: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>): <span class="type">SimpleType</span> = term <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="comment">// 整数文字：</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lit</span>(n) =&gt; <span class="type">Primitive</span>(<span class="string">&quot;int&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下面，<code>ctx.getOrElse(k, t)</code> 函数用于在给定键
<code>k</code> 的 <code>ctx</code>
映射中访问，指定在未找到该键的情况下执行的代码块 <code>t</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量引用：</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Var</span>(name) =&gt; ctx.getOrElse(name, err(<span class="string">&quot;not found: &quot;</span> + name))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录创建：</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Rcd</span>(fs) =&gt; <span class="type">Record</span>(fs.map &#123; <span class="keyword">case</span> (n, t) =&gt; (n, typeTerm(t)) &#125;)</span><br></pre></td></tr></table></figure>
<p>为了为一个 lambda
抽象指定类型，我们创建一个新的变量来表示参数类型，并在当前上下文中使用该参数的绑定类型化
lambda 的主体，其中 <code>name -&gt; param</code> 是对配对
<code>(name, param)</code> 的另一种语法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda abstractions:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Lam</span>(name, body) =&gt;</span><br><span class="line">  <span class="keyword">val</span> param = freshVar</span><br><span class="line">  <span class="type">Function</span>(param, typeTerm(body)(ctx + (name -&gt; param)))</span><br></pre></td></tr></table></figure>
<p>To type applications, we similarly introduce a fresh variable
standing for the result type of the function that we are applying:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applications:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">App</span>(f, a) =&gt;</span><br><span class="line">  <span class="keyword">val</span> res = freshVar</span><br><span class="line">  constrain(typeTerm(f), <span class="type">Function</span>(typeTerm(a), res))</span><br><span class="line">  res</span><br></pre></td></tr></table></figure>
<p>Finally, record accesses result in a constraint that the receiver on
the left-hand side of the selection is a record type with the
appropriate field name:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// record field selections:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Sel</span>(obj, name) =&gt;</span><br><span class="line">  <span class="keyword">val</span> res = freshVar</span><br><span class="line">  constrain(typeTerm(obj), <span class="type">Record</span>((name -&gt; res) :: <span class="type">Nil</span>))</span><br><span class="line">  res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As one can observe, the basic MLsub type inference algorithm so far
is quite similar to the traditional algorithm W for HM-style type
inference.</p>
<h3 id="constraining">3.2.2 Constraining</h3>
<p>The first thing to diverge from algorithm W is the handling of
constraints.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// λ 抽象:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Lam</span>(name, body) =&gt;</span><br><span class="line">  <span class="keyword">val</span> param = freshVar</span><br><span class="line">  <span class="type">Function</span>(param, typeTerm(body)(ctx + (name -&gt; param)))</span><br></pre></td></tr></table></figure>
<p>对于类型应用，我们同样引入一个新变量，表示我们正在应用的函数的结果类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">App</span>(f, a) =&gt;</span><br><span class="line">  <span class="keyword">val</span> res = freshVar</span><br><span class="line">  constrain(typeTerm(f), <span class="type">Function</span>(typeTerm(a), res))</span><br><span class="line">  res</span><br></pre></td></tr></table></figure>
<p>最后，记录访问导致了一个约束，要求选择左侧的接收是具有适当字段名称的记录类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录字段选择:</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Sel</span>(obj, name) =&gt;</span><br><span class="line">  <span class="keyword">val</span> res = freshVar</span><br><span class="line">  constrain(typeTerm(obj), <span class="type">Record</span>((name -&gt; res) :: <span class="type">Nil</span>))</span><br><span class="line">  res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如可以观察到的，基本的 MLsub 类型推断算法到目前为止与传统的算法 W 在
HM 风格的类型推断中非常相似。</p>
<h3 id="约束">3.2.2 约束</h3>
<p>第一个与算法 W 不同的地方是约束的处理。</p>
<p>First, note that type variable bounds, which are updated using
mutation, may very well begin to form cycles as type inference
progresses. We have to account for this by using a cache parameter
(initially empty) which remembers all the type comparisons that have
been or are being made. This not only prevents us from falling into
infinite recursion, but also avoids repeating identical work (i.e.,
solving some of the sub-constraints more than once), which is important
to avoid making the algorithm exponential in complexity [Pierce 2002,
Chapter 21.10].</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span></span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">    (<span class="keyword">implicit</span> cache: <span class="type">MutSet</span>[(<span class="type">SimpleType</span>, <span class="type">SimpleType</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.contains(lhs -&gt; rhs)) <span class="keyword">return</span> () <span class="keyword">else</span> cache += rhs -&gt; rhs</span><br></pre></td></tr></table></figure>
<p>The next step is to match each possible pair of basic types which can
be constrained successfully, and propagate the constraints
accordingly:</p>
<p>首先，请注意，随着类型推断的进行，使用变异更新的类型变量边界很可能开始形成循环。我们必须通过使用一个缓存参数（初始为空）来考虑这一点，该参数记住所有已进行或正在进行的类型比较。这不仅可以防止我们陷入无限递归，还可以避免重复相同的工作（即，对某些子约束的求解进行多次），这对于避免使算法的复杂性变为指数级是很重要的
[Pierce 2002, Chapter 21.10]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">constrain</span>(<span class="params">lhs: SimpleType, rhs: SimpleType</span>)</span><br><span class="line">    (implicit cache: MutSet[(SimpleType, SimpleType)]): Unit = &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.contains(lhs -&gt; rhs)) <span class="keyword">return</span> () <span class="keyword">else</span> cache += rhs -&gt; rhs</span><br></pre></td></tr></table></figure>
<p>下一步是匹配每对可以成功约束的基本类型，并相应地传播约束：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lhs, rhs) <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="type">Primitive</span>(n0), <span class="type">Primitive</span>(n1)) <span class="keyword">if</span> n0 == n1 =&gt;</span><br><span class="line">    () <span class="comment">// nothing to do</span></span><br><span class="line">  <span class="keyword">case</span> (<span class="type">Function</span>(l0, r0), <span class="type">Function</span>(l1, r1)) =&gt;</span><br><span class="line">    constrain(l1, l0); constrain(r0, r1)</span><br><span class="line">  <span class="keyword">case</span> (<span class="type">Record</span>(fs0), <span class="type">Record</span>(fs1)) =&gt;</span><br><span class="line">    fs1 foreach &#123; <span class="keyword">case</span> (n1, t1) =&gt;</span><br><span class="line">      fs0.find(_._1 == n1) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; err(<span class="string">&quot;missing field: &quot;</span> + n1 + <span class="string">&quot; in &quot;</span> + lhs)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>((_, t0)) =&gt; constrain(t0, t1) &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function types are constrained according to the usual rules of
contra- and co-variance of parameter and result types (respectively),
and record types according to the usual width and depth subtyping.</p>
<p>The case for type variables appearing on the left- or right-hand side
is interesting, as this is when we finally mutate the bounds of
variables. Crucially, after adding the corresponding upper or lower
bound to the variable state, we need to iterate<a href="#fn19"
class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>
over the existing opposite bounds of the variable being constrained, in
order to make sure that they become consistent with the new bound:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (<span class="type">Variable</span>(lhs), rhs) =&gt;</span><br><span class="line">  lhs.upperBounds = rhs :: lhs.upperBounds</span><br><span class="line">  lhs.lowerBounds foreach(constrain_, rhs))</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (lhs, <span class="type">Variable</span>(rhs)) =&gt;</span><br><span class="line">  rhs.lowerBounds = lhs :: rhs.lowerBounds</span><br><span class="line">  rhs.upperBounds foreach(constrain(lhs, _))</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lhs, rhs) <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="type">Primitive</span>(n0), <span class="type">Primitive</span>(n1)) <span class="keyword">if</span> n0 == n1 =&gt;</span><br><span class="line">    () <span class="comment">// nothing to do</span></span><br><span class="line">  <span class="keyword">case</span> (<span class="type">Function</span>(l0, r0), <span class="type">Function</span>(l1, r1)) =&gt;</span><br><span class="line">    constrain(l1, l0); constrain(r0, r1)</span><br><span class="line">  <span class="keyword">case</span> (<span class="type">Record</span>(fs0), <span class="type">Record</span>(fs1)) =&gt;</span><br><span class="line">    fs1 foreach &#123; <span class="keyword">case</span> (n1, t1) =&gt;</span><br><span class="line">      fs0.find(_._1 == n1) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; err(<span class="string">&quot;missing field: &quot;</span> + n1 + <span class="string">&quot; in &quot;</span> + lhs)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>((_, t0)) =&gt; constrain(t0, t1) &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function
类型根据参数和结果类型（分别）的协变和反变的常规规则进行约束，而记录类型则根据常规的宽度和深度子类型进行约束。</p>
<p>在左侧或右侧出现的类型变量的情况是有趣的，因为这时我们最终改变变量的边界。至关重要的是，在将相应的上界或下界添加到变量状态后，我们需要遍历<a
href="#fn20" class="footnote-ref" id="fnref20"
role="doc-noteref"><sup>20</sup></a>已存在的与约束变量相对的边界，以确保它们与新的边界保持一致：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (<span class="type">Variable</span>(lhs), rhs) =&gt;</span><br><span class="line">  lhs.upperBounds = rhs :: lhs.upperBounds</span><br><span class="line">  lhs.lowerBounds foreach(constrain_, rhs))</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (lhs, <span class="type">Variable</span>(rhs)) =&gt;</span><br><span class="line">  rhs.lowerBounds = lhs :: rhs.lowerBounds</span><br><span class="line">  rhs.upperBounds foreach(constrain(lhs, _))</span><br></pre></td></tr></table></figure>
<p>Note that there is something deeply non-trivial happening here: we
install the new upper bound <code>rhs</code> before recursing into the
<code>lhs.lowerBounds</code>. This turns out to be essential — without
it, recursive constraining calls which would get back to
<code>lhs</code> would miss this new upper bound, failing to constrain
it. Another subtlety is that <em>new bounds</em> may very well appear in
<code>lhs.upperBounds</code> and <code>lhs.lowerBounds</code> while we
are recursing. This subtlety is briefly discussed further in Section
5.3.1.</p>
<p>Finally, if all other options have failed, we report an error that
the two types cannot be constrained:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> _ =&gt; err(<span class="string">&quot;cannot constrain &quot;</span> + lhs + <span class="string">&quot; &lt;: &quot;</span> + rhs)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里发生了一些深刻的非平凡的事情：我们在递归进入
<code>lhs.lowerBounds</code> 之前安装新的上界
<code>rhs</code>。这被证明是至关重要的——如果没有它，递归约束调用将会返回到
<code>lhs</code>
时会错过这个新的上界，从而无法对其进行约束。另一个微妙之处是，在我们递归期间，<em>新的界限</em>很可能会出现在
<code>lhs.upperBounds</code> 和 <code>lhs.lowerBounds</code>
中。这个微妙之处在第 5.3.1 节中有所简要讨论。</p>
<p>最后，如果所有其他选项都失败了，我们报告一个错误，说明这两种类型无法被约束：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> _ =&gt; err(<span class="string">&quot;cannot constrain &quot;</span> + lhs + <span class="string">&quot; &lt;: &quot;</span> + rhs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this subsection, we saw the core of the Simple-sub type inference
algorithm, which distills what we argue is the “simple essence” of
Dolan’s type inference approach. However, we are not quite done yet. We
still need to produce user-readable type representations (next section)
and to support polymorphism and recursion through let bindings (Section
3.5).</p>
<p>3.3 User-Facing Types Representations</p>
<p><em>Where did union, intersection, top, bottom, and recursive types
go?</em></p>
<p>It turns out these are not really core to the type inference
approach, and are more like emergent properties of type pretty-printing
and simplification. They only come up once we try to display friendly
type expressions to users, after type inference has done the gist of its
job.</p>
<p>3.3.1 Constraining <em>Type Variables Indirectly</em>. Remember that
we have been constraining type variables, but that type variable
constraints are not part of the syntax that MLsub and Simple-sub are
supposed to output. The “trick” is to indirectly encode these
constraints through the use of union and intersection types (recall the
examples given in Section 2.3.1).</p>
<p>在这一小节中，我们看到了简易子类型推断算法的核心，这提炼了我们认为是Dolan类型推断方法的“简单本质”。然而，我们尚未完成。我们仍需生成用户可读的类型表示（下一节）并通过let绑定支持多态和递归（第3.5节）。</p>
<p>3.3 面向用户的类型表示</p>
<p><em>并集、交集、顶、底和递归类型去哪儿了？</em></p>
<p>事实证明，这些并不是类型推断方法的核心，更像是类型美观打印和简化的涌现属性。它们在我们尝试向用户展示友好的类型表达式时才会出现，在类型推断完成其核心工作之后。</p>
<p>3.3.1
间接约束<em>类型变量</em>。请记住，我们一直在约束类型变量，但类型变量约束并不是MLsub和Simple-sub应该输出的语法的一部分。“技巧”在于通过使用并集和交集类型间接编码这些约束（回忆第2.3.1节中给出的例子）。</p>
<p>3.3.2 <em>Targeted Type Syntax.</em> In order to produce
user-friendly type representations in the tradition of MLsub, we target
the type syntax tree presented in Figure 5.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Type</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Top</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bot</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Union</span> (lhs: <span class="type">Type</span>, rhs: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Inter</span> (lhs: <span class="type">Type</span>, rhs: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">FunctionType</span> (lhs: <span class="type">Type</span>, rhs: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">RecordType</span>   (fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Type</span>)])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">RecursiveType</span> (name: <span class="type">String</span>, body: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TypeVariable</span>  (name: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">PrimitiveType</span> (name: <span class="type">String</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>Fig. 5. The type syntax targeted as the end result of type
inference.</p>
<p>3.3.3 <em>Type Coalescing Algorithm.</em> In order to produce
immutable <em>Type</em> values from our inferred <em>SimpleType</em>
internal representation, we need to go through a process we refer to as
<em>type coalescing</em>, whose goal is to replace the positive
occurrences of <em>type</em> variables with a union of their lower
bounds, and their negative occurrences with an intersection of their
upper bounds.</p>
<p>3.3.2 <em>目标类型语法.</em>
为了生成符合用户友好的类型表示，遵循MLsub的传统，我们的目标是图5中呈现的类型语法树。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Type</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Top</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bot</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Union</span> (lhs: <span class="type">Type</span>, rhs: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Inter</span> (lhs: <span class="type">Type</span>, rhs: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">FunctionType</span> (lhs: <span class="type">Type</span>, rhs: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">RecordType</span>   (fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Type</span>)])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">RecursiveType</span> (name: <span class="type">String</span>, body: <span class="type">Type</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TypeVariable</span>  (name: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">PrimitiveType</span> (name: <span class="type">String</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>图5. 作为类型推断最终结果的目标类型语法。</p>
<p>3.3.3 <em>类型合并算法.</em>
为了从我们推断的<em>SimpleType</em>内部表示中生成不可变的<em>Type</em>值，我们需要经历一个我们称之为<em>类型合并</em>的过程，其目标是用其下界的并集替换<em>type</em>变量的正出现，用其上界的交集替换负出现。</p>
<p>We define a <em>PolarVariable</em> type synonym which associates a
<em>type variable</em> state with a <em>polarity</em>. The algorithm
starts by initializing an empty mutable map called <em>recursive</em>,
whose goal is to remember which <em>type variables</em> refer to
themselves through their bounds, assigning them a fresh type variable
which will be used when constructing the corresponding
<em>RecursiveType</em> value:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type PolarVariable = (VariableState, Boolean) // &#x27;true&#x27; means &#x27;positive&#x27;</span><br><span class="line"></span><br><span class="line">def coalesceType(ty: SimpleType): Type = &#123;</span><br><span class="line">  val recursive: MutMap[PolarVariable, String] = MutMap.empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The (VariableState, Boolean) keys of the recursive map include the
polarity in the right-hand side to make sure we produce only
<em>polar</em> recursive types (those whose variables occur with the
same polarity as the types themselves); this turns out to be necessary
for principality [Dolan 2017].</p>
<p>Then, we define a worker function go which calls itself recursively
in a straightforward manner, but makes sure to keep track of the type
variables that are currently being coalesced, and to keep track of the
current polarity — whether we are coalescing a positive (polar == true)
or negative (polar == false) type position:</p>
<p>我们定义了一个 <em>PolarVariable</em> 类型同义词，它将
<em>类型变量</em> 状态与 <em>极性</em>
关联起来。算法首先初始化一个空的可变映射
<em>recursive</em>，其目的是记住哪些 <em>类型变量</em>
通过它们的边界引用自身，并为它们分配一个新的类型变量，该变量将在构造相应的
<em>RecursiveType</em> 值时使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type PolarVariable = (VariableState, Boolean) // &#x27;true&#x27; 表示 &#x27;positive&#x27;</span><br><span class="line"></span><br><span class="line">def coalesceType(ty: SimpleType): Type = &#123;</span><br><span class="line">  val recursive: MutMap[PolarVariable, String] = MutMap.empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归映射的 (VariableState, Boolean)
键在右侧包含极性，以确保我们只生成 <em>polar</em>
递归类型（这些类型的变量与类型本身的极性相同）；这被证明对于首要性是必要的
[Dolan 2017]。</p>
<p>然后，我们定义一个工作函数
go，它以直接的方式递归调用自身，但确保跟踪当前正在合并的类型变量，以及跟踪当前极性——我们是合并正类型
(polar == true) 还是负类型 (polar == false) 的位置：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span></span>(ty: <span class="type">SimpleType</span>, polar: <span class="type">Boolean</span>)(inProcess: <span class="type">Set</span>[<span class="type">PolarVariable</span>]): <span class="type">Type</span></span><br><span class="line">    = ty <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Primitive</span>(n) =&gt; <span class="type">PrimitiveType</span>(n)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Function</span>(l, r) =&gt;</span><br><span class="line">        <span class="type">FunctionType</span>(go(l, !polar)(inProcess), go(r, polar)(inProcess))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Record</span>(fs) =&gt;</span><br><span class="line">        <span class="type">RecordType</span>(fs.map(nt =&gt; nt._1 -&gt; go(nt._2, polar)(inProcess)))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>The interesting case is the following.<a href="#fn21"
class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>
In the code below, <code>vs.uniqueName</code>, is an attribute defined
in the <code>VariableState</code> class, which holds a name unique to
<code>vs</code>.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Variable</span>(vs) =&gt;</span><br><span class="line">    <span class="keyword">val</span> vs_pol = vs -&gt; polar</span><br><span class="line">    <span class="keyword">if</span> (inProcessamilates(vs_pol))</span><br><span class="line">        <span class="type">TypeVariable</span>(recursive.get lub <span class="keyword">else</span> <span class="type">Update</span>(vs_pol, freshVar.uniqueName))</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> bounds = <span class="keyword">if</span> (polar) vs.lowerBounds <span class="keyword">else</span> vs.upperBounds</span><br><span class="line">        <span class="keyword">val</span> boundTypes = bounds.map(go_, polar)(inProcess + vs_pol))</span><br><span class="line">        <span class="keyword">val</span> mrg = <span class="keyword">if</span> (polar) <span class="type">Union</span> <span class="keyword">else</span> <span class="type">Inter</span></span><br><span class="line">        <span class="keyword">val</span> res = boundTypes.foldLeft(<span class="type">TypeVariable</span>(vs.uniqueName))(mrg)</span><br><span class="line">        recursive.get (vs_pol).fold (res) (<span class="type">RecursiveType_</span>, res))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span></span>(ty: <span class="type">SimpleType</span>, polar: <span class="type">Boolean</span>)(inProcess: <span class="type">Set</span>[<span class="type">PolarVariable</span>]): <span class="type">Type</span></span><br><span class="line">    = ty <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Primitive</span>(n) =&gt; <span class="type">PrimitiveType</span>(n)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Function</span>(l, r) =&gt;</span><br><span class="line">        <span class="type">FunctionType</span>(go(l, !polar)(inProcess), go(r, polar)(inProcess))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Record</span>(fs) =&gt;</span><br><span class="line">        <span class="type">RecordType</span>(fs.map(nt =&gt; nt._1 -&gt; go(nt._2, polar)(inProcess)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">有趣的情况如下。[^<span class="number">7</span>] 在下面的代码中，`vs.uniqueName` 是在 `<span class="type">VariableState</span>` 类中定义的一个属性，它保存一个对 `vs` 唯一的名称。</span><br><span class="line"></span><br><span class="line">```scala</span><br><span class="line"><span class="keyword">case</span> <span class="type">Variable</span>(vs) =&gt;</span><br><span class="line">    <span class="keyword">val</span> vs_pol = vs -&gt; polar</span><br><span class="line">    <span class="keyword">if</span> (inProcessamilates(vs_pol))</span><br><span class="line">        <span class="type">TypeVariable</span>(recursive.get lub <span class="keyword">else</span> <span class="type">Update</span>(vs_pol, freshVar.uniqueName))</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> bounds = <span class="keyword">if</span> (polar) vs.lowerBounds <span class="keyword">else</span> vs.upperBounds</span><br><span class="line">        <span class="keyword">val</span> boundTypes = bounds.map(go_, polar)(inProcess + vs_pol))</span><br><span class="line">        <span class="keyword">val</span> mrg = <span class="keyword">if</span> (polar) <span class="type">Union</span> <span class="keyword">else</span> <span class="type">Inter</span></span><br><span class="line">        <span class="keyword">val</span> res = boundTypes.foldLeft(<span class="type">TypeVariable</span>(vs.uniqueName))(mrg)</span><br><span class="line">        recursive.get (vs_pol).fold (res) (<span class="type">RecursiveType_</span>, res))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>We first check whether the variable is already being coalesced. If it
is, we look up the 'recursive' map: if this map already contains an
entry for the variable, we simply return it; otherwise, we create a new
fresh <code>TypeVariable</code> and update the map using
<code>getOrElseUpdate</code>.</p>
<p>If we are not coalescing a recursive variable occurrence, we look
into the bounds of the variable. Depending on the current polarity, we
recurse into the lower or upper bounds. Then, if the recursive</p>
<p>map now contains an entry for the variable, it means the variable was
recursive. In this case, we wrap the result in RecursiveType with the
variable found in the map.</p>
<p>We conclude the algorithm by calling go on the top-level type ty with
an empty inProcess:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(ty, <span class="literal">true</span>)(<span class="type">Set</span>.empty)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先检查变量是否已经被合并。如果是，我们查找“recursive”映射：如果该映射已经包含该变量的条目，我们直接返回；否则，我们创建一个新的
<code>TypeVariable</code> 并使用 <code>getOrElseUpdate</code>
更新映射。</p>
<p>如果我们不是在合并一个递归变量的出现，我们将查看变量的界限。根据当前的极性，我们递归进入下限或上限。然后，如果递归</p>
<p>映射现在包含该变量的条目，这意味着该变量是递归的。在这种情况下，我们用在映射中找到的变量包装结果为
<code>RecursiveType</code>。</p>
<p>我们通过在顶级类型 ty 上调用 go 并传入一个空的 inProcess
来结束算法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(ty, <span class="literal">true</span>)(<span class="type">Set</span>.empty)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This algorithm does produce some unnecessary variables (variables
which could be removed to simplify the type expression); we see how to
simplify type representations in Section 4.</p>
<h2 id="examples">3.4 Examples</h2>
<p>Now is a good time to pause and exemplify some crucial aspects of
Simple-sub.</p>
<h3 id="recursive-types.-1">3.4.1 Recursive Types.</h3>
<p>The reason for having recursive types in the user-facing type syntax
has now become quite obvious: we need them in order to “tie the knot”
when we are trying to coalesce type variables which appears in the
coalescence of their own bounds.</p>
<p>For instance, consider the possible inferred representation
<code>Function(Variable(s), Variable(t))</code>, where
<code>s = new VariableState(Nil, Nil)</code> and
<code>t = new VariableState(Nil, Function(Variable(s), Variable(t))) :: Nil</code>.
Notice that there is a cycle in the upper bounds of <code>t</code>;
therefore, the coalescing algorithm turns this <code>SimpleType</code>
representation into the user-facing type
<code>FunctionType(TypeVariable("s"), RecursiveType("t", FunctionType(TypeVariable("s"), TypeVariable("t"))))</code>,
which corresponds to <span class="math inline">\(\alpha \rightarrow
(\mu\beta.\alpha \rightarrow \beta)\)</span> (and which will then be
simplified to <span class="math inline">\(\tau \rightarrow
(\mu\alpha.\tau \rightarrow \alpha)\)</span>).</p>
<p>该算法确实会产生一些不必要的变量（可以通过去除这些变量来简化类型表达）；我们将在第4节中看到如何简化类型表示。</p>
<h2 id="示例">3.4 示例</h2>
<p>现在是暂停并举例说明 Simple-sub 的一些关键方面的好时机。</p>
<h3 id="递归类型-1">3.4.1 递归类型。</h3>
<p>在用户可见的类型语法中引入递归类型的原因现在变得相当明显：我们需要它们来“打结”，当我们尝试将出现在自身边界的类型变量合并时。</p>
<p>例如，考虑可能推断出的表示
<code>Function(Variable(s), Variable(t))</code>，其中
<code>s = new VariableState(Nil, Nil)</code> 和
<code>t = new VariableState(Nil, Function(Variable(s), Variable(t))) :: Nil</code>。注意
<code>t</code> 的上限中存在一个循环；因此，合并算法将此
<code>SimpleType</code> 表示转换为用户可见的类型
<code>FunctionType(TypeVariable("s"), RecursiveType("t", FunctionType(TypeVariable("s"), TypeVariable("t"))))</code>，这对应于
<span class="math inline">\(\alpha \rightarrow (\mu\beta.\alpha
\rightarrow \beta)\)</span>（然后将简化为 <span
class="math inline">\(\tau \rightarrow (\mu\alpha.\tau \rightarrow
\alpha)\)</span>）。</p>
<h3 id="example-of-type-inference.">3.4.2 Example of Type
Inference.</h3>
<p>To facilitate our understanding of the typing and coalescing
algorithms, we now unroll the execution of a type inference run.
Consider the term twice = <span class="math inline">\(\lambda f. \lambda
x. f(f x)\)</span>, which takes a function <em>f</em> and some
<em>x</em> as parameters, and applies <em>f</em> twice on
<em>x</em>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typeTerm(λx. λx. f (f x))(empty)</span><br><span class="line">| typeTerm(λx. f (f x))(Map(f ↦ α))  // α fresh</span><br><span class="line">|   typeTerm(f (f x))(Map(f ↦ α, x ↦ β))  // β fresh</span><br><span class="line">|     typeTerm(f)(Map(f ↦ α, x ↦ β)) = α</span><br><span class="line">|     typeTerm(f x)(Map(f ↦ α, x ↦ β))</span><br><span class="line">|       typeTerm(f)(Map(f ↦ α, x ↦ β)) = α</span><br><span class="line">|       typeTerm(x)(Map(f ↦ α, x ↦ β)) = β</span><br><span class="line">|       constrain(α, Function(β, γ))  // γ fresh</span><br><span class="line">|         α.upperBounds = Function(β, γ) :: α.upperBounds</span><br><span class="line">|       = γ</span><br><span class="line">|     constrain(α, Function(γ, δ))  // δ fresh</span><br><span class="line">|       α.upperBounds = Function(γ, δ) :: α.upperBounds</span><br><span class="line">|     = δ</span><br><span class="line">|   = Function(β, δ)</span><br><span class="line">= Function(α, Function(β, δ))</span><br></pre></td></tr></table></figure>
<h3 id="类型推断的示例">3.4.2 类型推断的示例</h3>
<p>为了帮助我们理解类型和合并算法，我们现在展开一次类型推断的执行过程。考虑项
twice = <span class="math inline">\(\lambda f. \lambda x. f(f
x)\)</span>，它以一个函数 <em>f</em> 和一些 <em>x</em> 作为参数，并在
<em>x</em> 上应用 <em>f</em> 两次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typeTerm(λx. λx. f (f x))(empty)</span><br><span class="line">| typeTerm(λx. f (f x))(Map(f ↦ α))  // α fresh</span><br><span class="line">|   typeTerm(f (f x))(Map(f ↦ α, x ↦ β))  // β fresh</span><br><span class="line">|     typeTerm(f)(Map(f ↦ α, x ↦ β)) = α</span><br><span class="line">|     typeTerm(f x)(Map(f ↦ α, x ↦ β))</span><br><span class="line">|       typeTerm(f)(Map(f ↦ α, x ↦ β)) = α</span><br><span class="line">|       typeTerm(x)(Map(f ↦ α, x ↦ β)) = β</span><br><span class="line">|       constrain(α, Function(β, γ))  // γ fresh</span><br><span class="line">|         α.upperBounds = Function(β, γ) :: α.upperBounds</span><br><span class="line">|       = γ</span><br><span class="line">|     constrain(α, Function(γ, δ))  // δ fresh</span><br><span class="line">|       α.upperBounds = Function(γ, δ) :: α.upperBounds</span><br><span class="line">|     = δ</span><br><span class="line">|   = Function(β, δ)</span><br><span class="line">= Function(α, Function(β, δ))</span><br></pre></td></tr></table></figure>
<p>After this process, we end up with two upper bounds on <span
class="math inline">\(\alpha\)</span>, namely
<code>Function(\beta, \gamma)</code> and
<code>Function(\gamma, \delta)</code>. We next see how the type
coalescing algorithm unrolls from this inferred <code>SimpleType</code>
representation. We omit the details of some of the less interesting
sub-executions, and by a slight abuse of notation we use <span
class="math inline">\(\alpha\)</span> to denote <span
class="math inline">\(\alpha.uniqueName\)</span>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">coalesceType(function(α, function(β, δ)))</span><br><span class="line">  go(function(α, function(β, δ)), <span class="literal">true</span>)(empty)</span><br><span class="line">    go(α, <span class="literal">false</span>)(empty)</span><br><span class="line">    <span class="keyword">val</span> bounds = function(β, γ) :: function(γ, δ) :: <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">val</span> boundTypes</span><br><span class="line">      go(function(β, γ), <span class="literal">false</span>)(<span class="type">Set</span>(α ↦ <span class="literal">false</span>)) = β → γ</span><br><span class="line">      go(function(γ, δ), <span class="literal">false</span>)(<span class="type">Set</span>(α ↦ <span class="literal">false</span>)) = γ → δ</span><br><span class="line">    = β → γ :: γ → δ :: <span class="type">Nil</span></span><br><span class="line">    = α ∩ (β → γ) ∩ (γ → δ)</span><br><span class="line">  go(function(β, δ), <span class="literal">true</span>)(empty)</span><br><span class="line">    go(β, <span class="literal">false</span>)(empty) = β</span><br><span class="line">    go(δ, <span class="literal">true</span>)(empty) = δ</span><br><span class="line">    = β → δ</span><br><span class="line">    = α ∩ (β → γ) ∩ (γ → δ) → β → δ</span><br><span class="line">    = α ∩ (β → γ) ∩ (γ → δ) → β → δ</span><br></pre></td></tr></table></figure>
<p>在这个过程中，我们得到两个对 <span
class="math inline">\(\alpha\)</span> 的上界，即
<code>Function(\beta, \gamma)</code> 和
<code>Function(\gamma, \delta)</code>。接下来，我们将看到类型合并算法如何从这个推断的
<code>SimpleType</code>
表示中展开。我们省略一些不太有趣的子执行的细节，并通过轻微的符号滥用使用
<span class="math inline">\(\alpha\)</span> 来表示 <span
class="math inline">\(\alpha.uniqueName\)</span>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">coalesceType(function(α, function(β, δ)))</span><br><span class="line">  go(function(α, function(β, δ)), <span class="literal">true</span>)(empty)</span><br><span class="line">    go(α, <span class="literal">false</span>)(empty)</span><br><span class="line">    <span class="keyword">val</span> bounds = function(β, γ) :: function(γ, δ) :: <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">val</span> boundTypes</span><br><span class="line">      go(function(β, γ), <span class="literal">false</span>)(<span class="type">Set</span>(α ↦ <span class="literal">false</span>)) = β → γ</span><br><span class="line">      go(function(γ, δ), <span class="literal">false</span>)(<span class="type">Set</span>(α ↦ <span class="literal">false</span>)) = γ → δ</span><br><span class="line">    = β → γ :: γ → δ :: <span class="type">Nil</span></span><br><span class="line">    = α ∩ (β → γ) ∩ (γ → δ)</span><br><span class="line">  go(function(β, δ), <span class="literal">true</span>)(empty)</span><br><span class="line">    go(β, <span class="literal">false</span>)(empty) = β</span><br><span class="line">    go(δ, <span class="literal">true</span>)(empty) = δ</span><br><span class="line">    = β → δ</span><br><span class="line">    = α ∩ (β → γ) ∩ (γ → δ) → β → δ</span><br><span class="line">    = α ∩ (β → γ) ∩ (γ → δ) → β → δ</span><br></pre></td></tr></table></figure>
<p>Finally, we will see in Section 4 that this type can be compacted to
<span class="math inline">\(\alpha \sqcap (\beta \sqcup \gamma
\rightarrow \gamma \sqcap \delta) \rightarrow \beta \rightarrow
\delta\)</span>, and then simplified to <span
class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma)
\rightarrow \beta \rightarrow \gamma\)</span>, since <span
class="math inline">\(\alpha\)</span> occurs only negatively (thus can
be removed) and <span class="math inline">\(\delta\)</span> and <span
class="math inline">\(\gamma\)</span> co-occur negatively (thus can be
merged into a single variable).</p>
<h2 id="let-polymorphism-and-recursion">3.5 Let Polymorphism and
Recursion</h2>
<h3 id="let-polymorphism.">3.5.1 Let Polymorphism.</h3>
<p>In traditional ML languages, local let bindings may be assigned
polymorphic types. This requires keeping track of generalized <em>typing
schemes</em> which are to be <em>instantiated</em> with fresh variables
on every use, and making sure that we are not generalizing those type
variables which occur in the environment, which would be unsound.</p>
<p>One way of determining which type variables to generalize is to scan
the current environment, looking for references to the type variables in
question. However, that is quite inefficient (it adds a linear-time
operation in an important part of the algorithm).</p>
<p>最后，我们将在第4节看到，这种类型可以压缩为 <span
class="math inline">\(\alpha \sqcap (\beta \sqcup \gamma \rightarrow
\gamma \sqcap \delta) \rightarrow \beta \rightarrow
\delta\)</span>，然后简化为 <span class="math inline">\((\beta \sqcup
\gamma \rightarrow \gamma) \rightarrow \beta \rightarrow
\gamma\)</span>，因为 <span class="math inline">\(\alpha\)</span>
仅以负面形式出现（因此可以被移除），而 <span
class="math inline">\(\delta\)</span> 和 <span
class="math inline">\(\gamma\)</span>
在负面形式中共现（因此可以合并为一个变量）。</p>
<h2 id="let多态性和递归">3.5 Let多态性和递归</h2>
<h3 id="let多态性">3.5.1 Let多态性。</h3>
<p>在传统的 ML 语言中，局部 let 绑定可以被赋予多态类型。这需要跟踪广义
<em>类型方案</em>，这些方案将在每次使用时用新变量
<em>实例化</em>，并确保我们不对环境中出现的类型变量进行泛化，这将是不安全的。</p>
<p>确定哪些类型变量需要泛化的一种方法是扫描当前环境，寻找对相关类型变量的引用。然而，这种方法效率相当低下（它在算法的一个重要部分增加了线性时间操作）。</p>
<p><em>Efficient generalization in ML.</em> A better approach is to use
levels. The idea is that all fresh type variables created inside the
right-hand side of a let binding are first assigned a higher level,
which indicates that they should be generalized. However, the level of a
variable is lowered when the variable “escapes” through a constraint
into the enclosing environment, preventing its future generalization
(see the web article by Kiselyov [2013] for an excellent resource on the
subject).</p>
<p><em>Simple-sub typing with levels.</em> We can use the same idea to
achieve let polymorphism in Simple-sub, though we have to be a little
more careful, because we do not merely <em>unify</em> type variables as
in ML, but instead we constrain their bounds. Our idea is to make sure
that lower-level type variables never refer to higher-level ones through
their bounds, and to enforce that property by duplicating type
structures as needed, when it would otherwise be violated by the
addition of a bound.</p>
<p>We first need to add a <code>lvl</code> field to type variable
states:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableState</span>(<span class="params">val level: <span class="type">Int</span>,</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowerBounds: <span class="type">List</span>[<span class="type">SimpleType</span>],</span><br><span class="line"><span class="keyword">var</span> upperBounds: <span class="type">List</span>[<span class="type">SimpleType</span>])</span><br></pre></td></tr></table></figure>
<p><em>在机器学习中的高效泛化。</em>
一种更好的方法是使用层次。这个想法是，在let绑定的右侧创建的所有新类型变量首先被分配一个更高的层次，这表明它们应该被泛化。然而，当变量通过约束“逃逸”到封闭环境中时，变量的层次会降低，从而防止其未来的泛化（参见Kiselyov
[2013] 的网络文章，这是一个关于该主题的优秀资源）。</p>
<p><em>带层次的简单子类型。</em>
我们可以使用相同的想法在Simple-sub中实现let多态，尽管我们必须更加小心，因为我们并不仅仅像在ML中那样“统一”类型变量，而是约束它们的边界。我们的想法是确保低层次的类型变量通过它们的边界
never
引用高层次的类型变量，并在需要时通过复制类型结构来强制执行该属性，以防止由于添加约束而违反该属性。</p>
<p>我们首先需要向类型变量状态添加一个<code>lvl</code>字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableState</span>(<span class="params">val level: <span class="type">Int</span>,</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowerBounds: <span class="type">List</span>[<span class="type">SimpleType</span>],</span><br><span class="line"><span class="keyword">var</span> upperBounds: <span class="type">List</span>[<span class="type">SimpleType</span>])</span><br></pre></td></tr></table></figure>
<p>and to update <code>freshVar</code> correspondingly:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freshVar</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>): <span class="type">Variable</span> =</span><br><span class="line">    <span class="type">Variable</span>(<span class="keyword">new</span> <span class="type">VariableState</span>(lvl, <span class="type">Nil</span>, <span class="type">Nil</span>))</span><br></pre></td></tr></table></figure>
<p>Next, we add an implicit <code>lvl</code> parameter to the
<code>typeTerm</code> function, and we make sure to type the right-hand
sides of let bindings with a higher level than the current one:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(trm: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>, lvl: <span class="type">Int</span>): <span class="type">SimpleType</span> = trm <span class="keyword">match</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// non-recursive let bindings:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Let</span>(<span class="literal">false</span>, nme, rhs, bod) =&gt;</span><br><span class="line">        <span class="keyword">val</span> rhsTy = typeTerm(rhs)(ctx, lvl + <span class="number">1</span>) <span class="comment">// incremented level!</span></span><br><span class="line">        typeTerm(bod)(ctx + (nme =&gt; <span class="type">PolyMorphicType</span>(lvl, rhs_ty)), lvl)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并相应地更新 <code>freshVar</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freshVar</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>): <span class="type">Variable</span> =</span><br><span class="line">    <span class="type">Variable</span>(<span class="keyword">new</span> <span class="type">VariableState</span>(lvl, <span class="type">Nil</span>, <span class="type">Nil</span>))</span><br></pre></td></tr></table></figure>
<p>接下来，我们在 <code>typeTerm</code> 函数中添加一个隐式的
<code>lvl</code> 参数，并确保让绑定的右侧类型使用比当前高的级别：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(trm: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>, lvl: <span class="type">Int</span>): <span class="type">SimpleType</span> = trm <span class="keyword">match</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// non-recursive let bindings:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Let</span>(<span class="literal">false</span>, nme, rhs, bod) =&gt;</span><br><span class="line">        <span class="keyword">val</span> rhsTy = typeTerm(rhs)(ctx, lvl + <span class="number">1</span>) <span class="comment">// incremented level!</span></span><br><span class="line">        typeTerm(bod)(ctx + (nme =&gt; <span class="type">PolyMorphicType</span>(lvl, rhs_ty)), lvl)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice that in the context used to type the body of the let binding,
we wrap the right-hand side type into a <code>PolymorphicType</code>
wrapper, which is defined at the end of Figure 6. A polymorphic type
wraps a simple type body, but additionally remembers above which level
the type variables that appear in body are to be considered universally
quantified. Its <code>in instances</code> method copies body, replacing
the type variables above level with fresh variables at level
<code>lvl</code> (a task performed by <code>freshenAbove</code>, whose
implementation is too boring to warrant taking space in this paper).</p>
<p>In order to make <code>PolymorphicType</code> and
<code>SimpleType</code> type-compatible, we create a common base trait<a
href="#fn22" class="footnote-ref" id="fnref22"
role="doc-noteref"><sup>22</sup></a> <em>TypeScheme</em>, as shown in
Figure 6. This trait contains two abstract methods: one to instantiate
the type at a given level, and one to compute the level of the type. The
latter is implemented in <code>SimpleType</code> by a field which is
lazily evaluated, to avoid needless recomputation; this field is used to
remember the maximum level of any type variables contained in the
type.</p>
<p>Finally, we adapt <code>typeTerm</code> to instantiate the types
associated with variable names in <code>ctx</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Ctx</span> </span>= <span class="type">Map</span>[<span class="type">String</span>, <span class="type">TypeScheme</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(trm: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>, lvl: <span class="type">Int</span>): <span class="type">SimpleType</span> = trm <span class="keyword">match</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Var</span>(name) =&gt;</span><br><span class="line">        ctx.getOrElse(name, err(<span class="string">&quot;not found: &quot;</span> + name)).instantiate</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在用于输入 let 绑定主体的上下文中，我们将右侧的类型包装在
<code>PolymorphicType</code> 包装器中，该包装器在图 6
的末尾定义。多态类型包装一个简单类型主体，但额外记住在主体中出现的类型变量应被视为普遍量化的级别。它的
<code>in instances</code> 方法复制主体，替换级别以上的类型变量为级别
<code>lvl</code> 的新变量（这项任务由 <code>freshenAbove</code>
执行，其实现过于无聊，不值得在本文中占用空间）。</p>
<p>为了使 <code>PolymorphicType</code> 和 <code>SimpleType</code>
类型兼容，我们创建一个共同的基类特 trait<a href="#fn23"
class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>
<em>TypeScheme</em>，如图 6
所示。该特含有两个抽象方法：一个用于在给定级别实例化类型，一个用于计算类型的级别。后者在
<code>SimpleType</code>
中通过一个懒惰求值的字段实现，以避免不必要的重新计算；该字段用于记住类型中包含的任何类型变量的最大级别。</p>
<p>最后，我们调整 <code>typeTerm</code> 以实例化与 <code>ctx</code>
中变量名相关联的类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Ctx</span> </span>= <span class="type">Map</span>[<span class="type">String</span>, <span class="type">TypeScheme</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(trm: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>, lvl: <span class="type">Int</span>): <span class="type">SimpleType</span> = trm <span class="keyword">match</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Var</span>(name) =&gt;</span><br><span class="line">        ctx.getOrElse(name, err(<span class="string">&quot;not found: &quot;</span> + name)).instantiate</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TypeScheme</span> </span>&#123;</span><br><span class="line">  <span class="comment">// to be implemented in SimpleType and TypeScheme:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instantiate</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>): <span class="type">SimpleType</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">level</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="type">SimpleType</span> <span class="keyword">extends</span> <span class="type">TypeScheme</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Variable</span>(s: <span class="type">VariableState</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Primitive</span>(name: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Function</span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Record</span>(fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">SimpleType</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following members are required to implement TypeScheme:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instantiate</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>) = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> level = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Function</span>(lhs, rhs) =&gt; max(lhs.level, rhs.level)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Record</span>(fields)     =&gt; fields.map(_._2.level).maxOption.getOrElse(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Variable</span>(vs)       =&gt; vs.level</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Primitive</span>(_)       =&gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicType</span>(<span class="params">level: <span class="type">Int</span>, body: <span class="type">SimpleType</span></span>) <span class="keyword">extends</span> <span class="title">TypeScheme</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instantiate</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>) = freshenAbove(body, level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableState</span>(<span class="params">val level: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                    var lowerBounds: <span class="type">List</span>[<span class="type">SimpleType</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">                    var upperBounds: <span class="type">List</span>[<span class="type">SimpleType</span>]</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TypeScheme</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在SimpleType和TypeScheme中实现：</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instantiate</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>): <span class="type">SimpleType</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">level</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="type">SimpleType</span> <span class="keyword">extends</span> <span class="type">TypeScheme</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Variable</span>(s: <span class="type">VariableState</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Primitive</span>(name: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Function</span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Record</span>(fields: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">SimpleType</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的成员是实现TypeScheme所必需的：</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instantiate</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>) = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> level = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Function</span>(lhs, rhs) =&gt; max(lhs.level, rhs.level)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Record</span>(fields)     =&gt; fields.map(_._2.level).maxOption.getOrElse(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Variable</span>(vs)       =&gt; vs.level</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Primitive</span>(_)       =&gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicType</span>(<span class="params">level: <span class="type">Int</span>, body: <span class="type">SimpleType</span></span>) <span class="keyword">extends</span> <span class="title">TypeScheme</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instantiate</span></span>(<span class="keyword">implicit</span> lvl: <span class="type">Int</span>) = freshenAbove(body, level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableState</span>(<span class="params">val level: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                    var lowerBounds: <span class="type">List</span>[<span class="type">SimpleType</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">                    var upperBounds: <span class="type">List</span>[<span class="type">SimpleType</span>]</span>)</span></span><br></pre></td></tr></table></figure>
<p><em>Constraining with levels.</em> The next step is to make sure that
variables of higher level do not escape into the bounds of variables of
lower level. We do that by adding guards in the constraining algorithm,
preventing it from happening:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span></span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Variable</span>(lhs), rhs) <span class="keyword">if</span> rhs.level &lt;= lhs.level =&gt;  <span class="comment">// new guard here</span></span><br><span class="line">        lhs.upperBounds = rhs :: lhs.upperBounds</span><br><span class="line">        lhs.lowerBounds.foreach(constrain(_, rhs))</span><br><span class="line">    <span class="keyword">case</span> (lhs, <span class="type">Variable</span>(rhs)) iflhs.level &lt;= rhs.level =&gt; <span class="comment">// new guard here</span></span><br><span class="line">        rhs.lowerBounds = lhs :: rhs.lowerBounds</span><br><span class="line">        rhs.upperBounds.forEach(constrain(lhs, _))</span><br></pre></td></tr></table></figure>
<p><em>使用层级进行约束。</em>
下一步是确保较高层级的变量不会逃逸到较低层级变量的边界中。我们通过在约束算法中添加保护措施来防止这种情况发生：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span></span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Variable</span>(lhs), rhs) <span class="keyword">if</span> rhs.level &lt;= lhs.level =&gt;  <span class="comment">// 新的保护措施</span></span><br><span class="line">        lhs.upperBounds = rhs :: lhs.upperBounds</span><br><span class="line">        lhs.lowerBounds.foreach(constrain(_, rhs))</span><br><span class="line">    <span class="keyword">case</span> (lhs, <span class="type">Variable</span>(rhs)) <span class="keyword">if</span> lhs.level &lt;= rhs.level =&gt; <span class="comment">// 新的保护措施</span></span><br><span class="line">        rhs.lowerBounds = lhs :: rhs.lowerBounds</span><br><span class="line">        rhs.upperBounds.forEach(constrain(lhs, _))</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extrude</span></span>(ty: <span class="type">SimpleType</span>, pol: <span class="type">Boolean</span>)</span><br><span class="line">    (<span class="keyword">implicit</span> lvl: <span class="type">Int</span>, c: <span class="type">MutMap</span>[<span class="type">PolarVariable</span>, <span class="type">VariableState</span>]): <span class="type">SimpleType</span></span><br><span class="line">    = <span class="keyword">if</span> (ty.level &lt;= lvl) ty <span class="keyword">else</span> ty <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Primitive</span>(_)</span><br><span class="line">            =&gt; ty</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Function</span>(l, r)</span><br><span class="line">            =&gt; <span class="type">Function</span>(extrude(l, !pol), extrude(r, pol))</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Record</span>(fs)</span><br><span class="line">            =&gt; <span class="type">Record</span>(fs.map(nt =&gt; nt._1 -&gt; extrude(nt._2, pol)))</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Variable</span>(vs)</span><br><span class="line">            =&gt; c.getOrElse(vs -&gt; pol, &#123;</span><br><span class="line">                <span class="keyword">val</span> nvs = freshVar</span><br><span class="line">                c += vs -&gt; pol -&gt; nvs</span><br><span class="line">                <span class="keyword">if</span> (pol) &#123;</span><br><span class="line">                    vs.upperBounds ::= nvs</span><br><span class="line">                    nvs.lowerBounds = vs.lowerBounds.map(extrude(_, pol))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    vs.lowerBounds ::= nvs</span><br><span class="line">                    nvs.upperBounds = vs.upperBounds.map(extrude(_, pol))</span><br><span class="line">                &#125;</span><br><span class="line">                nvs</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Fig. 7. Type extrusion algorithm.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extrude</span></span>(ty: <span class="type">SimpleType</span>, pol: <span class="type">Boolean</span>)</span><br><span class="line">    (<span class="keyword">implicit</span> lvl: <span class="type">Int</span>, c: <span class="type">MutMap</span>[<span class="type">PolarVariable</span>, <span class="type">VariableState</span>]): <span class="type">SimpleType</span></span><br><span class="line">    = <span class="keyword">if</span> (ty.level &lt;= lvl) ty <span class="keyword">else</span> ty <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Primitive</span>(_)</span><br><span class="line">            =&gt; ty</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Function</span>(l, r)</span><br><span class="line">            =&gt; <span class="type">Function</span>(extrude(l, !pol), extrude(r, pol))</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Record</span>(fs)</span><br><span class="line">            =&gt; <span class="type">Record</span>(fs.map(nt =&gt; nt._1 -&gt; extrude(nt._2, pol)))</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Variable</span>(vs)</span><br><span class="line">            =&gt; c.getOrElse(vs -&gt; pol, &#123;</span><br><span class="line">                <span class="keyword">val</span> nvs = freshVar</span><br><span class="line">                c += vs -&gt; pol -&gt; nvs</span><br><span class="line">                <span class="keyword">if</span> (pol) &#123;</span><br><span class="line">                    vs.upperBounds ::= nvs</span><br><span class="line">                    nvs.lowerBounds = vs.lowerBounds.map(extrude(_, pol))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    vs.lowerBounds ::= nvs</span><br><span class="line">                    nvs.upperBounds = vs.upperBounds.map(extrude(_, pol))</span><br><span class="line">                &#125;</span><br><span class="line">                nvs</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>图 7. 类型挤出算法。</p>
<p>Naturally, we also need to handle the cases where there is a level
violation. In such cases, we make a copy of the problematic type up to
its type variables of wrong level (including their bounds) using the
<code>extrude</code> function, which returns a type at the right level
that mirrors the structure of the original type:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (lhs @ <span class="type">Variable_</span>, rhs0) =&gt;</span><br><span class="line">    <span class="keyword">val</span> rhs = extrude rhs0, <span class="literal">false</span>)(lhs.level, <span class="type">MutMap</span>.empty)</span><br><span class="line">    constrain (lhs, rhs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (lhs0, rhs @ <span class="type">Variable_</span>) =&gt;</span><br><span class="line">    vallhs = extrude (lhs0, <span class="literal">true</span>)(rhs.level, <span class="type">MutMap</span>.empty)</span><br><span class="line">    constrain (lhs, rhs)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>自然，我们也需要处理存在级别违规的情况。在这种情况下，我们使用
<code>extrude</code>
函数复制到其错误级别的类型变量（包括它们的边界）的有问题的类型，该函数返回一个在正确级别的类型，反映了原始类型的结构：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (lhs @ <span class="type">Variable_</span>, rhs0) =&gt;</span><br><span class="line">    <span class="keyword">val</span> rhs = extrude(rhs0, <span class="literal">false</span>)(lhs.level, <span class="type">MutMap</span>.empty)</span><br><span class="line">    constrain(lhs, rhs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (lhs0, rhs @ <span class="type">Variable_</span>) =&gt;</span><br><span class="line">    <span class="keyword">val</span> lhs = extrude(lhs0, <span class="literal">true</span>)(rhs.level, <span class="type">MutMap</span>.empty)</span><br><span class="line">    constrain(lhs, rhs)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The <code>extrude</code> function is defined in Figure 7. Its goal is
to make a copy of the problematic type such that the copy has the
requested level and soundly <em>approximates</em> the original type. If
a variable <code>vs</code> needs to be copied as part of an extruded
type, two new variables should be created, one for each of vs's bounds
(unless of course the variable occurs strictly positively or strictly
negatively, in which case one of the two bounds can be discarded). This
way, we essentially create a conservative approximation of vs in the
result of the extrusion, and any later instantiation of vs (created at
every point the nested let binding is used) will be able to receive
additional constraints independently, as long as these constraints are
within the extruded approximating bounds of vs.</p>
<p><code>extrude</code> 函数在图 7
中定义。它的目标是复制有问题的类型，使得该副本具有请求的级别并且能够合理地
<em>近似</em> 原始类型。如果需要将变量 <code>vs</code>
作为外延类型的一部分进行复制，则应创建两个新变量，一个用于每个vs的界（当然，除非变量严格正向或严格负向出现，在这种情况下可以丢弃两个边界中的一个）。通过这种方式，我们基本上在挤出的结果中创建了vs的一个保守近似，并且任何后续对vs的实例化（在每次使用嵌套let绑定时创建）都能够独立地接收额外的约束，只要这些约束在vs的挤出近似边界之内。</p>
<p>extrude recursively traverses its argument type tree up to its
subtrees of acceptable levels. When it finds a type variable vs with the
wrong level, it creates a copy nvs of the faulty type variable at the
requested level lv1 and registers the necessary constraints. This works
because nvs has a level lower than vs, satisfying the invariant on
levels. We have to recursively extrude the bound of vs to place it in
the nvs copy, but this bounds may form cycles. To avoid going into an
infinite extrusion loop, we keep a cache c of the variables already
being extruded, along with the polarity of that extrusion. In other
words, extrude copies not only type trees, but also the
potentially-cyclic subgraphs of type variable bounds which are rooted in
these type trees.</p>
<p>extrude
递归遍历其参数类型树直到可接受级别的子树。当它发现一个级别错误的类型变量
vs 时，它在请求的级别 lv1 创建一个故障类型变量 nvs
的副本，并注册必要的约束。这是可行的，因为 nvs 的级别低于
vs，满足级别不变量。我们必须递归地 extrude vs 的边界以将其放置在 nvs
副本中，但这些边界可能会形成循环。为了避免进入无限 extrusion
循环，我们保持一个已经被 extruded 的变量的缓存 c，以及该 extrusion
的极性。换句话说，extrude
不仅复制类型树，还复制这些类型树的类型变量边界的潜在循环子图。</p>
<p><em>Let polymorphism in MLsub.</em> In contrast to the approach
presented here, Dolan uses an equivalent “lambda-lifted” type system,
which associates to let-bound variables entire typing environments, in
the typing context. While this can make for a slicker specification, it
is rather counter-intuitive and thus harder to understand, creates many
useless type variables (which need to be simplified later), and
needlessly duplicates constraints, which causes inefficiencies [Pottier
1998, Chapter 16.2].</p>
<p>3.5.2 <em>Recursive Let Bindings.</em> Finally, supporting recursive
let bindings is done in the usual way, by typing the right-hand side of
the let binding with, in the context, a name bound to a type variable
which is later checked to be a supertype of the actual right-hand side
type (see Figure 8).</p>
<h2 id="summary">3.6 Summary</h2>
<p>We summarize the final typing and constraining algorithms in Figures
8 and 9, respectively.</p>
<p><em>MLsub 中的 Let 多态性。</em> 与此处提出的方法不同，Dolan
使用了一种等效的“lambda-lifted”类型系统，它将 let
绑定变量与整个类型环境关联，在类型上下文中。虽然这可以使规范更加简洁，但它相当直觉上不易理解，因此更难以把握，产生许多无用的类型变量（稍后需要简化），并不必要地重复约束，这导致效率低下
[Pottier 1998, Chapter 16.2]。</p>
<p>3.5.2 <em>递归 Let 绑定。</em> 最后，支持递归的 let
绑定是通过以通常的方式进行的，即在上下文中使用一个绑定到类型变量的名称对
let
绑定的右侧进行类型检查，该类型变量稍后被检查为实际右侧类型的超类型（见图
8）。</p>
<h2 id="总结">3.6 总结</h2>
<p>我们在图 8 和图 9 中分别总结了最终的类型和约束算法。</p>
<p>Overall, Simple-sub looks more like traditional type inference
algorithms than Dolan’s biunification, and it completely eschews the
complexities of bisubstitution and polar types. Yet, as we confirm
experimentally in Section 6, both algorithms produce equivalent results.
This shows that bisubstitution and polar types are not, in fact,
essential to type inference with subtyping and principal types in the
style of MLsub.</p>
<h2 id="simplifying-types">4 SIMPLIFYING TYPES</h2>
<p>As it is, the algorithm shown in the previous section infers types
which often contain redundancies in their structures, as well as type
variables which could be removed or unified. An important component of
type inference when subtyping is involved is to simplify the types
inferred, so as to make them compact and easy to comprehend [Pottier
1998]. If we did not perform any simplification, the inferred types
would usually grow linearly with the size of the program!</p>
<p>总体而言，Simple-sub 更像传统的类型推断算法，而不是 Dolan
的双重统一，并且完全避免了双重替换和极性类型的复杂性。然而，正如我们在第六节中通过实验确认的，两个算法产生的结果是等价的。这表明，双重替换和极性类型实际上不是在
MLsub 风格中进行带有子类型及主要类型的类型推断所必需的。</p>
<h2 id="简化类型">4 简化类型</h2>
<p>如前所述，前一节中展示的算法推断出的类型通常在结构上包含冗余部分，以及可以删除或统一的类型变量。当涉及子类型时，类型推断的一个重要组成部分是简化推断出的类型，以使其紧凑且易于理解
[Pottier
1998]。如果我们不进行任何简化，推断出的类型通常会随着程序大小的增加而线性增长！</p>
<p>In this section, we explore the design space and tradeoffs of type
simplification (Section 4.1); we recall how MLsub performs
automaton-based simplification (Section 4.2); we explain the ideas
behind Simple-sub’s more basic approach to simplification, which turns
out to be sufficient most of the time — and sometimes better (Section
4.3); and we describe an intermediate representation to facilitate the
application of these ideas (Section 4.4).</p>
<h3 id="type-simplification-tradeoffs">4.1 Type Simplification
Tradeoffs</h3>
<p>Part of the appeal of algebraic subtyping is that it produces
<em>compact</em> principal types, which are easy to read, unlike
previous approaches to subtype inference. However, this comes at a cost:
it requires making simplifying assumptions about the semantics of types.
These assumptions hold in MLsub, but may not hold in languages with more
advanced features.</p>
<p>在本节中，我们探讨类型简化的设计空间和权衡（第4.1节）；我们回顾MLsub如何执行基于自动机的简化（第4.2节）；我们解释Simple-sub更基本的简化方法背后的想法，这种方法在大多数情况下被证明是足够的——有时甚至更好（第4.3节）；我们描述了一种中间表示，以促进这些想法的应用（第4.4节）。</p>
<h3 id="类型简化的权衡">4.1 类型简化的权衡</h3>
<p>代数子类型的吸引力部分在于它产生<em>紧凑</em>的主类型，这些主类型易于阅读，不像以前的子类型推断方法。然而，这是有代价的：它需要对类型的语义做出简化假设。这些假设在MLsub中成立，但在具有更高级特性的语言中可能不成立。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(trm: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>, lvl: <span class="type">Int</span>): <span class="type">SimpleType</span> = trm <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lit</span>(n)     =&gt; <span class="type">Primitive</span>(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Var</span>(name)  =&gt; ctx.getOrElse(name, err(<span class="string">&quot;not found: &quot;</span> + name)).instantiate</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Rcd</span>(fs)    =&gt; <span class="type">Record</span>(fs.map &#123; <span class="keyword">case</span> (n, t) =&gt; (n, typeTerm(t)) &#125;)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lam</span>(name, body) =&gt;</span><br><span class="line">    <span class="keyword">val</span> param = freshVar</span><br><span class="line">    <span class="type">Function</span>(param, typeTerm(body)(ctx + (name -&gt; param), lvl))</span><br><span class="line">  <span class="keyword">case</span> <span class="type">App</span>(f, a) =&gt;</span><br><span class="line">    <span class="keyword">val</span> res = freshVar</span><br><span class="line">    constrain(typeTerm(f), <span class="type">Function</span>(typeTerm(a), res))</span><br><span class="line">    res</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sel</span>(obj, name) =&gt;</span><br><span class="line">    <span class="keyword">val</span> res = freshVar</span><br><span class="line">    constrain(typeTerm(obj), <span class="type">Record</span>((name -&gt; res) :: <span class="type">Nil</span>))</span><br><span class="line">    res</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Let</span>(isrec, nme, rhs, bod) =&gt;</span><br><span class="line">    <span class="keyword">val</span> rhs_ty = <span class="keyword">if</span> (isrec) &#123;</span><br><span class="line">      <span class="keyword">val</span> exp = freshVar(lvl + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">val</span> inf = typeTerm(rhs)(ctx + (nme -&gt; exp), lvl + <span class="number">1</span>)</span><br><span class="line">      constrain(inf, exp)</span><br><span class="line">      exp</span><br><span class="line">    &#125; <span class="keyword">else</span> typeTerm(rhs)(ctx, lvl + <span class="number">1</span>)</span><br><span class="line">    typeTerm(bod)(ctx + (nme -&gt; <span class="type">PolymorphicType</span>(lvl, rhs_ty)), lvl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fig. 8. Full specification of term typing in Simple-sub.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeTerm</span></span>(trm: <span class="type">Term</span>)(<span class="keyword">implicit</span> ctx: <span class="type">Ctx</span>, lvl: <span class="type">Int</span>): <span class="type">SimpleType</span> = trm <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lit</span>(n)     =&gt; <span class="type">Primitive</span>(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Var</span>(name)  =&gt; ctx.getOrElse(name, err(<span class="string">&quot;not found: &quot;</span> + name)).instantiate</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Rcd</span>(fs)    =&gt; <span class="type">Record</span>(fs.map &#123; <span class="keyword">case</span> (n, t) =&gt; (n, typeTerm(t)) &#125;)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lam</span>(name, body) =&gt;</span><br><span class="line">    <span class="keyword">val</span> param = freshVar</span><br><span class="line">    <span class="type">Function</span>(param, typeTerm(body)(ctx + (name -&gt; param), lvl))</span><br><span class="line">  <span class="keyword">case</span> <span class="type">App</span>(f, a) =&gt;</span><br><span class="line">    <span class="keyword">val</span> res = freshVar</span><br><span class="line">    constrain(typeTerm(f), <span class="type">Function</span>(typeTerm(a), res))</span><br><span class="line">    res</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sel</span>(obj, name) =&gt;</span><br><span class="line">    <span class="keyword">val</span> res = freshVar</span><br><span class="line">    constrain(typeTerm(obj), <span class="type">Record</span>((name -&gt; res) :: <span class="type">Nil</span>))</span><br><span class="line">    res</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Let</span>(isrec, nme, rhs, bod) =&gt;</span><br><span class="line">    <span class="keyword">val</span> rhs_ty = <span class="keyword">if</span> (isrec) &#123;</span><br><span class="line">      <span class="keyword">val</span> exp = freshVar(lvl + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">val</span> inf = typeTerm(rhs)(ctx + (nme -&gt; exp), lvl + <span class="number">1</span>)</span><br><span class="line">      constrain(inf, exp)</span><br><span class="line">      exp</span><br><span class="line">    &#125; <span class="keyword">else</span> typeTerm(rhs)(ctx, lvl + <span class="number">1</span>)</span><br><span class="line">    typeTerm(bod)(ctx + (nme -&gt; <span class="type">PolymorphicType</span>(lvl, rhs_ty)), lvl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图 8. Simple-sub 中术语类型的完整规格说明。</p>
<p>For instance, MLsub considers the types
<code>(int → int) ∧ (nat → nat)</code> and
<code>int ∪ nat → int ∧ nat</code> to be equivalent, although the latter
intuitively contains strictly <em>less</em> information. This assumption
is sound, because MLsub programs cannot distinguish between the two
types — program which works with one will also work with the other.
However, the equivalence would not hold in a language which, for
example, used intersection types to encode overloading.</p>
<p>As another example, MLsub does not distinguish between the types
<code>&#123; tag : 0; payload : str &#125; ∪ &#123; tag : 1; payload : int &#125;</code> and
<code>&#123; tag : 0 ∪ 1; payload : str ∪ int &#125;</code>, where 0 and 1 denote
singleton literal types (trivial to add to our type system). But in
languages like JavaScript which support flow typing [Pearce 2013;
Tobin-Hochstadt and Felleisen 2010], the former holds more information,
since the different types of payload could be extracted separately by
first matching on the tag.¹⁴</p>
<p>例如，MLsub认为类型<code>(int → int) ∧ (nat → nat)</code>和<code>int ∪ nat → int ∧ nat</code>是等价的，尽管后者在直观上包含的信息严格<em>少</em>。这个假设是合理的，因为MLsub程序无法区分这两种类型——处理一种的程序也可以处理另一种。然而，在一种使用交集类型来编码重载的语言中，这种等价关系就不成立了。</p>
<p>作为另一个例子，MLsub并不区分类型<code>&#123; tag : 0; payload : str &#125; ∪ &#123; tag : 1; payload : int &#125;</code>和<code>&#123; tag : 0 ∪ 1; payload : str ∪ int &#125;</code>，其中0和1表示单元素文字类型（很容易添加到我们的类型系统中）。但在支持流类型的语言如JavaScript中[Pearce
2013; Tobin-Hochstadt and Felleisen
2010]，前者包含更多信息，因为不同类型的负载可以通过首先匹配标签分别提取。<a
href="#fn24" class="footnote-ref" id="fnref24"
role="doc-noteref"><sup>24</sup></a></p>
<p>These simplifying assumptions are not <em>necessary</em> for
principal type inference — they are merely a requirement of MLsub’s
simplification and subsumption checking approaches (note that
subsumption checking is outside the scope of this paper). While they are
<em>implied</em> by Dolan’s algebraic construction of subtyping, making
them inescapable in his system, these assumptions can actually</p>
<p>这些简化假设对于主类型推断并不是<em>必要</em>的——它们仅仅是MLsub的简化和涵蓋性检查方法的要求（请注意，涵蓋性检查超出了本文的范围）。虽然它们是由Dolan的子类型代数构造<em>隐含</em>的，使得它们在他的系统中不可避免，但实际上这些假设可以</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span></span>(lhs: <span class="type">SimpleType</span>, rhs: <span class="type">SimpleType</span>)</span><br><span class="line">  (<span class="keyword">implicit</span> cache: <span class="type">MutSet</span>[(<span class="type">SimpleType</span>,<span class="type">SimpleType</span>)] = <span class="type">MutSet</span>.empty): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.contains(lhs -&gt; rhs)) <span class="keyword">return</span> () <span class="keyword">else</span> cache += lhs -&gt; rhs</span><br><span class="line">  (lhs, rhs) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Primitive</span>(n0), <span class="type">Primitive</span>(n1)) <span class="keyword">if</span> n0 != n1 =&gt; ()</span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Function</span>(l0, r0), <span class="type">Function</span>(l1, r1)) =&gt;</span><br><span class="line">      constrain(l1, l0); constrain(r0, r1)</span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Record</span>(fs0), <span class="type">Record</span>(fs1)) =&gt;</span><br><span class="line">      fs1.foreach &#123; <span class="keyword">case</span> (n1, t1) =&gt;</span><br><span class="line">        fs0.find(_._1 == n1) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; err(<span class="string">&quot;missing field: &quot;</span> + n1 + <span class="string">&quot; in &quot;</span> + lhs)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(_, t0) =&gt; constrain(t0, t1) &#125;&#125;</span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Variable</span>(lhs), rhs0) <span class="keyword">if</span> rhs.level &lt;= lhs.level =&gt;</span><br><span class="line">      lhs.upperBounds = rhs :: lhs.upperBounds</span><br><span class="line">      lhs.lowerBounds.foreach(constrain(_, rhs))</span><br><span class="line">    <span class="keyword">case</span> (lhs0, <span class="type">Variable</span>(rhs)) <span class="keyword">if</span> lhs.level &lt;= rhs.level =&gt;</span><br><span class="line">      rhs.lowerBounds = lhs :: rhs.lowerBounds</span><br><span class="line">      rhs.upperBounds.foreach(constrain(lhs, _))</span><br><span class="line">    <span class="keyword">case</span> (lhs @ <span class="type">Variable</span>(_), rhs0) =&gt;</span><br><span class="line">      <span class="keyword">val</span> rhs = extrude(rhs0, <span class="literal">false</span>)(lhs.level, <span class="type">MutMap</span>.empty)</span><br><span class="line">      constrain(lhs, rhs)</span><br><span class="line">    <span class="keyword">case</span> (lhs0, rhs @ <span class="type">Variable</span>(_)) =&gt;</span><br><span class="line">      <span class="keyword">val</span> lhs = extrude(lhs0, <span class="literal">true</span>)(rhs.level, <span class="type">MutMap</span>.empty)</span><br><span class="line">      constrain(lhs, rhs)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; err(<span class="string">&quot;cannot constrain &quot;</span> + lhs + <span class="string">&quot; &lt;: &quot;</span> + rhs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fig. 9. Full specification of subtype constraining in Simple-sub.</p>
<p>be separated from the type inference specification — we see a
syntactic interpretation of subtyping in Section 5 which does
<em>not</em> imply them, the understanding being that the system can be
completed with more rules as desired, to achieve the simplification
potential described in this section.</p>
<h2 id="type-simplification-in-mlsub">4.2 Type Simplification in
MLsub</h2>
<p>图9. Simple-sub中子类型约束的完整规范。</p>
<p>与类型推断规范分开 —
我们在第5节中看到了一种子类型的语法解释，该解释<em>不</em>意味着它们，理解是系统可以根据需要添加更多规则，以实现本节中描述的简化潜力。</p>
<h2 id="mlsub中的类型简化">4.2 MLsub中的类型简化</h2>
<p>Thanks to the simplifying assumptions described in the previous
subsection, MLsub can represent types as finite-state automata, where
the states are type variables and where the edges, which are labelled,
represent relations between these type variables. There are four sorts
of labels on any edge between two type variables <span
class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span>: an “is-a” label indicate that
<span class="math inline">\(\alpha\)</span> is a subtype of <span
class="math inline">\(\beta\)</span>; a “consumes” label indicate that
<span class="math inline">\(\alpha\)</span> is a function which takes
some <span class="math inline">\(\beta\)</span> in parameter; a
“produces” label indicate that <span
class="math inline">\(\alpha\)</span> is a function which returns some
<span class="math inline">\(\beta\)</span> as a result; and finally, a
“contains-L” label indicate that <span
class="math inline">\(\alpha\)</span> is a record which contains a field
named <span class="math inline">\(L\)</span> of type <span
class="math inline">\(\beta\)</span>. The starting state of the
automaton represents the root of the type expression.</p>
<p>This clever representation allows one to simplify types by reusing
well-known existing techniques from the domain of automata theory: type
automata can be made deterministic (“is-a”-labelled</p>
<p>由于前一小节中描述的简化假设，MLsub
可以将类型表示为有限状态自动机，其中状态是类型变量，边缘（带标签）表示这些类型变量之间的关系。在任何两个类型变量
<span class="math inline">\(\alpha\)</span> 和 <span
class="math inline">\(\beta\)</span>
之间的边缘上有四种标签：一个“is-a”标签表示 <span
class="math inline">\(\alpha\)</span> 是 <span
class="math inline">\(\beta\)</span> 的子类型；一个“consumes”标签表示
<span class="math inline">\(\alpha\)</span> 是一个以某个 <span
class="math inline">\(\beta\)</span>
为参数的函数；一个“produces”标签表示 <span
class="math inline">\(\alpha\)</span> 是一个返回某个 <span
class="math inline">\(\beta\)</span>
作为结果的函数；最后，一个“contains-L”标签表示 <span
class="math inline">\(\alpha\)</span> 是一个包含名为 <span
class="math inline">\(L\)</span> 的字段类型为 <span
class="math inline">\(\beta\)</span>
的记录。自动机的起始状态表示类型表达式的根。</p>
<p>这种巧妙的表示允许通过重用自动机理论领域中的现有技术来简化类型：类型自动机可以被制作成确定性的（“is-a”标签）</p>
<p>edges are seen as <span class="math inline">\(\epsilon\)</span>
edges, so type automata are initially non-deterministic) and then
minimized, to achieve simplification. However, this is a quite heavy and
expensive approach. We found that in practice, a more straightforward
simplification algorithm was often sufficient. We describe such an
algorithm in the rest of this section.</p>
<h2 id="type-simplification-in-simple-sub">4.3 Type Simplification in
Simple-sub</h2>
<p>Our simplification approach hinges on two main ideas:
<em>co-occurrence analysis</em> and <em>hash consing</em>.</p>
<p>4.3.1 <em>Co-occurrence Analysis.</em> Co-occurrence analysis looks
at every variable that appears in a type in both positive and negative
positions, and records along which other variables and types it always
occurs. A variable <span class="math inline">\(v\)</span> occurs along a
type <span class="math inline">\(\tau\)</span> if it is part of the same
type union ... <span class="math inline">\(\sqcup v \sqcup\)</span> ...
<span class="math inline">\(\sqcup \tau \sqcup\)</span> ... or part of
the same type intersection ... <span class="math inline">\(\sqcap v
\sqcap\)</span> ... <span class="math inline">\(\sqcap \tau
\sqcap\)</span> ...</p>
<p>Based on this information, we can perform three kinds of
simplification:</p>
<p>边被视为 <span class="math inline">\(\epsilon\)</span>
边，因此类型自动机最初是非确定性的)
然后经过最小化，以实现简化。然而，这是一种相当繁重和昂贵的方法。我们发现，在实践中，通常更直接的简化算法就足够了。我们将在本节的其余部分描述这样的算法。</p>
<h2 id="在-simple-sub-中的类型简化">4.3 在 Simple-sub 中的类型简化</h2>
<p>我们的简化方法依赖于两个主要思想：<em>共现分析</em> 和
<em>哈希一致性</em>。</p>
<p>4.3.1 <em>共现分析。</em>
共现分析查看在类型中以正面和负面位置出现的每个变量，并记录它与其他变量和类型的共同出现情况。如果一个变量
<span class="math inline">\(v\)</span> 出现在类型 <span
class="math inline">\(\tau\)</span> 旁边，则它是同一类型并的一个部分 ...
<span class="math inline">\(\sqcup v \sqcup\)</span> ... <span
class="math inline">\(\sqcup \tau \sqcup\)</span> ...
或同一类型交集的一个部分 ... <span class="math inline">\(\sqcap v
\sqcap\)</span> ... <span class="math inline">\(\sqcap \tau
\sqcap\)</span> ...</p>
<p>基于这些信息，我们可以进行三种简化：</p>
<p><em>Removal of polar variable.</em> First, we want to remove type
variables which appear only positively (or negatively) in a type
expression. For instance, consider the type inferred for <span
class="math inline">\(\lambda x.x + 1\)</span>, which is currently <span
class="math inline">\(\alpha \sqcap \text{int} \rightarrow
\text{int}\)</span> (because the typing of lambda expressions always
assigns a type variable to the parameter). The variable <span
class="math inline">\(\alpha\)</span> in this type is redundant since it
only occurs in negative position — whichever <span
class="math inline">\(\alpha\)</span> the caller may pick, the function
will still require the argument to be an int, and it will still produce
an int as a result. So we can simply remove <span
class="math inline">\(\alpha\)</span> and obtain the simplified type
<span class="math inline">\(\text{int} \rightarrow
\text{int}\)</span>.</p>
<p>As another example, the type of a function which uses its argument as
an int but never terminates, <span class="math inline">\(\text{int}
\rightarrow \alpha\)</span>, can be simplified to <span
class="math inline">\(\text{int} \rightarrow \perp\)</span>.</p>
<p><em>去除极性变量。</em>
首先，我们想要去除在类型表达式中仅以正面（或负面）出现的类型变量。例如，考虑函数
<span class="math inline">\(\lambda x.x + 1\)</span>
推断出的类型，目前是 <span class="math inline">\(\alpha \sqcap
\text{int} \rightarrow \text{int}\)</span>（因为 lambda
表达式的类型总是将类型变量分配给参数）。这个类型中的变量 <span
class="math inline">\(\alpha\)</span>
是多余的，因为它只出现在负面位置——无论调用者选择哪个 <span
class="math inline">\(\alpha\)</span>，函数仍然要求参数是
int，并且结果仍然是 int。因此，我们可以简单地去除 <span
class="math inline">\(\alpha\)</span>，得到简化后的类型 <span
class="math inline">\(\text{int} \rightarrow \text{int}\)</span>。</p>
<p>作为另一个例子，一个使用其参数作为 int 但永不终止的函数类型 <span
class="math inline">\(\text{int} \rightarrow \alpha\)</span> 可以简化为
<span class="math inline">\(\text{int} \rightarrow \perp\)</span>。</p>
<p><em>Unification of indistinguishable variables.</em> We have
previously mentioned that a type such as <span
class="math inline">\(\text{bool} \rightarrow \alpha \rightarrow \beta
\rightarrow \alpha \sqcup \beta\)</span> (the natural type of
if-then-else) is equivalent to the simpler type <span
class="math inline">\(\text{bool} \rightarrow \alpha \rightarrow
\alpha\)</span>. This is true because the positive occurrences of the
variables <span class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span> are "indistinguishable" — whenever
an <span class="math inline">\(\alpha\)</span> is produced, a <span
class="math inline">\(\beta\)</span> is also produced. Therefore, we
cannot distinguish the two variables, and they can be unified.</p>
<p>Based on the result of the co-occurrence analysis, we can unify all
those variables that always occur together either in positive or in
negative positions (or both).</p>
<p><em>不可区分变量的统一。</em> 我们之前提到过，类型 <span
class="math inline">\(\text{bool} \rightarrow \alpha \rightarrow \beta
\rightarrow \alpha \sqcup \beta\)</span>（if-then-else
的自然类型）等价于更简单的类型 <span class="math inline">\(\text{bool}
\rightarrow \alpha \rightarrow \alpha\)</span>。这是因为变量 <span
class="math inline">\(\alpha\)</span> 和 <span
class="math inline">\(\beta\)</span>
的正出现是“不可区分”的——每当产生一个 <span
class="math inline">\(\alpha\)</span> 时，<span
class="math inline">\(\beta\)</span>
也会被产生。因此，我们无法区分这两个变量，它们可以被统一。</p>
<p>根据共现分析的结果，我们可以统一那些总是一起出现在正位置或负位置（或两者）的所有变量。</p>
<p><em>Flattening of “variable sandwiches”.</em> What we call a
"variable sandwich" is an inferred type variable <span
class="math inline">\(v\)</span> which has a type <span
class="math inline">\(\tau\)</span> both as an upper bound and as a
lower bound, i.e., <span class="math inline">\(v \le \tau\)</span> and
<span class="math inline">\(v \ge \tau\)</span>. This means that <span
class="math inline">\(v\)</span> is equivalent to <span
class="math inline">\(\tau\)</span>. In a coalesced type, this will
transpire as <span class="math inline">\(v\)</span> co-occurring with
<span class="math inline">\(\tau\)</span> both positively and
negatively. So we can use the result of co-occurrence analysis to remove
variables which are sandwiched between two identical bounds. As an
example, we simplify the type <span class="math inline">\(\alpha \sqcap
\text{int} \rightarrow \alpha \sqcup \text{int}\)</span> to just <span
class="math inline">\(\text{int} \rightarrow \text{int}\)</span>.</p>
<p>Conceptually, this idea generalizes polar variable removal, which was
explained above. Indeed, if a variable never occurs positively, it
conceptually occurs both positively and negatively along with the type
<span class="math inline">\(\perp\)</span>, so we can replace that
variable with <span class="math inline">\(\perp\)</span> (i.e., remove
it from all type unions).</p>
<p><em>“变量三明治”的扁平化。</em>
我们所称的“变量三明治”是一个推断的类型变量 <span
class="math inline">\(v\)</span>，其类型 <span
class="math inline">\(\tau\)</span> 同时作为上界和下界，即 <span
class="math inline">\(v \le \tau\)</span> 和 <span
class="math inline">\(v \ge \tau\)</span>。这意味着 <span
class="math inline">\(v\)</span> 与 <span
class="math inline">\(\tau\)</span> 等价。在一个合并的类型中，这将表现为
<span class="math inline">\(v\)</span> 与 <span
class="math inline">\(\tau\)</span>
同时正向和负向共现。因此，我们可以使用共现分析的结果来移除夹在两个相同界限之间的变量。作为一个例子，我们将类型
<span class="math inline">\(\alpha \sqcap \text{int} \rightarrow \alpha
\sqcup \text{int}\)</span> 简化为仅仅 <span
class="math inline">\(\text{int} \rightarrow \text{int}\)</span>。</p>
<p>在概念上，这个思想推广了极性变量的移除，如上所述。实际上，如果一个变量从未正向出现，那么它在概念上同时与类型
<span class="math inline">\(\perp\)</span>
正向和负向出现，因此我们可以用 <span
class="math inline">\(\perp\)</span>
替换该变量（即，从所有类型的并集中移除它）。</p>
<p>All these transformations are truly simplifications, in the sense
that they yield new types which contain fewer subterms but are still
<em>equivalent</em> to the original types (i.e., the two types subsume
each other). Therefore, these transformations also preserve
principality.</p>
<p>4.3.2 <em>Hash Consing.</em> Simple-sub's other simplification
approach, <em>hash consing</em>, deals with removing duplicated
structures in coalesced type expressions.</p>
<p>Consider the following recursive term:</p>
<p><span class="math display">\[ \text{let } f = \lambda x. \{ L = x ; R
= f x \} \text{ in } f \]</span></p>
<p>The coalesced type inferred for this term would be:</p>
<p><span class="math display">\[ \alpha \rightarrow \{ L : \alpha; R :
\mu\beta. \{ L : \alpha; R : \beta \} \} \]</span></p>
<p>Notice that there is an outer record layer that is redundant. We
would like to instead infer:</p>
<p><span class="math display">\[ \alpha \rightarrow \mu\beta. \{ L :
\alpha; R : \beta \} \]</span></p>
<p>所有这些转换实际上都是简化，从这个意义上说，它们产生了包含较少子项的新类型，但仍然与原始类型<em>等价</em>（即，这两个类型可以互相包含）。因此，这些转换也保留了原始性。</p>
<p>4.3.2 <em>Hash Consing.</em> Simple-sub的另一种简化方法<em>hash
consing</em>，处理的是在合并的类型表达式中移除重复结构的问题。</p>
<p>考虑以下递归项：</p>
<p><span class="math display">\[ \text{let } f = \lambda x. \{ L = x ; R
= f x \} \text{ in } f \]</span></p>
<p>为这个项推断出的合并类型将是：</p>
<p><span class="math display">\[ \alpha \rightarrow \{ L : \alpha; R :
\mu\beta. \{ L : \alpha; R : \beta \} \} \]</span></p>
<p>注意，这里有一个冗余的外部记录层。我们希望推断出：</p>
<p><span class="math display">\[ \alpha \rightarrow \mu\beta. \{ L :
\alpha; R : \beta \} \]</span></p>
<p>This can be done by performing hash consing on the types being
coalesced, in the <code>coalesceType</code> function: instead of simply
remembering which <em>variables</em> are in the process of being
coalesced, we can remember whole type expressions; when we reach a type
expression which is already being coalesced, we introduce a recursive
type variable in this position, removing the redundant outer layer of
types like the above.</p>
<p>Interestingly, MLsub does not currently perform a comparable
simplification, so Simple-sub infers simpler types in examples like the
one above.</p>
<h2 id="an-intermediate-representation-for-simplification">4.4 An
Intermediate Representation for Simplification</h2>
<p>这可以通过在 <code>coalesceType</code>
函数中对正在合并的类型执行哈希合并来完成：我们可以记住正在合并的整个类型表达式，而不仅仅是哪个
<em>变量</em>
正在被合并；当我们遇到一个已经在合并中的类型表达式时，我们会在这个位置引入一个递归类型变量，从而去除像上述那样冗余的外层类型。</p>
<p>有趣的是，MLsub
当前并不执行类似的简化，因此在像上述示例中，Simple-sub
推导出更简单的类型。</p>
<h2 id="用于简化的中间表示">4.4 用于简化的中间表示</h2>
<p>The above two approaches do not work very well out of the box. First,
we cannot perform them on non-coalesced types, since co-occurrence
analysis would miss information which only becomes apparent after the
bounds are flattened. For instance, if we inferred a type variable <span
class="math inline">\(\alpha\)</span> with upper bounds <span
class="math inline">\(\tau_0 \rightarrow \tau_1\)</span> and <span
class="math inline">\(\tau_2 \rightarrow \tau_3\)</span>, only after we
flatten these bounds and merge the function types into <span
class="math inline">\(\tau_0 \sqcup \tau_2 \rightarrow \tau_1 \sqcap
\tau_2\)</span> do we notice the co-occurrence of <span
class="math inline">\(\tau_0\)</span>, <span
class="math inline">\(\tau_2\)</span> and <span
class="math inline">\(\tau_1\)</span>, <span
class="math inline">\(\tau_3\)</span>. Second, it is awkward to perform
the normalization steps necessary for this sort of function type merging
on the final coalesced type representation, which is syntactically too
loose (it can represent types which do not correspond to inferred types,
for instance merging unions and intersections).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title class_">CompactType</span> vars: Set[CTypeVariable],</span><br><span class="line">    prims: Set[PrimType],</span><br><span class="line">    rcd: Option[SortedMap String, CompactType]],</span><br><span class="line">    fun: Option[(CompactType, CompactType)]</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title class_">CompactTypeScheme</span> (cty: CompactType,</span><br><span class="line">    recVars: Map[CTypeVariable, CompactType])</span><br></pre></td></tr></table></figure>
<p>上述两种方法在实际应用中效果并不理想。首先，我们无法对非合并类型执行这些操作，因为共现分析会遗漏在边界被扁平化后才显现的信息。例如，如果我们推断出一个类型变量
<span class="math inline">\(\alpha\)</span>，其上界为 <span
class="math inline">\(\tau_0 \rightarrow \tau_1\)</span> 和 <span
class="math inline">\(\tau_2 \rightarrow
\tau_3\)</span>，只有在我们扁平化这些边界并将函数类型合并为 <span
class="math inline">\(\tau_0 \sqcup \tau_2 \rightarrow \tau_1 \sqcap
\tau_3\)</span> 后，我们才会注意到 <span
class="math inline">\(\tau_0\)</span>、<span
class="math inline">\(\tau_2\)</span> 与 <span
class="math inline">\(\tau_1\)</span>、<span
class="math inline">\(\tau_3\)</span>
的共现。其次，在最终的合并类型表示上执行这种函数类型合并所需的标准化步骤是尴尬的，因为它的语法过于松散（它可以表示与推断类型不对应的类型，例如合并并集和交集）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title class_">CompactType</span> vars: Set[CTypeVariable],</span><br><span class="line">    prims: Set[PrimType],</span><br><span class="line">    rcd: Option[SortedMap String, CompactType]],</span><br><span class="line">    fun: Option[(CompactType, CompactType)]</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title class_">CompactTypeScheme</span> (cty: CompactType,</span><br><span class="line">    recVars: Map[CTypeVariable, CompactType])</span><br></pre></td></tr></table></figure>
<p>For these reasons, we introduce an intermediate
<code>CompactType</code> representation between <code>SimpleType</code>
and <code>Type</code>, in which to perform simplification more easily.
The <code>CompactType</code> representation, shown above, corresponds to
a normalized representation of types where all the non-recursive
variable bounds are coalesced. The <code>recVars</code> field of
<code>CompactTypeScheme</code> records the bounds of recursive type
variables (which we cannot coalesce, as they are cyclic).</p>
<p>The <code>compactType</code> function to convert a
<code>SimpleType</code> into a <code>CompactTypeScheme</code> is
straightforward and looks like the <code>coalesceType</code> function
shown earlier. The <code>simplifyType</code> function is slightly more
complicated, as it has to perform a co-occurrence analysis pass followed
by a rewriting pass. Finally, hash consing is done as part of the
<code>coalesceCompactType</code> function. We do not show the
implementations of these functions here for lack of space, but they can
be seen in the code associated with the paper.</p>
<h2 id="formalization-of-simple-sub">5 FORMALIZATION OF SIMPLE-SUB</h2>
<p>So far, we have appealed to an intuitive understanding of subtyping,
eschewing a more explicit characterization. In this section, we make our
intuition more formal by giving a syntactic account</p>
<p>出于这些原因，我们引入了一种介于 <code>SimpleType</code> 和
<code>Type</code> 之间的中间 <code>CompactType</code>
表示，以便更容易地进行简化。上述的 <code>CompactType</code>
表示对应于类型的标准化表示，其中所有非递归变量的界限都进行了合并。<code>CompactTypeScheme</code>
的 <code>recVars</code>
字段记录了递归类型变量的界限（我们不能合并它们，因为它们是循环的）。</p>
<p>将 <code>SimpleType</code> 转换为 <code>CompactTypeScheme</code> 的
<code>compactType</code> 函数很简单，类似于前面显示的
<code>coalesceType</code> 函数。<code>simplifyType</code>
函数稍微复杂一些，因为它需要进行共现分析遍及和重写遍及。最后，哈希一致性作为
<code>coalesceCompactType</code>
函数的一部分完成。由于篇幅限制，我们在此不展示这些函数的实现，但可以在与论文相关的代码中看到它们。</p>
<h2 id="simple-sub-的形式化">5 SIMPLE-SUB 的形式化</h2>
<p>到目前为止，我们已经依赖于对子类型的直观理解，避免了更明确的表述。在这一节中，我们通过提供一个语法账户使我们的直观理解更加正式。</p>
<p><span class="math display">\[
\text{S-REFL}
\quad
\frac{}{\tau \leq \tau}
\]</span></p>
<p><span class="math display">\[
\text{S-TRANS}
\quad
\frac{
  \Sigma \vdash \tau_0 \leq \tau_1 \quad \Sigma \vdash \tau_1 \leq
\tau_2
}{
  \Sigma \vdash \tau_0 \leq \tau_2
}
\]</span></p>
<p><span class="math display">\[
\text{S-WEAKEN}
\quad
\frac{H}{\Sigma \vdash H}
\]</span></p>
<p><span class="math display">\[
\text{S-ASSUM}
\quad
\frac{\Sigma, \triangleright H \vdash H}{\Sigma \vdash H}
\]</span></p>
<p><span class="math display">\[
\text{S-HYP}
\quad
\frac{H \in \Sigma}{\Sigma \vdash H}
\]</span></p>
<p><span class="math display">\[
\text{S-REC}
\quad
\frac{}{\mu\alpha.\,\tau \equiv [\mu\alpha.\,\tau / \alpha]\tau}
\]</span></p>
<p><span class="math display">\[
\text{S-OR}
\quad
\frac{
  \forall i, \exists j,\ \Sigma \vdash \tau_i \leq \tau&#39;_j
}{
  \Sigma \vdash \bigsqcup_i \tau_i \leq \bigsqcup_j \tau&#39;_j
}
\]</span></p>
<p><span class="math display">\[
\text{S-AND}
\quad
\frac{
  \forall i, \exists j,\ \Sigma \vdash \tau_j \leq \tau&#39;_i
}{
  \Sigma \vdash \bigcap_j \tau_j \leq \bigcap_i \tau&#39;_i
}
\]</span></p>
<p><span class="math display">\[
\text{S-FUN}
\quad
\frac{
  \triangleleft\Sigma \vdash \tau_0 \leq \tau_1 \quad
\triangleleft\Sigma \vdash \tau_2 \leq \tau_3
}{
  \Sigma \vdash \tau_1 \to \tau_2 \leq \tau_0 \to \tau_3
}
\]</span></p>
<p><span class="math display">\[
\text{S-RCD}
\quad
\frac{}{
  \{ l_i : t_i \}^i \equiv \bigcap_i \{ l_i : t_i \}
}
\]</span></p>
<p><span class="math display">\[
\text{S-DEPTH}
\quad
\frac{
  \triangleleft\Sigma \vdash \tau_1 \leq \tau_2
}{
  \Sigma \vdash \{ l : \tau_1 \} \leq \{ l : \tau_2 \}
}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\triangleleft(\Sigma, H) = \triangleleft\Sigma, H \\
&amp;\triangleleft(\Sigma, \triangleright H) = \triangleleft\Sigma, H \\
&amp;\triangleleft\epsilon = \epsilon
\end{aligned}
\]</span></p>
<p>Fig. 10. Declarative subtyping rules of Simple-sub. These only cover
part of the relationships present in Dolan’s algebraic construction of
types [Dolan 2017]. More subtyping rules can be added to give desirable
properties to the system (such as distributivity of unions,
intersections, and type constructors), but they are not strictly
required for principal type inference. Note that by convention, we
consider that an empty union is ⊥ and an empty intersection is T, so
these rules cover things like int ≤ T.</p>
<p>of the minimal subtyping relationship required to make the type
inference algorithm of Section 3 sound and complete. We state the
corresponding theorems and sketch how to carry out their proofs. The
complete proofs are outside the scope of this (already quite long)
paper.</p>
<p><span class="math display">\[
\text{S-DEPTH}
\quad
\frac{
  \triangleleft\Sigma \vdash \tau_1 \leq \tau_2
}{
  \Sigma \vdash \{ l : \tau_1 \} \leq \{ l : \tau_2 \}
}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\triangleleft(\Sigma, H) = \triangleleft\Sigma, H \\
&amp;\triangleleft(\Sigma, \triangleright H) = \triangleleft\Sigma, H \\
&amp;\triangleleft\epsilon = \epsilon
\end{aligned}
\]</span></p>
<p>图10. Simple-sub
的声明性子类型规则。这些仅涵盖了Dolan的类型代数构造中存在的关系的一部分[Dolan
2017]。可以添加更多的子类型规则，以赋予系统所需的特性（例如，并集、交集和类型构造子的分配性），但这些对于主类型推断并不严格必要。请注意，根据约定，我们认为空并集是⊥，空交集是T，因此这些规则涵盖了
int ≤ T 这样的情况。</p>
<p>的最小子类型关系，以使第3节的类型推断算法是可靠和完整的。我们陈述相应的定理并概要说明如何进行证明。完整的证明超出了本文（已经相当长）的范围。</p>
<p>We restrict ourselves to the non-let-polymorphic version of
Simple-sub for simplicity.<a href="#fn25" class="footnote-ref"
id="fnref25" role="doc-noteref"><sup>25</sup></a></p>
<h2 id="a-syntax-first-definition-of-subtyping">5.1 A Syntax-First
Definition of Subtyping</h2>
<p>Figure 10 presents the minimal subtyping rules necessary to perform
sound and complete type inference in Simple-sub. The general subtyping
judgement has the form <span class="math inline">\(Σ \vdash τ_0 ≤
τ_1\)</span> and includes a subtyping context <span
class="math inline">\(Σ\)</span> made of subtyping hypotheses of the
form <span class="math inline">\(τ_2 ≤ τ_3\)</span>, possibly prefixed
with a <span class="math inline">\(▷\)</span> symbol. We use <span
class="math inline">\(Σ \vdash τ_0 ≡ τ_1\)</span> as a shorthand for
<span class="math inline">\(Σ \vdash τ_0 ≤ τ_1 ∧ Σ \vdash τ_1 ≤
τ_0\)</span>. When <span class="math inline">\(Σ\)</span> is empty, we
omit the <span class="math inline">\(Σ \vdash\)</span> and just write
<span class="math inline">\(τ_0 ≤ τ_1\)</span> and <span
class="math inline">\(τ_0 ≡ τ_1\)</span>.</p>
<p>我们将自己限制在 Simple-sub 的非 let-polymorphic 版本，以简化问题。<a
href="#fn26" class="footnote-ref" id="fnref26"
role="doc-noteref"><sup>26</sup></a></p>
<h2 id="类型子项的语法优先定义">5.1 类型子项的语法优先定义</h2>
<p>图 10 展示了在 Simple-sub
中执行声称和完整类型推断所需的最小子项规则。一般的子项判断形式为 <span
class="math inline">\(Σ \vdash τ_0 ≤
τ_1\)</span>，并包含由子项假设构成的子项上下文 <span
class="math inline">\(Σ\)</span>，假设的形式为 <span
class="math inline">\(τ_2 ≤ τ_3\)</span>，可能以 <span
class="math inline">\(▷\)</span> 符号为前缀。我们使用 <span
class="math inline">\(Σ \vdash τ_0 ≡ τ_1\)</span> 作为 <span
class="math inline">\(Σ \vdash τ_0 ≤ τ_1 ∧ Σ \vdash τ_1 ≤ τ_0\)</span>
的简写。当 <span class="math inline">\(Σ\)</span> 为空时，我们省略 <span
class="math inline">\(Σ \vdash\)</span>，只写 <span
class="math inline">\(τ_0 ≤ τ_1\)</span> 和 <span
class="math inline">\(τ_0 ≡ τ_1\)</span>。</p>
<p>Note that Figure 10 only presents a subset of all the rules one may
want in an actual system. In particular, type simplification and
subsumption checking (to determine whether one type signature is at
least as general as another) require rules to merge type constructors
like function types, so that for instance the equivalence <span
class="math inline">\((τ_0 → τ_1) ∩ (τ_2 → τ_3) ≡ τ_0 ∪ τ_1 → τ_2 ∩
τ_3\)</span> holds (see the related discussion in Section 4.1). On the
other hand, we do not expect rules like distributivity of unions over
intersections to be actually useful in a pure MLsub-style system, since
unions and intersections are normally kept separate (unions occurring
strictly positively, and intersections strictly negatively); however,
they could come in useful in a generalized system.</p>
<p>请注意，图10仅呈现了在实际系统中可能需要的所有规则的一个子集。特别是，类型简化和子类型检查（以确定一个类型签名是否至少和另一个类型签名一样一般）需要规则来合并类型构造，如函数类型，因此例如等式
<span class="math inline">\((τ_0 → τ_1) ∩ (τ_2 → τ_3) ≡ τ_0 ∪ τ_1 → τ_2
∩ τ_3\)</span>
成立（参见第4.1节中的相关讨论）。另一方面，我们不希望如交集上的并集的分配律这样的规则在纯MLsub风格的系统中实际上有用，因为并集和交集通常保持分开（并集严格正向出现，交集严格负向出现）；但是，在一个广义系统中，它们可能会有用。</p>
<h3 id="subtyping-recursive-types.">5.1.1 Subtyping Recursive
Types.</h3>
<p>A consequence of our syntactic account of subtyping is that we do not
define types as some fixed point over a generative relation, as done in,
e.g., [Dolan 2017; Pierce 2002]. Instead, we have to account for the
fact that we manipulate <em>finite</em> syntactic type trees, in which
recursive types have to be manually unfolded to derive things about
them. This is the purpose of the S-REC rule, which substitutes a
recursive types within itself to expose one layer of its underlying
definition. However, as remarked by Amadio and Cardelli [1993], the
S-REC rule alone is not sufficient to derive valid inequalities like
<span class="math inline">\(μα_0. τ → τ → α_0 ≤ μα_1. τ → α_1\)</span>
because</p>
<p>these types, although equivalent, never unfold to the precise same
syntactic representation. This motivates the next paragraph.</p>
<h3 id="子类型递归类型">5.1.1 子类型递归类型</h3>
<p>我们对子类型的语法描述的一个结果是，我们并不将类型定义为一些生成关系上的不动点，如在[Dolan
2017；Pierce
2002]中所做的那样。相反，我们必须考虑到我们操控的是<em>有限</em>的语法类型树，其中递归类型必须手动展开以推导出关于它们的信息。这就是S-REC规则的目的，它在自身内部替换递归类型，以揭示其基本定义的一层。然而，正如Amadio和Cardelli
[1993]所指出的，单独的S-REC规则不足以推导出有效的不等式，例如<span
class="math inline">\(μα_0. τ → τ → α_0 ≤ μα_1. τ →
α_1\)</span>，因为</p>
<p>这些类型虽然是等价的，但从未展开成完全相同的语法表示。这激励了下一段。</p>
<p>5.1.2 <em>Subtyping Hypotheses.</em> We make use of the environment Σ
to store subtyping hypotheses, to be leveraged later using the S-HYP
rule. We have to be careful not to allow the use of a hypothesis right
after assuming it, which would obviously make the system unsound. In the
specification of their constraint solving algorithm, Hosoya et al.
[2005] use two distinct judgments ⊢ and ⊢' to distinguish from places
where the hypotheses can or cannot be used. We take a different, but
related approach. Our S-Assum subtyping rule resembles the Löb rule
described by Appel et al. [2007], which uses the “later” modality ▷ in
order to delay the applicability of hypotheses — by placing this symbol
in front of the hypothesis being assumed, we prevent its immediate usage
by S-HYP. We eliminate ▷ when passing through a function or record
constructor, using ◁ to remove all ▷ occurrences from the set of
hypotheses, thereby unlocking them for use by S-HYP.</p>
<p>5.1.2 <em>子类型假设。</em> 我们利用环境 Σ
来存储子类型假设，以便稍后通过 S-HYP
规则使用。我们必须小心不要在假设后立即使用该假设，这显然会导致系统的不健全。在他们的约束求解算法的规范中，Hosoya
等人 [2005] 使用两个不同的判断 ⊢ 和 ⊢'
来区分可以使用和不能使用假设的地方。我们采取一种不同但相关的方法。我们的
S-Assum 子类型规则类似于 Appel 等人 [2007] 所描述的 Löb
规则，它使用“later”模态 ▷
来延迟假设的适用性——通过将此符号放在假设前面，我们防止其被 S-HYP
立即使用。我们在通过函数或记录构造函数时消除 ▷，使用 ◁
从假设集中移除所有 ▷ 出现，从而解锁它们以供 S-HYP 使用。</p>
<p>These precautions reflect the “guardedness” restrictions used by
Dolan [2017] on recursive types, which prevents usages of α that are not
guarded by → or { ... } in a recursive type µα. τ. By contrast, our
restriction is not a syntactic one, and contrary to Dolan we do allow
types like µα. α — this type unfolds into itself by S-REC — and µα. α ∩
α, about which no useful assumptions can be leveraged, since they never
go through a function or record constructor.</p>
<p>5.1.3 <em>Example.</em> As an example, let us try to derive the
following inequality, which states that the type of a function taking
two curried τ arguments an arbitrary number of times is a <em>special
case</em> of the type of a function taking a single τ argument an
arbitrary number of times:</p>
<p><span class="math display">\[
\mu\alpha_0. \tau \to \tau \to \alpha_0 \le \mu\alpha_1. \tau \to
\alpha_1
\]</span></p>
<p>To facilitate the development, we use the shorthands τ₀ = μα₀. τ → τ
→ α₀; τ₁ = μα₁. τ → α₁; and H = τ₀ ≤ τ₁. We start by deriving that the
respective unfoldings of the recursive types are subtypes; that is, that
τ → τ → τ₀ ≤ τ → τ₁ (1). Note that for conciseness, we omit the
applications of S-WEAKEN in the derivations below:</p>
<p>这些预防措施反映了Dolan
[2017]对递归类型使用的“受限性”限制，这防止了在递归类型µα.
τ中使用未被→或{...}保护的α。相比之下，我们的限制不是一个语法上的限制，与Dolan不同，我们确实允许像µα.
α这样的类型——这个类型通过S-REC展开成它自己——以及µα. α ∩
α，关于这些类型没有可用的有用假设，因为它们从未经过函数或记录构造器。</p>
<p>5.1.3 <em>示例.</em>
作为一个例子，让我们尝试推导以下不等式，它指出一个函数接受两个柯里化τ参数任意次数的类型是一个函数接受单个τ参数任意次数的类型的<em>特例</em>：</p>
<p><span class="math display">\[
\mu\alpha_0. \tau \to \tau \to \alpha_0 \le \mu\alpha_1. \tau \to
\alpha_1
\]</span></p>
<p>为了方便发展，我们使用简写τ₀ = μα₀. τ → τ → α₀; τ₁ = μα₁. τ → α₁;
以及H = τ₀ ≤ τ₁。我们开始推导递归类型的相应展开是子类型；也就是说，τ → τ
→ τ₀ ≤ τ → τ₁
(1)。请注意，为了简洁，我们在下面的推导中省略了S-WEAKEN的应用：</p>
<p><span class="math display">\[
\begin{tikzcd}[column sep=2.8em, row sep=2.8em]
    \begin{array}{c} \text{REFL} \\ H \vdash \tau \le \tau \end{array}
&amp;
    \begin{array}{c} \text{FUN} \\ \frac{H \vdash \tau \le \tau}{H
\vdash \tau \to \tau_0 \le \tau \to \tau_1} \end{array} &amp;
    \begin{array}{c} \text{HYP} \\ \frac{(\tau_0 \le \tau_1) \in H}{H
\vdash \tau_0 \le \tau_1} \end{array} &amp;
    \begin{array}{c} \text{REC} \\ H \vdash \tau \to \tau_1 \le \tau_1
\end{array} &amp;
    \begin{array}{c} \text{TRANS} \\ \frac{H \vdash \tau \to \tau_0 \le
\tau_1}{\vdash H \vdash \tau \to \tau \to \tau_0 \le \tau \to \tau_1}
\end{array} \\
    \multicolumn{5}{c}{(1)}
\end{tikzcd}
\]</span></p>
<p>Then, we simply have to fold back the unfolded recursive types, using
<em>REC</em> and <em>TRANS</em>:</p>
<p><span class="math display">\[
\begin{tikzcd}[column sep=2.8em, row sep=2.8em]
    \begin{array}{c} \text{REFL} \\ H \vdash \tau \le \tau \end{array}
&amp;
    \begin{array}{c} \text{FUN} \\ \frac{H \vdash \tau \le \tau}{H
\vdash \tau \to \tau_0 \le \tau \to \tau_1} \end{array} &amp;
    \begin{array}{c} \text{HYP} \\ \frac{(\tau_0 \le \tau_1) \in H}{H
\vdash \tau_0 \le \tau_1} \end{array} &amp;
    \begin{array}{c} \text{REC} \\ H \vdash \tau \to \tau_1 \le \tau_1
\end{array} &amp;
    \begin{array}{c} \text{TRANS} \\ \frac{H \vdash \tau \to \tau_0 \le
\tau_1}{\vdash H \vdash \tau \to \tau \to \tau_0 \le \tau \to \tau_1}
\end{array} \\
    \multicolumn{5}{c}{(1)}
\end{tikzcd}
\]</span></p>
<p>然后，我们只需使用 <em>REC</em> 和 <em>TRANS</em>
将展开的递归类型折叠回去：</p>
<p><span class="math display">\[
\begin{tikzcd}[column sep=2.8em, row sep=2.8em]
    \begin{array}{c} \text{TRANS} \\ \frac{\begin{array}[t]{c}
\text{REC} \\ \multicolumn{2}{c}{\begin{array}[t]{c} \vdash H \vdash
\tau_0 \le \tau \to \tau \to \tau_0 \end{array}}
\end{array}}{\begin{array}[t]{c} \vdash H \vdash \tau_0 \le \tau \to
\tau_1 \end{array}} \end{array} &amp;
    \begin{array}{c} \text{ASSUM} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau_0 \le \tau_1 \end{array}}{\tau_0 \le \tau_1} \end{array}
&amp;
    \begin{array}{c} \text{REC} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau \to \tau_1 \le \tau_1 \end{array}}{\vdash H \vdash \tau \to
\tau_1 \le \tau_1} \end{array} &amp;
    \begin{array}{c} \text{TRANS} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau_0 \le \tau \to \tau_1 \end{array}}{\vdash H \vdash \tau \to
\tau_1 \le \tau_1} \end{array} &amp;
    \begin{array}{c} \text{ASSUM} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau_0 \le \tau_1 \end{array}}{\tau_0 \le \tau_1} \end{array} \\
    \multicolumn{5}{c}{(1)}
\end{tikzcd}
\]</span></p>
<p>5.2 Simplified Algorithms and Mutability</p>
<p><span class="math display">\[
\begin{tikzcd}[column sep=2.8em, row sep=2.8em]
    \begin{array}{c} \text{传递性} \\ \frac{\begin{array}[t]{c}
\text{假设} \\ \multicolumn{2}{c}{\begin{array}[t]{c} \vdash H \vdash
\tau_0 \le \tau \to \tau \to \tau_0 \end{array}}
\end{array}}{\begin{array}[t]{c} \vdash H \vdash \tau_0 \le \tau \to
\tau_1 \end{array}} \end{array} &amp;
    \begin{array}{c} \text{假设} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau_0 \le \tau_1 \end{array}}{\tau_0 \le \tau_1} \end{array}
&amp;
    \begin{array}{c} \text{递归} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau \to \tau_1 \le \tau_1 \end{array}}{\vdash H \vdash \tau \to
\tau_1 \le \tau_1} \end{array} &amp;
    \begin{array}{c} \text{传递性} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau_0 \le \tau \to \tau_1 \end{array}}{\vdash H \vdash \tau \to
\tau_1 \le \tau_1} \end{array} &amp;
    \begin{array}{c} \text{假设} \\ \frac{\begin{array}[t]{c} \vdash H
\vdash \tau_0 \le \tau_1 \end{array}}{\tau_0 \le \tau_1} \end{array} \\
    \multicolumn{5}{c}{(1)}
\end{tikzcd}
\]</span></p>
<p>5.2 简化算法与可变性</p>
<p>For ease of formal reasoning, we use a simpler definition of type
coalescing, shown in Figure 11. In this definition, we refer to
TypeVariable(vs.uniqueName) as α<sub>vs</sub>, and we use
α<sub>vs</sub><sup>+</sup> and α<sub>vs</sub><sup>-</sup> to denote two
additional (distinct) unique names, to be used as positive and negative
recursive occurrence binders — they serve the purpose of
freshVar.uniqueName in the version of type coalescing shown in Section
3.3. Similarly, it is possible to give a simpler (but less efficient)
definition of the constrain</p>
<p>function using immutable data structures instead of mutable ones,
which is easily proven equivalent; we do not show this simpler version
here for lack of space, but assume its existence.</p>
<p>为了方便形式推理，我们使用了一种更简单的类型合并定义，见图11。在这个定义中，我们将
TypeVariable(vs.uniqueName) 称为 α<sub>vs</sub>，并用
α<sub>vs</sub><sup>+</sup> 和 α<sub>vs</sub><sup>-</sup>
来表示两个额外的（不同的）唯一名称，作为正递归出现绑定器和负递归出现绑定器——它们在类型合并的版本中起着
freshVar.uniqueName
的作用，如第3.3节所示。类似地，可以使用不可变数据结构而不是可变数据结构给出约束函数的更简单（但效率较低）定义，这很容易证明是等价的；由于篇幅有限，我们在这里不展示这个更简单的版本，但假设它的存在。</p>
<p>The only mutability left in the simplified algorithms is the
mutability of type variable bounds. We refer to these bounds
collectively as σ, which maps each VariableState instance to its current
upper and lower bounds. We write foo(args)ₐ ⇝σ' res to denote the
execution of some function foo given bounds σ and having the effect of
producing the new bounds σ'. We use the shorthand
lb<sup>vs</sup><sub>σ</sub> for vs.lowerBounds<sub>σ</sub> and
ub<sup>vs</sup><sub>σ</sub> for vs.upperBounds<sub>σ</sub>.</p>
<p>5.3 Soundness and Completeness</p>
<p>Our theorems of interest are the soundness and completeness of
Simple-sub:</p>
<p>THEOREM 1 (SOUNDNESS). <em>Simple-sub only yields types which comply
with the declarative type system: if typeTerm(t)(empty)₀ ⇝σ st for some
st and σ, then there exists a type τ such that τ ⊢ t : τ and τ ≤<span
class="math inline">\(^V\)</span>
E<sub>σ</sub><sup>+</sup>[[st]].</em></p>
<p>THEOREM 2 (COMPLETENESS). *Simple-sub always finds principal type
schemes: if τ : t, then typeTerm(t)(empty)₀ ⇝σ st for some st and σ, and
<span class="math inline">\(E_σ^+ \ [[st]] ≤^V τ\)</span>.</p>
<p>5.3.1 Soundness. As usual, proving the theorem requires proving a
more general lemma.</p>
<p>文本翻译如下：</p>
<p>在简化算法中唯一剩下的可变性是类型变量边界的可变性。我们将这些边界统称为
σ，它将每个 VariableState 实例映射到其当前的上界和下界。我们写
foo(args)ₐ ⇝σ' res 来表示在给定边界 σ 的情况下执行某个函数
foo，并产生新的边界 σ'。我们使用简写 lb<sup>vs</sup><sub>σ</sub> 表示
vs.lowerBounds<sub>σ</sub>，ub<sup>vs</sup><sub>σ</sub> 表示
vs.upperBounds<sub>σ</sub>。</p>
<p>5.3 声明性与完整性</p>
<p>我们关注的定理是 Simple-sub 的声明性和完整性：</p>
<p>定理 1（声明性）。<em>Simple-sub
仅产生与声明性类型系统相符的类型：如果 typeTerm(t)(empty)₀ ⇝σ st
对于某些 st 和 σ 成立，则存在一个类型 τ，使得 τ ⊢ t : τ 且 τ ≤<span
class="math inline">\(^V\)</span>
E<sub>σ</sub><sup>+</sup>[[st]]。</em></p>
<p>定理 2（完整性）。Simple-sub 始终找到主类型方案：如果 τ :
t，则存在某些 st 和 σ，使得 typeTerm(t)(empty)₀ ⇝σ st，以及 <span
class="math inline">\(E_σ^+ \ [[st]] ≤^V τ\)</span>。</p>
<p>5.3.1 声明性。与往常一样，证明该定理需要证明一个更一般的引理。</p>
<p>We use <em>unifying type coalescing</em> (Figure 12) — a variant of
type coalescing which allows proving the soundness lemmas more easily.
The crucial property of unifying coalescing is that it instantiates each
type variable α<sub>vs</sub> in a way that makes the positive coalescing
of vs a subtype of its negative coalescing, as long as all lower bounds
of vs are subtypes of all its upper bounds — i.e., its bounds are
<em>consistent</em>. We also denote by τ<sub>cons</sub> σ the fact that
the bounds of all variables in σ are consistent.</p>
<p><strong>Lemma 1 (Soundness — General).</strong> Assuming <span
class="math inline">\(\vdash_{\text{cons}} \sigma\)</span> and <span
class="math inline">\(\text{typeTerm}(t)(\text{ctx})_\sigma
\Downarrow_{\sigma&#39;} \text{st}\)</span>, then <span
class="math inline">\(\vdash_{\text{cons}} \sigma&#39;\)</span> and
<span class="math inline">\(\mathcal{E}^-_{\sigma&#39;}[\text{ctx}]
\vdash t : \mathcal{E}^-_{\sigma&#39;}[\text{st}]\)</span>.</p>
<p>The proof is by induction on the executions of typeTerm, assuming
that typeTerm terminates successfully. In the process, we need a number
of auxiliary lemmas, most of which we do not show here. The core of the
proof actually resides in the proof of <em>sound constraining</em>
(Lemma 2).</p>
<p><span class="math display">\[
\mathbf{E}^{\phi}_{\sigma}[\mathrm{Primitive}(n)]\,C = n
\]</span></p>
<p>我们使用 <em>unifying type coalescing</em>（图12）——
一种类型聚合的变体，允许更容易地证明声学引理。统一聚合的关键性质是，它以一种方式实例化每个类型变量
α<sub>vs</sub>，使得 vs 的正聚合是其负聚合的子类型，只要 vs
的所有下界都是其所有上界的子类型 —— 即，它的界限是 <em>consistent</em>
的。我们还用 τ<sub>cons</sub> σ 表示 σ
中所有变量的界限是一致的事实。</p>
<p>引理1（SOUNDNESS — 一般）。 假设 <span
class="math inline">\(\vdash_{\text{cons}} \sigma\)</span> 且 <span
class="math inline">\(\text{typeTerm}(t)(\text{ctx})_\sigma
\Downarrow_{\sigma&#39;} \text{st}\)</span>，则 <span
class="math inline">\(\vdash_{\text{cons}} \sigma&#39;\)</span> 且 <span
class="math inline">\(\mathcal{E}^-_{\sigma&#39;}[\text{ctx}] \vdash t :
\mathcal{E}^-_{\sigma&#39;}[\text{st}]\)</span></p>
<p>证明是通过对 typeTerm 执行的归纳，假设 typeTerm
成功终止。在此过程中，我们需要几个辅助引理，其中大部分在这里不展示。证明的核心实际上在于
<em>sound constraining</em> 的证明（引理2）。</p>
<p><span class="math display">\[
\mathbf{E}^{\phi}_{\sigma}[\mathrm{Primitive}(n)]\,C = n
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{\phi}_{\sigma}[\mathrm{Function}(s,t)]\,C =
\mathbf{E}^{-\phi}_{\sigma}[s]\,C \to \mathbf{E}^{\phi}_{\sigma}[t]\,C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{\phi}_{\sigma}[\mathrm{Record}(fs)]\,C =
\bigcap_{(n,t)\,\in\,fs} \{ n : \mathbf{E}^{\phi}_{\sigma}[t]\,C \}
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{-}_{\sigma}[\mathrm{Variable}(vs)]\,C = \alpha^{-}_{vs}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\text{if
} (vs, -) \in C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{-}_{\sigma}[\mathrm{Variable}(vs)]\,C =
\mu\alpha^{-}_{vs}.\,\alpha_{vs} \cap
\bigcap_{u\in\mathrm{ub}^{vs}_{\sigma}} \mathbf{E}^{-}_{\sigma}[u]\,(C
\cup \{(vs, -)\}) \quad\quad\text{if } (vs, -) \notin C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{+}_{\sigma}[\mathrm{Variable}(vs)]\,C = \alpha^{+}_{vs}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\text{if
} (vs, +) \in C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{+}_{\sigma}[\mathrm{Variable}(vs)]\,C =
\mu\alpha^{+}_{vs}.\,\alpha_{vs} \cup
\bigsqcup_{l\in\mathrm{lb}^{vs}_{\sigma}} \mathbf{E}^{+}_{\sigma}[l]\,(C
\cup \{(vs, +)\}) \quad\quad\text{if } (vs, +) \notin C
\]</span></p>
<p>Fig. 11. Type coalescing, where the metavariable φ is either + or −
and ¬(+) = − and ¬(−) = +.</p>
<p><span class="math display">\[
\mathbf{E}^{\phi}_{\sigma}[\mathrm{Function}(s,t)]\,C =
\mathbf{E}^{-\phi}_{\sigma}[s]\,C \to \mathbf{E}^{\phi}_{\sigma}[t]\,C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{\phi}_{\sigma}[\mathrm{Record}(fs)]\,C =
\bigcap_{(n,t)\,\in\,fs} \{ n : \mathbf{E}^{\phi}_{\sigma}[t]\,C \}
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{-}_{\sigma}[\mathrm{Variable}(vs)]\,C = \alpha^{-}_{vs}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\text{如果
} (vs, -) \in C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{-}_{\sigma}[\mathrm{Variable}(vs)]\,C =
\mu\alpha^{-}_{vs}.\,\alpha_{vs} \cap
\bigcap_{u\in\mathrm{ub}^{vs}_{\sigma}} \mathbf{E}^{-}_{\sigma}[u]\,(C
\cup \{(vs, -)\}) \quad\quad\text{如果 } (vs, -) \notin C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{+}_{\sigma}[\mathrm{Variable}(vs)]\,C = \alpha^{+}_{vs}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\text{如果
} (vs, +) \in C
\]</span></p>
<p><span class="math display">\[
\mathbf{E}^{+}_{\sigma}[\mathrm{Variable}(vs)]\,C =
\mu\alpha^{+}_{vs}.\,\alpha_{vs} \cup
\bigsqcup_{l\in\mathrm{lb}^{vs}_{\sigma}} \mathbf{E}^{+}_{\sigma}[l]\,(C
\cup \{(vs, +)\}) \quad\quad\text{如果 } (vs, +) \notin C
\]</span></p>
<p>图 11. 类型合并，其中元变量 φ 是 + 或 −，并且 ¬(+) = − 和 ¬(−) =
+。</p>
<p><span class="math display">\[
\begin{aligned}
\mathcal{E}_\sigma^-[\mathrm{Variable}(vs)]\,C &amp;= \mu\alpha_{vs}^-.
\bigcap_{u \in \mathrm{ub}^{vs}_\sigma}
\mathcal{E}_\sigma^-[\![u]\!]\,(C \cup \{(vs, -)\}) &amp; \text{if }
(vs, -) \notin C \\
\mathcal{E}_\sigma^+[\mathrm{Variable}(vs)]\,C &amp;= \mu\alpha_{vs}^+.
\mathcal{E}_\sigma^-[\mathrm{Variable}(vs)]\,C \cup \bigsqcup_{l \in
\mathrm{lb}_\sigma^{vs}} \mathcal{E}_\sigma^+[\![\ ]\!]\,(C \cup \{(vs,
+)\}) &amp; \text{if } (vs, +) \notin C
\end{aligned}
\]</span></p>
<p>Fig. 12. Unifying type coalescing. All other cases are exactly like
in Figure 11, and are omitted.</p>
<p><strong>LEMMA 2 (SOUNDNESS OF CONSTRAINING).</strong> <em>When it
succeeds, constraining in consistent bounds ensures that the bounds
remain consistent and the coalescing of the constrained types become
subtypes: if <span class="math inline">\(\vdash_{\text{cons}}
\sigma\)</span> and constrain(st₀, st₁)ₐ <span
class="math inline">\(\Downarrow\)</span> <em>σ'</em> (), then <span
class="math inline">\(\vdash_{\text{cons}} \sigma&#39;\)</span> and
<span class="math inline">\(\mathcal{E}_{\sigma&#39;}^-[st₀] \le
\mathcal{E}_{\sigma&#39;}^+[st₁]\)</span>.</em></p>
<p><span class="math display">\[
\begin{aligned}
\mathcal{E}_\sigma^-[\mathrm{Variable}(vs)]\,C &amp;= \mu\alpha_{vs}^-.
\bigcap_{u \in \mathrm{ub}^{vs}_\sigma}
\mathcal{E}_\sigma^-[\![u]\!]\,(C \cup \{(vs, -)\}) &amp; \text{如果 }
(vs, -) \notin C \\
\mathcal{E}_\sigma^+[\mathrm{Variable}(vs)]\,C &amp;= \mu\alpha_{vs}^+.
\mathcal{E}_\sigma^-[\mathrm{Variable}(vs)]\,C \cup \bigsqcup_{l \in
\mathrm{lb}_\sigma^{vs}} \mathcal{E}_\sigma^+[\![\ ]\!]\,(C \cup \{(vs,
+)\}) &amp; \text{如果 } (vs, +) \notin C
\end{aligned}
\]</span></p>
<p>图12. 统一类型合并。其他所有情况与图11完全相同，故省略。</p>
<p><strong>引理2（约束的有效性）。</strong>
<em>当成功时，在一致的界限内进行约束确保界限保持一致，且被约束类型的合并变为子类型：如果
<span class="math inline">\(\vdash_{\text{cons}} \sigma\)</span> 且
constrain(st₀, st₁)ₐ <span class="math inline">\(\Downarrow\)</span>
<em>σ'</em> ()，那么 <span class="math inline">\(\vdash_{\text{cons}}
\sigma&#39;\)</span> 且 <span
class="math inline">\(\mathcal{E}_{\sigma&#39;}^-[st₀] \le
\mathcal{E}_{\sigma&#39;}^+[st₁]\)</span>.</em></p>
<p>This is proven by induction on executions of the constraining calls.
We actually need a stronger induction hypothesis, which relates the
subtyping context <span class="math inline">\(\Sigma\)</span> with the
constraining cache, talks precisely about the bounds introduced by each
call, and states that existing subtyping relations between coalesced
types are not altered by further constraining calls. The <em>Variable
cases</em> are quite subtle; when we insert the new bound into the
variable’s state, we temporarily break the consistency of the variable’s
bounds, but we restore it as an effect of the following recursive calls
to propagate the bound. To apply the induction on these recursive calls,
we need to loosen the “consistent bounds” premise of the hypothesis,
making an exception for those variables which appear as part of the
current constraining cache, thus allowing the calls to happen in
partially-broken bounds.</p>
<h3 id="completeness.">5.3.2 Completeness.</h3>
<p>Completeness is proven through the following more general lemma:</p>
<p>这通过对约束调用执行的归纳证明。我们实际上需要一个更强的归纳假设，它将子类型上下文
<span class="math inline">\(\Sigma\)</span>
与约束缓存相关联，准确地讨论每个调用引入的界限，并声明已合并类型之间的现有子类型关系不受进一步约束调用的影响。<em>变量情况</em>非常微妙；当我们将新界限插入变量的状态时，我们暂时打破了变量界限的一致性，但我们会在后续递归调用中恢复它，以传播该界限。为了对这些递归调用应用归纳，我们需要放宽假设中的“一致界限”前提，对那些作为当前约束缓存一部分出现的变量作出例外，从而允许在部分破坏的界限中进行调用。</p>
<h3 id="完整性">5.3.2 完整性。</h3>
<p>完整性通过以下更一般的引理证明：</p>
<p><strong>LEMMA 3 (COMPLETENESS — GENERAL).</strong> *Assuming <span
class="math inline">\(\Gamma \vdash t : \tau\)</span>, then for all
<span class="math inline">\(ctx\)</span>, <span
class="math inline">\(\sigma\)</span>, and type-variable substitution
<span class="math inline">\(\rho\)</span>, if <span
class="math inline">\(\rho(E_\sigma^-[ctx]) \equiv \Gamma\)</span> then
typeTerm(t)(ctx)ₐ <span class="math inline">\(\Downarrow\)</span> _σ'_st
for some st and <span class="math inline">\(\sigma&#39;\)</span>, and
there exists a substitution <span
class="math inline">\(\rho&#39;\)</span> such that <span
class="math inline">\(\rho&#39;(E_{\sigma&#39;}^-[ctx]) \equiv
\Gamma\)</span> and <span
class="math inline">\(\rho&#39;(E_{\sigma&#39;}^+[st]) \le
\tau\)</span>.*</p>
<p>Remark that “there exists a <span
class="math inline">\(\rho&#39;\)</span> such that <span
class="math inline">\(\rho&#39;(\tau_0) \le \tau_1\)</span>” is
equivalent to “<span class="math inline">\(\tau_0 \le^\forall
\tau_1\)</span>” by definition of the subsumption relation <span
class="math inline">\(\le^\forall\)</span>. Again, the core of the proof
resides in lemmas about constraining.</p>
<p><strong>LEMMA 4 (TERMINATION OF CONSTRAINING).</strong> *For all st₀,
st₁, and <span class="math inline">\(\sigma\)</span>, either
constrain(st₀, st₁)ₐ hits an err(...) case and fails, or there exists a
<span class="math inline">\(\sigma&#39;\)</span> such that
constrain(st₀, st₁)ₐ <span class="math inline">\(\Downarrow\)</span>
_<span class="math inline">\(\sigma&#39;\)</span>().*</p>
<p><strong>引理 3 (完备性 — 一般).</strong> *假设 <span
class="math inline">\(\Gamma \vdash t : \tau\)</span>，则对于所有 <span
class="math inline">\(ctx\)</span>、<span
class="math inline">\(\sigma\)</span> 和类型变量替换 <span
class="math inline">\(\rho\)</span>，如果 <span
class="math inline">\(\rho(E_\sigma^-[ctx]) \equiv \Gamma\)</span>，则
typeTerm(t)(ctx)ₐ <span class="math inline">\(\Downarrow\)</span> _σ'_st
对某些 st 和 <span class="math inline">\(\sigma&#39;\)</span>
成立，并且存在一个替换 <span class="math inline">\(\rho&#39;\)</span>
使得 <span class="math inline">\(\rho&#39;(E_{\sigma&#39;}^-[ctx])
\equiv \Gamma\)</span> 且 <span
class="math inline">\(\rho&#39;(E_{\sigma&#39;}^+[st]) \le
\tau\)</span>。*</p>
<p>注意，“存在一个 <span class="math inline">\(\rho&#39;\)</span> 使得
<span class="math inline">\(\rho&#39;(\tau_0) \le
\tau_1\)</span>”根据子类关系 <span
class="math inline">\(\le^\forall\)</span> 的定义等价于“<span
class="math inline">\(\tau_0 \le^\forall
\tau_1\)</span>”。再次强调，证明的核心在于关于约束的引理。</p>
<p><strong>引理 4 (约束的终止).</strong> *对于所有 st₀、st₁ 和 <span
class="math inline">\(\sigma\)</span>，要么 constrain(st₀, st₁)ₐ 命中
err(...) 情况并失败，要么存在一个 <span
class="math inline">\(\sigma&#39;\)</span> 使得 constrain(st₀, st₁)ₐ
<span class="math inline">\(\Downarrow\)</span> _<span
class="math inline">\(\sigma&#39;\)</span>()。*</p>
<p><strong>LEMMA 5 (COMPLETENESS OF CONSTRAINING).</strong>
*Constraining succeeds on types whose coalesced forms are subtypes, and
it does not alter existing subtyping relationships: for all st₀, st₁,
<span class="math inline">\(\rho\)</span>, and <span
class="math inline">\(\sigma\)</span>, if <span
class="math inline">\(\rho(E_\sigma^-[st₀]) \le
E_\sigma^+[st₁]\)</span>, then constrain(st₀, st₁)ₐ <span
class="math inline">\(\Downarrow\)</span> _<span
class="math inline">\(\sigma&#39;\)</span>() for some <span
class="math inline">\(\sigma&#39;\)</span> - i.e., constraining does not
yield an error — and for all st₂, st₃, <span
class="math inline">\(\sigma&#39;\)</span> such that constrain(st₂,
st₃)ₐ <span class="math inline">\(\Downarrow _\sigma&#39;\)</span>(),
then <span class="math inline">\(\rho(E_{\sigma&#39;}^-[st₀]) \le
E_{\sigma&#39;}^+[st₁]\)</span>.*</p>
<p><strong>引理 5 (约束的完整性)。</strong>
*限制在其合并形式为子类型的类型上成功，并且不会改变现有的子类型关系：对于所有的
st₀, st₁, <span class="math inline">\(\rho\)</span>, 和 <span
class="math inline">\(\sigma\)</span>，如果 <span
class="math inline">\(\rho(E_\sigma^-[st₀]) \le
E_\sigma^+[st₁]\)</span>，则 constrain(st₀, st₁)ₐ <span
class="math inline">\(\Downarrow\)</span> _<span
class="math inline">\(\sigma&#39;\)</span>() 对某个 <span
class="math inline">\(\sigma&#39;\)</span> 成立 — 即，限制不会产生错误 —
并且对于所有的 st₂, st₃, <span
class="math inline">\(\sigma&#39;\)</span>，如果 constrain(st₂, st₃)ₐ
<span class="math inline">\(\Downarrow _\sigma&#39;\)</span>()，则 <span
class="math inline">\(\rho(E_{\sigma&#39;}^-[st₀]) \le
E_{\sigma&#39;}^+[st₁]\)</span>.*</p>
<p>We prove Lemmas 3 and 5 by induction on typing and subtyping
derivations, respectively. The rule S-TRANS causes some trouble: in case
the subtyping derivation used it, we get premises which refer to
derivations on which we cannot apply the induction, because they do not
correspond to recursive constrain calls. S-TRANS can be removed from the
system and proven from the other rules only in an empty subtyping
context; indeed, <span class="math inline">\(\Sigma\)</span> could in
principle include transitivity-breaking hypotheses, such as <span
class="math inline">\((\top \le \bot) \in \Sigma\)</span>. But the
subtyping context, which will mirror the constraining cache, will not be
empty in the actual inductive proof of (a stronger version of) Lemma 5.
The solution is to show that no transitivity-breaking assumptions are
ever introduced in the subtyping context during successful constraining,
and that the input subtyping relation can always be derived without
using S-TRANS; we do this by strengthening the induction hypothesis
accordingly.</p>
<h2 id="experimental-evaluation">6 EXPERIMENTAL EVALUATION</h2>
<p>我们通过对类型和子类型推导的归纳法证明引理 3 和引理 5。规则 S-TRANS
造成了一些麻烦：如果子类型推导使用了它，我们得到的前提引用了无法应用归纳法的推导，因为它们不对应于递归约束调用。S-TRANS
可以在空的子类型上下文中从系统中删除，并且仅通过其他规则证明；实际上，<span
class="math inline">\(\Sigma\)</span>
原则上可以包含破坏传递性的假设，例如 <span class="math inline">\((\top
\le \bot) \in \Sigma\)</span>。但是，子类型上下文将在引理
5（更强版本）实际归纳证明中反映约束缓存，因此不会为空。解决方案是证明在成功约束过程中，子类型上下文中从未引入破坏传递性的假设，并且输入子类型关系总是可以在不使用
S-TRANS 的情况下推导出来；我们通过相应地加强归纳假设来做到这一点。</p>
<h2 id="实验评估">6 实验评估</h2>
<p>To evaluate the strengths of both the Simple-sub and MLsub
implementations, we ran them on 1,313,832 randomly-generated expressions
of varying sizes, of which 515,509 turned out to be well-typed and
798,321 turned out to be ill-typed.</p>
<p><em>Subsumption checking.</em> MLsub provides a <em>subsumption
checker</em>, whose goal is to determine if one inferred signature is at
least as general as another (i.e., it tests for <span
class="math inline">\(\le^\forall\)</span>). We used MLsub’s subsumption
checker to verify that both algorithms produced equivalent result,
checking that mutual subsumption held between the two inferred type
expressions.</p>
<p>为了评估 Simple-sub 和 MLsub 实现的优劣，我们在 1,313,832
个随机生成的不同大小的表达式上进行了测试，其中 515,509
个被证明是良类型的，798,321 个被证明是错误类型的。</p>
<p><em>subsumption检查。</em> MLsub 提供了一个 <em>subsumption
checker</em>，其目标是确定一个推断的签名是否至少与另一个一样一般（即，它测试
<span class="math inline">\(\le^\forall\)</span>）。我们使用 MLsub
的归纳检查器来验证两个算法产生的结果是相同的，检查两个推断类型表达式之间的互归纳是否成立。</p>
<p><em>Generated expressions.</em> We considered random expressions
making use of integer literals, lambdas, applications, record creations,
field selections, recursive let bindings, and non-recursive let
bindings. We used at most five different variable names and at most
three different field names per expression. We stochastically generated
well-scoped expressions without shadowing, using a depth-first search
with an exponential decrease in probability of recursing into non-leaf
subexpression. This generated 1,313,832 expressions of sizes ranging
from 1 to 23, the majority (about a million) being in the 10–15 range.
The code used for generating and testing these expressions can be found
online in the <em>mlsub-compare</em> branch of the repository, as well
as in the archived artifact of this paper.</p>
<p><em>生成的表达式。</em>
我们考虑了随机表达式，使用整数字面量、lambda、应用、记录创建、字段选择、递归
let 绑定以及非递归 let
绑定。每个表达式中我们最多使用五个不同的变量名和三个不同的字段名。我们随机生成了无变量遮蔽的良作用域表达式，使用深度优先搜索，并在递归到非叶子子表达式的概率上以指数方式递减。如此生成的表达式总计
1,313,832 个，大小范围从 1 到 23，大多数（约一百万个）在 10–15
范围内。用于生成和测试这些表达式的代码可以在在线的
<em>mlsub-compare</em>
仓库分支中找到，也可以在本文的档案工件中找到。</p>
<p><em>Bugs found in MLsub.</em> We found several bugs in MLsub: a
variable shadowing bug — the expression
<code>let rec x = (let y = x in (fun x -&gt; y)) in x</code> gets
assigned the wrong type <code>a -&gt; a</code> because of the shadowing
of let-bounds variable <code>x</code>;<a href="#fn27"
class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> a
type comparison bug due to a typo (which had already been fixed in
another branch of the project); and a simplification bug, giving (for
instance) to the record expression
<code>&#123;u = 0; v = &#123;w = &#123;w = 0&#125;&#125;&#125;</code> the wrong type
<code>&#123;u : int, v : (rec a = &#123;w : a&#125;)&#125;</code>. Because of the latter
bug, to carry out the tests successfully, we had to disable MLsub’s
simplifier (but the Simple-sub simplifier was still enabled).</p>
<p><em>Summary.</em> We were able to make sure that Simple-sub and MLsub
agreed on type inference for more than a million randomly-generated
expressions. Systematic testing turned out to be a surprisingly useful
tool for detecting small mistakes which would have otherwise gone
unnoticed.</p>
<h1 id="conclusions-and-future-work">7 CONCLUSIONS AND FUTURE WORK</h1>
<p><em>在MLsub中发现的错误。</em>
我们在MLsub中发现了几个错误：一个变量遮蔽错误——表达式
<code>let rec x = (let y = x in (fun x -&gt; y)) in x</code> 由于遮蔽了
let-bound 变量 <code>x</code> 而被赋予了错误的类型
<code>a -&gt; a</code>；<a href="#fn28" class="footnote-ref"
id="fnref28" role="doc-noteref"><sup>28</sup></a> 一个由于 TYPO
引起的类型比较错误（该错误已经在项目的另一个分支中修复）；以及一个简化错误，使得（例如）记录表达式
<code>&#123;u = 0; v = &#123;w = &#123;w = 0&#125;&#125;&#125;</code> 被赋予了错误的类型
<code>&#123;u : int, v : (rec a = &#123;w : a&#125;)&#125;</code>。由于后一个错误，为了成功进行测试，我们不得不禁用
MLsub 的简化器（但 Simple-sub 的简化器仍然启用）。</p>
<p><em>总结。</em> 我们能够确保 Simple-sub 和 MLsub
在超过一百万个随机生成的表达式上的类型推断一致。系统化测试被证明是一个令人惊讶的有效工具，用于检测那些否则会被忽视的小错误。</p>
<h1 id="结论与未来工作">7 结论与未来工作</h1>
<p>Algebraic subtyping and its realization in MLsub demonstrated a very
promising new technique for inferring compact principal types in the
presence of implicit subtyping. In this paper, we presented a simpler
foundational view of MLsub’s type system, which does not require notions
of bisubstitution or polar types, and slightly departs from the focus on
<em>algebra first</em>. This new understanding lead us to more
approachable type inference specification and implementation. We showed
the design of Simple-sub, which achieves principal type inference and
reasonable simplification in just 500 lines of code, to serve as an
inspiration to future type systems and programming languages
designers.</p>
<p>代数子类型及其在MLsub中的实现展示了一种在隐式子类型存在时推导紧凑主类型的新技术，前景非常可观。本文提出了一个更简单的MLsub类型系统的基础视角，该视角不需要双替代或极性类型的概念，并且在一定程度上偏离了<em>代数优先</em>的重点。这一新理解使我们能够制定更易于接近的类型推导规范和实现。我们展示了Simple-sub的设计，它在仅500行代码内实现了主类型推导和合理简化，以此激励未来的类型系统和编程语言设计者。</p>
<p>There is still much to be explored among the possibilities offered by
algebraic subtyping, and by the new Simple-sub algorithm in particular.
Polymorphic variants, a very useful language feature [Garrigue 1998],
are the dual of polymorphic record types. A simple form of polymorphic
variants (i.e., without default match cases and without nested patterns)
can be handled in our system in <em>exactly</em> the same way as we have
shown for records. Both variants and records can also be extended easily
to support row variable for extensibility, yielding a powerful system;
moreover, such a system would still be simple and natural to use thanks
to subtyping, which usefully complements row polymorphism [Pottier 1998,
Chapter 14.7]. Finally, we have been prototyping extensions for more
advanced features which also benefit from subtyping, such as first-class
polymorphism.</p>
<h1 id="acknowledgments">8 ACKNOWLEDGMENTS</h1>
<p>I would like to thank Stephen Dolan and Alan Mycroft for their
responsiveness and help in testing MLsub, and for their feedback on the
paper; Paolo G. Giarrusso for his insightful suggestions; the paper’s
shepherd Tom Schrijvers; and the anonymous reviewers for their useful
comments.</p>
<h1 id="references">REFERENCES</h1>
<p>仍有许多可能性等待我们去探索，特别是代数子类型和新的 Simple-sub
算法。多态变体，这是一个非常有用的语言特性 [Garrigue
1998]，是多态记录类型的对偶。我们系统中可以以 <em>完全</em>
相同的方式处理多态变体的简单形式（即，没有默认匹配案例和嵌套模式），就像我们展示的记录一样。变体和记录也可以很容易地扩展以支持行变量，从而实现可扩展性，产生一个强大的系统；此外，得益于子类型，这样的系统仍然会简单自然，且实用地补充了行多态性
[Pottier 1998, Chapter
14.7]。最后，我们一直在为更高级特性原型开发扩展，这些特性也受益于子类型，例如一等公民多态性。</p>
<h1 id="致谢">8 致谢</h1>
<p>我想感谢 Stephen Dolan 和 Alan Mycroft 对 MLsub
测试的响应和帮助，以及他们对论文的反馈；感谢 Paolo G. Giarrusso
的深刻建议；感谢论文的指导 Tom
Schrijvers；感谢匿名评审对其有用评论的贡献。</p>
<h1 id="参考文献">参考文献</h1>
<p>Roberto M. Amadio and Luca Cardelli. 1993. Subtyping Recursive Types.
<em>ACM Trans. Program. Lang. Syst.</em> 15, 4 (Sept. 1993), 575–631.
https://doi.org/10.1145/155183.155231</p>
<p>Nada Amin, Samuel Grütter, Martin Odersky, Tiark Rompf, and Sandro
Stucki. 2016. <em>The Essence of Dependent Object Types</em>. Springer
International Publishing, Cham, 249–272.
https://doi.org/10.1007/978-3-319-30936-1_14</p>
<p>Andrew W. Appel, Paul-André Melliès, Christopher D. Richards, and
Jérôme Vouillon. 2007. A Very Modal Model of a Modern, Major, General
Type System. In <em>Proceedings of the 34th Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages</em> (Nice, France)
(POPL ’07). Association for Computing Machinery, New York, NY, USA,
109–122. https://doi.org/10.1145/1190216.1190235</p>
<p>Roberto M. Amadio 和 Luca Cardelli. 1993. 子类型递归类型. <em>ACM
Trans. Program. Lang. Syst.</em> 15, 4 (1993年9月), 575–631.
https://doi.org/10.1145/155183.155231</p>
<p>Nada Amin, Samuel Grütter, Martin Odersky, Tiark Rompf, 和 Sandro
Stucki. 2016. <em>依赖对象类型的本质</em>. Springer International
Publishing, Cham, 249–272.
https://doi.org/10.1007/978-3-319-30936-1_14</p>
<p>Andrew W. Appel, Paul-André Melliès, Christopher D. Richards, 和
Jérôme Vouillon. 2007. 现代主要通用类型系统的非常模态模型. 在
<em>第三十四届年度 ACM SIGPLAN-SIGACT 编程语言原理研讨会会议录</em>
(法国尼斯) (POPL ’07). 计算机协会, 纽约, NY, 美国, 109–122.
https://doi.org/10.1145/1190216.1190235</p>
<p>Giuseppe Castagna, Tommaso Petrucciani, and Kim Nguyen. 2016.
Set-theoretic types for polymorphic variants. In <em>Proceedings of the
21st ACM SIGPLAN International Conference on Functional Programming
(ICFP 2016)</em>. Association for Computing Machinery, Nara, Japan,
378–391. https://doi.org/10.1145/2951913.2951928</p>
<p>Giuseppe Castagna and Zhiwu Xu. 2011. Set-Theoretic Foundation of
Parametric Polymorphism and Subtyping. (2011), 94–106.
https://doi.org/10.1145/2034773.2034788</p>
<p>Nathanaël Courant. 2018. Safely typing algebraic effects (Gagallium
Blog). http://gallium.inria.fr/blog/safely-typing-algebraic-effects/.
Accessed: 2020-06-30.</p>
<p>Luis Damas and Robin Milner. 1982. Principal type-schemes for
functional programs. In <em>Proceedings of the 9th ACM SIGPLAN-SIGACT
symposium on Principles of programming languages (POPL ’82)</em>.
Association for Computing Machinery, Albuquerque, New Mexico, 207–212.
https://doi.org/10.1145/582153.582176</p>
<p>Stephen Dolan. 2017. <em>Algebraic subtyping</em>. Ph.D.
Dissertation.</p>
<p>Stephen Dolan and Alan Mycroft. 2017. Polymorphism, subtyping, and
type inference in MLsub. <em>ACM SIGPLAN Notices</em> 52, 1 (Jan. 2017),
60–72. https://doi.org/10.1145/3093333.3099882</p>
<p>Giuseppe Castagna, Tommaso Petrucciani, 和 Kim Nguyen. 2016.
多态变体的集合论类型. 收录于 <em>第21届ACM SIGPLAN国际函数编程会议（ICFP
2016）论文集</em>. 计算机协会, 日本奈良, 378–391.
https://doi.org/10.1145/2951913.2951928</p>
<p>Giuseppe Castagna 和 Zhiwu Xu. 2011. 参数多态性和子类型的集合论基础.
(2011), 94–106. https://doi.org/10.1145/2034773.2034788</p>
<p>Nathanaël Courant. 2018. 安全类型化代数效应 (Gagallium Blog).
http://gallium.inria.fr/blog/safely-typing-algebraic-effects/. 访问时间:
2020-06-30.</p>
<p>Luis Damas 和 Robin Milner. 1982. 函数程序的主要类型方案. 收录于
<em>第9届ACM SIGPLAN-SIGACT编程语言原理研讨会论文集（POPL ’82）</em>.
计算机协会, 新墨西哥州阿尔伯克基, 207–212.
https://doi.org/10.1145/582153.582176</p>
<p>Stephen Dolan. 2017. <em>代数子类型</em>. 博士论文.</p>
<p>Stephen Dolan 和 Alan Mycroft. 2017.
MLsub中的多态性、子类型和类型推断. <em>ACM SIGPLAN通知</em> 52, 1
(2017年1月), 60–72. https://doi.org/10.1145/3093333.3099882</p>
<p>Joshua Dunfield and Neelakantan R. Krishnaswami. 2013. Complete and
Easy Bidirectional Typechecking for Higher-Rank Polymorphism.
<em>SIGPLAN Not.</em> 48, 9 (Sept. 2013), 429–442.
https://doi.org/10.1145/2544174.2500582</p>
<p>Tim Freeman and Frank Pfenning. 1991. Refinement types for ML. In
<em>Proceedings of the ACM SIGPLAN 1991 conference on Programming
language design and implementation</em>. 268–277.</p>
<p>Alain Frisch, Giuseppe Castagna, and Véronique Benzaken. 2008.
Semantic Subtyping: Dealing Set-Theoretically with Function, Union,
Intersection, and Negation Types. <em>J. ACM</em> 55, 4, Article 19
(Sept. 2008), 64 pages. https://doi.org/10.1145/1391289.1391293</p>
<p>Jacques Garrigue. 1998. Programming with polymorphic variants. In
<em>ML Workshop</em>, Vol. 13. Baltimore, 7.</p>
<p>Roger Hindley. 1969. The Principal Type-Scheme of an Object in
Combinatory Logic. <em>Trans. Amer. Math. Soc.</em> 146 (1969), 29–60.
https://doi.org/10.2307/1995158 Publisher: American Mathematical
Society.</p>
<p>Haruo Hosoya, Jérôme Vouillon, and Benjamin C. Pierce. 2005. Regular
Expression Types for XML. <em>ACM Trans. Program. Lang. Syst.</em> 27, 1
(Jan. 2005), 46–90. https://doi.org/10.1145/1053468.1053470</p>
<p>Joshua Dunfield 和 Neelakantan R. Krishnaswami. 2013.
完整且简单的双向类型检查用于更高阶多态性. <em>SIGPLAN Not.</em> 48, 9
(2013年9月), 429–442. https://doi.org/10.1145/2544174.2500582</p>
<p>Tim Freeman 和 Frank Pfenning. 1991. ML 的细化类型. 载于 <em>ACM
SIGPLAN 1991 编程语言设计与实现会议纪要</em>. 268–277.</p>
<p>Alain Frisch, Giuseppe Castagna 和 Véronique Benzaken. 2008.
语义子类型: 用集合理论处理函数、并集、交集和否定类型. <em>J. ACM</em>
55, 4, Article 19 (2008年9月), 64页.
https://doi.org/10.1145/1391289.1391293</p>
<p>Jacques Garrigue. 1998. 使用多态变体编程. 载于 <em>ML Workshop</em>,
第13卷. 巴尔的摩, 7.</p>
<p>Roger Hindley. 1969. 组合逻辑中对象的主类型方案. <em>Trans. Amer.
Math. Soc.</em> 146 (1969), 29–60. https://doi.org/10.2307/1995158
出版社: 美国数学学会.</p>
<p>Haruo Hosoya, Jérôme Vouillon 和 Benjamin C. Pierce. 2005. XML
的正则表达式类型. <em>ACM Trans. Program. Lang. Syst.</em> 27, 1
(2005年1月), 46–90. https://doi.org/10.1145/1053468.1053470</p>
<p>DeLesley S. Hutchins. 2010. Pure Subtype Systems. In <em>Proceedings
of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages</em> (Madrid, Spain) (POPL ’10). Association for
Computing Machinery, New York, NY, USA, 287–298.
https://doi.org/10.1145/1706299.1706334</p>
<p>Oleg Kiselyov. 2013. Efficient generalization with levels (Okmij
Blog). http://okmij.org/ftp/ML/generalization.html#levels. Accessed:
2020-06-30.</p>
<p>Robin Milner. 1978. A theory of type polymorphism in programming.
<em>J. Comput. System Sci.</em> 17, 3 (Dec. 1978), 348–375.
https://doi.org/10.1016/0022-0000(78)90014-4</p>
<p>Martin Odersky and Konstantin Läufer. 1996. Putting Type Annotations
to Work. In <em>Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages</em> (St. Petersburg Beach, Florida,
USA) (POPL ’96). Association for Computing Machinery, New York, NY, USA,
54–67. https://doi.org/10.1145/237721.237729</p>
<p>DeLesley S. Hutchins. 2010. 纯子类型系统。载于 <em>第37届年度 ACM
SIGPLAN-SIGACT 编程语言原则研讨会论文集</em> （西班牙马德里）(POPL
’10)。计算机协会，纽约，纽约，美国，287–298。
https://doi.org/10.1145/1706299.1706334</p>
<p>Oleg Kiselyov. 2013. 带级别的高效泛化 (Okmij 博客).
http://okmij.org/ftp/ML/generalization.html#levels.
访问时间：2020-06-30。</p>
<p>Robin Milner. 1978. 编程中类型多态性的理论。
<em>计算机与系统科学杂志</em> 17, 3 (1978年12月)，348–375。
https://doi.org/10.1016/0022-0000(78)90014-4</p>
<p>Martin Odersky 和 Konstantin Läufer. 1996. 将类型注解付诸实践。载于
<em>第23届 ACM SIGPLAN-SIGACT 编程语言原则研讨会论文集</em>
（美国佛罗里达州圣彼得堡海滩）(POPL
’96)。计算机协会，纽约，纽约，美国，54–67。
https://doi.org/10.1145/237721.237729</p>
<p>David J. Pearce. 2013. Sound and Complete Flow Typing with Unions,
Intersections and Negations. In <em>Verification, Model Checking, and
Abstract Interpretation (Lecture Notes in Computer Science)</em>,
Roberto Giacobazzi, Josh Berdine, and Isabella Mastroeni (Eds.).
Springer, Berlin, Heidelberg, 335–354.
https://doi.org/10.1007/978-3-642-35873-9_21</p>
<p>Benjamin C. Pierce. 2002. <em>Types and programming languages</em>.
MIT press.</p>
<p>François Pottier. 1998. <em>Type Inference in the Presence of
Subtyping: from Theory to Practice</em>. Research Report RR-3483. INRIA.
https://hal.inria.fr/inria-00073205</p>
<p>Patrick M. Rondon, Ming Kawaguci, and Ranjit Jhala. 2008. Liquid
Types. In <em>Proceedings of the 29th ACM SIGPLAN Conference on
Programming Language Design and Implementation</em> (Tucson, AZ, USA)
(PLDI ’08). Association for Computing Machinery, New York, NY, USA,
159–169. https://doi.org/10.1145/1375581.1375602</p>
<p>David J. Pearce. 2013. 带有联合、交集和否定的声音和完整流类型。载于
<em>Verification, Model Checking, and Abstract Interpretation (Lecture
Notes in Computer Science)</em>, Roberto Giacobazzi, Josh Berdine 和
Isabella Mastroeni (编). Springer, Berlin, Heidelberg, 335–354.
https://doi.org/10.1007/978-3-642-35873-9_21</p>
<p>Benjamin C. Pierce. 2002. <em>类型与编程语言</em>. MIT press.</p>
<p>François Pottier. 1998.
<em>存在子类型时的类型推断：从理论到实践</em>. 研究报告 RR-3483. INRIA.
https://hal.inria.fr/inria-00073205</p>
<p>Patrick M. Rondon, Ming Kawaguci 和 Ranjit Jhala. 2008. Liquid Types.
载于 <em>Proceedings of the 29th ACM SIGPLAN Conference on Programming
Language Design and Implementation</em> (Tucson, AZ, USA) (PLDI ’08).
Association for Computing Machinery, New York, NY, USA, 159–169.
https://doi.org/10.1145/1375581.1375602</p>
<p>Andreas Rossberg. 2015. 1ML – Core and Modules United (F-Ing
First-Class Modules). In <em>Proceedings of the 20th ACM SIGPLAN
International Conference on Functional Programming</em> (Vancouver, BC,
Canada) (ICFP 2015). Association for Computing Machinery, New York, NY,
USA, 35–47. https://doi.org/10.1145/2784731.2784738</p>
<p>John Rushby, Sam Owre, and Natarajan Shankar. 1998. Subtypes for
Specifications: Predicate Subtyping in PVS. <em>IEEE Trans. Softw.
Eng.</em> 24, 9 (Sept. 1998), 709–720.
https://doi.org/10.1109/32.713327</p>
<p>Sam Tobin-Hochstadt and Matthias Felleisen. 2010. Logical Types for
Untyped Languages. <em>SIGPLAN Not.</em> 45, 9 (Sept. 2010), 117–128.
https://doi.org/10.1145/1932681.1863561</p>
<p>Niki Vazou, Eric L. Seidel, Ranjit Jhala, Dimitrios Vytiniotis, and
Simon Peyton-Jones. 2014. Refinement Types for Haskell. In
<em>Proceedings of the 19th ACM SIGPLAN International Conference on
Functional Programming</em> (Gothenburg, Sweden) (ICFP '14). Association
for Computing Machinery, New York, NY, USA, 269–282.
https://doi.org/10.1145/2628136.2628161</p>
<p>Andreas Rossberg. 2015. 1ML – Core and Modules United (F-Ing
First-Class Modules). 在 <em>Proceedings of the 20th ACM SIGPLAN
International Conference on Functional Programming</em> (Vancouver, BC,
Canada) (ICFP 2015). 计算机协会，纽约，NY，USA, 35–47.
https://doi.org/10.1145/2784731.2784738</p>
<p>John Rushby, Sam Owre, 和 Natarajan Shankar. 1998. Subtypes for
Specifications: Predicate Subtyping in PVS. <em>IEEE Trans. Softw.
Eng.</em> 24, 9 (1998年9月), 709–720.
https://doi.org/10.1109/32.713327</p>
<p>Sam Tobin-Hochstadt 和 Matthias Felleisen. 2010. Logical Types for
Untyped Languages. <em>SIGPLAN Not.</em> 45, 9 (2010年9月), 117–128.
https://doi.org/10.1145/1932681.1863561</p>
<p>Niki Vazou, Eric L. Seidel, Ranjit Jhala, Dimitrios Vytiniotis, 和
Simon Peyton-Jones. 2014. Refinement Types for Haskell. 在
<em>Proceedings of the 19th ACM SIGPLAN International Conference on
Functional Programming</em> (Gothenburg, Sweden) (ICFP '14).
计算机协会，纽约，NY，USA, 269–282.
https://doi.org/10.1145/2628136.2628161</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>OCaml 在这些打破原则的特性上一直相对保守，显著的例外是
GADTs 和多重记录字段，但 Haskell
在这方面的采用更为宽松，以增强表达能力。<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>OCaml 在这些打破原则的特性上一直相对保守，显著的例外是
GADTs 和多重记录字段，但 Haskell
在这方面的采用更为宽松，以增强表达能力。<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>例如，OCaml
使用行类型使对象类型和多态变体更灵活，避免了显式强制转换的需求，这在某种程度上类似于隐式子类型
[Pottier 1998]；而 Haskell 可以使用类型类来模拟子类型，如 <em>lens</em>
和 <em>optics</em> 库所示，这两个库都是围绕子类型类比设计的。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>例如，OCaml
使用行类型使对象类型和多态变体更灵活，避免了显式强制转换的需求，这在某种程度上类似于隐式子类型
[Pottier 1998]；而 Haskell 可以使用类型类来模拟子类型，如 <em>lens</em>
和 <em>optics</em> 库所示，这两个库都是围绕子类型类比设计的。<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>从操作的角度来看，Simple-sub 与 MLsub
的图形实现有许多相似之处，尽管这两种算法仍然相当不同——尤其是，MLsub
在其约束图中将正节点与负节点分开（而 Simple-sub 没有这种分离），并且
MLsub 生成的类型变量比 Simple-sub 多得多。<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>从操作的角度来看，Simple-sub 与 MLsub
的图形实现有许多相似之处，尽管这两种算法仍然相当不同——尤其是，MLsub
在其约束图中将正节点与负节点分开（而 Simple-sub 没有这种分离），并且
MLsub 生成的类型变量比 Simple-sub 多得多。<a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn7"><p>我们对于代数子类型的可扩展性属性是否如其作者所宣传的那样有用，除了它的简化结果之外，存在一些疑问。首先，实际的编程语言设计上已经具有可扩展的类型系统，因为它们允许用户定义数据类型，而来自封闭世界形式演算的子类型悖论通常不会在这些环境中出现或造成问题。其次，扩展编程语言的核心类型语义的情况极为罕见，因此在设计类型系统时，这种情况可能并不值得优化。<a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn8"><p>我们对于代数子类型的可扩展性属性是否如其作者所宣传的那样有用，除了它的简化结果之外，存在一些疑问。首先，实际的编程语言设计上已经具有可扩展的类型系统，因为它们允许用户定义数据类型，而来自封闭世界形式演算的子类型悖论通常不会在这些环境中出现或造成问题。其次，扩展编程语言的核心类型语义的情况极为罕见，因此在设计类型系统时，这种情况可能并不值得优化。<a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>有趣的是，OCaml
编译器支持递归类型，但默认情况下只允许它们作为对象类型的一部分，因为它们可能导致意外情况——在某些情况下推断出递归类型，而不是报告明显的错误。在基于
MLsub 的实际语言中，可以对递归类型的推断施加类似的限制。<a
href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>有趣的是，OCaml
编译器支持递归类型，但默认情况下只允许它们作为对象类型的一部分，因为它们可能导致意外情况——在某些情况下推断出递归类型，而不是报告明显的错误。在基于
MLsub 的实际语言中，可以对递归类型的推断施加类似的限制。<a
href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>⁶从这个意义上说，<code>int</code> <span
class="math inline">\(\sqcup\)</span> <code>string</code> 类似于 <span
class="math inline">\(\tau\)</span>，尽管 MLsub
不认为这两种类型是等价的。<a href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn12"><p>⁷请注意，Java的几个特性远远超出了MLsub所能表达的范畴（例如，多态方法和泛型类层次结构），因此MLsub确实是比我们假设的结构化类型Java<em>严格少</em>的表达能力。<a
href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>⁶从这个意义上说，<code>int</code> <span
class="math inline">\(\sqcup\)</span> <code>string</code> 类似于 <span
class="math inline">\(\tau\)</span>，尽管 MLsub
不认为这两种类型是等价的。<a href="#fnref13" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn14"><p>⁷请注意，Java的几个特性远远超出了MLsub所能表达的范畴（例如，多态方法和泛型类层次结构），因此MLsub确实是比我们假设的结构化类型Java<em>严格少</em>的表达能力。<a
href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>⁸实际上，在真实的Java中，下界规范 inexplicably
仅支持<em>通配符</em>类型参数——这显然是一个疏漏。有关Java中类型边界的更多详细信息，请参见
https://docs.oracle.comjavase/tutorial/java/generics/bounded.html 和
https://docs.oracle.comjavase/tutorial/java/generics/lowerBounded.html。<a
href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>⁸实际上，在真实的Java中，下界规范 inexplicably
仅支持<em>通配符</em>类型参数——这显然是一个疏漏。有关Java中类型边界的更多详细信息，请参见
https://docs.oracle.comjavase/tutorial/java/generics/bounded.html 和
https://docs.oracle.comjavase/tutorial/java/generics/lowerBounded.html。<a
href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>⁹正如 Dolan 和 Mycroft [2017]
所解释的，这种类型与更自然的 <span class="math inline">\(\forall \alpha,
\beta\)</span> 一样一般。 <span class="math inline">\(bool \to \alpha
\to \beta \to \alpha \sqcup \beta\)</span>。<a href="#fnref17"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>⁹正如 Dolan 和 Mycroft [2017]
所解释的，这种类型与更自然的 <span class="math inline">\(\forall \alpha,
\beta\)</span> 一样一般。 <span class="math inline">\(bool \to \alpha
\to \beta \to \alpha \sqcup \beta\)</span>。<a href="#fnref18"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>¹¹Scala 语法 (<code>foo(a,_,c)</code>) 是对 lambda 抽象
(<code>x =&gt; foo(a, x, c)</code>) 的一种简写。<a href="#fnref19"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p>¹¹Scala 语法 (<code>foo(a,_,c)</code>) 是对 lambda 抽象
(<code>x =&gt; foo(a, x, c)</code>) 的一种简写。<a href="#fnref20"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21"><p>¹²在 Scala 中，<code>opt.fold(t)(f)</code>
通过对包含的值应用函数 <code>f</code> 来折叠 <code>opt</code>
选项，如果选项为空，则评估默认的 <code>thunk t</code>。
<code>MutMap</code> 的 <code>map.getOrElseUpdate(k, t)</code> 方法在
<code>map</code> 中查找一个键 <code>k</code>；如果未找到该键，则评估
<code>thunk t</code> 并用该值更新
<code>map</code>；否则，返回与该键关联的值。<a href="#fnref21"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22"><p>¹³在Scala中，<em>sealed trait</em>
类似于只能由同一文件中定义的类型实现的 <em>interface</em>。<a
href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23"><p>¹³在Scala中，<em>sealed trait</em>
类似于只能由同一文件中定义的类型实现的 <em>interface</em>。<a
href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn24"><p>¹⁴一些方法在面对这种更高级的推理形式时实现了完整的类型推断
[Castagna et al.
2016]，但它们通常缺乏主类型属性（它们生成一组可能的类型而不是单个最通用的类型），而且它们自然不支持相同程度的简化。<a
href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn25"><p>¹⁵我们对let多态性的实现可以单独证明是正确的，方法是显示它在每个使用地点的效果与复制let绑定定义相同（这就是let多态性的语义[Damas和Milner
1982]）。<a href="#fnref25" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn26"><p>¹⁵我们对let多态性的实现可以单独证明是正确的，方法是显示它在每个使用地点的效果与复制let绑定定义相同（这就是let多态性的语义[Damas和Milner
1982]）。<a href="#fnref26" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn27"><p>¹⁶我们发现这一点是因为，在早期的测试尝试中，我们生成了包含遮蔽的表达式。<a
href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn28"><p>¹⁶我们发现这一点是因为，在早期的测试尝试中，我们生成了包含遮蔽的表达式。<a
href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjk.moe/2025/%E4%BB%A3%E6%95%B0%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%88%E5%8F%8C%E8%AF%AD%E4%BA%A4%E6%9B%BF%E7%89%88%E6%9C%AC%EF%BC%89/" data-id="cmiyj78f7007mu4ueatetf539" data-title="代数子类型的精髓（双语交替版本）" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Decompile/" rel="tag">Decompile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PL/" rel="tag">PL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/StaticAnalysis/" rel="tag">StaticAnalysis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E5%92%8C%E5%9B%A0%E6%9E%9C%E6%80%A7/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">分析数据的相关性和因果性</div>
    </a>
  
</nav>

  
</article>

<!-- 2024年1月11日 giscus -->

  <section id="comments" class="vcomment">
    <script src="https://giscus.app/client.js"
      data-repo="am009/am009.github.io"
      data-repo-id="MDEwOlJlcG9zaXRvcnkxOTI3MTU2MzI="
      data-category="Comments"
      data-category-id="DIC_kwDOC3ybcM4CcWIQ"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="light"
      data-lang="zh-CN"
      data-loading="lazy"
      crossorigin="anonymous"
      async>
    </script>
  </section>



</section>
        
      </div>
      <footer id="footer">
  
    <aside id="sidebar" class="outer">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Digi/">Digi</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hack/">Hack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Project/">Project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Read/">Read</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Compiler/" rel="tag">Compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Decompile/" rel="tag">Decompile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/" rel="tag">English</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzz/" rel="tag">Fuzz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Investing/" rel="tag">Investing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM/" rel="tag">LLVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Learning/" rel="tag">Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Networking/" rel="tag">Networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Openwrt/" rel="tag">Openwrt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PL/" rel="tag">PL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/" rel="tag">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Read/" rel="tag">Read</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scientific/" rel="tag">Scientific</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/StaticAnalysis/" rel="tag">StaticAnalysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebAssembly/" rel="tag">WebAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rcore/" rel="tag">rcore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 11.25px;">AI</a> <a href="/tags/CTF/" style="font-size: 18.75px;">CTF</a> <a href="/tags/Compiler/" style="font-size: 16.25px;">Compiler</a> <a href="/tags/Decompile/" style="font-size: 20px;">Decompile</a> <a href="/tags/Embedded/" style="font-size: 12.5px;">Embedded</a> <a href="/tags/English/" style="font-size: 10px;">English</a> <a href="/tags/Fuzz/" style="font-size: 17.5px;">Fuzz</a> <a href="/tags/Investing/" style="font-size: 11.25px;">Investing</a> <a href="/tags/Java/" style="font-size: 11.25px;">Java</a> <a href="/tags/LLVM/" style="font-size: 11.25px;">LLVM</a> <a href="/tags/Learning/" style="font-size: 13.75px;">Learning</a> <a href="/tags/Linux/" style="font-size: 11.25px;">Linux</a> <a href="/tags/Networking/" style="font-size: 15px;">Networking</a> <a href="/tags/OS/" style="font-size: 12.5px;">OS</a> <a href="/tags/Openwrt/" style="font-size: 10px;">Openwrt</a> <a href="/tags/PL/" style="font-size: 20px;">PL</a> <a href="/tags/Raspberrypi/" style="font-size: 10px;">Raspberrypi</a> <a href="/tags/Read/" style="font-size: 12.5px;">Read</a> <a href="/tags/Scientific/" style="font-size: 12.5px;">Scientific</a> <a href="/tags/StaticAnalysis/" style="font-size: 20px;">StaticAnalysis</a> <a href="/tags/WebAssembly/" style="font-size: 10px;">WebAssembly</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/rcore/" style="font-size: 10px;">rcore</a> <a href="/tags/ucore/" style="font-size: 10px;">ucore</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">November 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
</aside>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 am009@github.com<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>