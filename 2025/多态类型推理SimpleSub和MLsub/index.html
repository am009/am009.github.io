<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>多态类型推理SimpleSub和MLsub | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="多态类型推理SimpleSub和MLsub">
<meta property="og:type" content="article">
<meta property="og:title" content="多态类型推理SimpleSub和MLsub">
<meta property="og:url" content="https://wjk.moe/2025/%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%8E%A8%E7%90%86SimpleSub%E5%92%8CMLsub/">
<meta property="og:site_name">
<meta property="og:description" content="多态类型推理SimpleSub和MLsub">
<meta property="og:locale">
<meta property="og:image" content="https://wjk.moe/2025/%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%8E%A8%E7%90%86SimpleSub%E5%92%8CMLsub/ML%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A4%BA%E4%BE%8B.drawio.png">
<meta property="article:published_time" content="2025-11-20T03:11:12.000Z">
<meta property="article:modified_time" content="2026-01-08T09:06:09.081Z">
<meta property="article:author" content="am009@github.com">
<meta property="article:tag" content="PL">
<meta property="article:tag" content="StaticAnalysis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wjk.moe/2025/%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%8E%A8%E7%90%86SimpleSub%E5%92%8CMLsub/ML%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A4%BA%E4%BE%8B.drawio.png">
  
    <link rel="alternate" href="/rss.xml" title="" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          
            <a class="nav-icon" target="_blank" rel="noopener" href="https://github.com/am009"><span class="fa fa-github"></span></a>
          
        
        
          <a class="nav-icon" href="/rss.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wjk.moe"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2025/多态类型推理SimpleSub和MLsub" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%8E%A8%E7%90%86SimpleSub%E5%92%8CMLsub/" class="article-date">
  <time class="dt-published" datetime="2025-11-20T03:11:12.000Z" itemprop="datePublished">2025-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Read/">Read</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      多态类型推理SimpleSub和MLsub
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>多态类型推理SimpleSub和MLsub</p>
<span id="more"></span>
<h2 id="简介">简介</h2>
<p>SimpleSub 和
MLsub是编程语言理论（PL）中的类型推理方向的，一系列支持多态子类型推理的算法框架。子类型（可以想象为继承和接口之类的）其实在现实编程中用得特别多，而多态类型（可以想象一下C++的模板）其实用的也多。这个算法可以让编译型语言也不用写很多类型标注，同时它在程序分析领域也可能有着很广泛的应用。</p>
<h2 id="资源总结">资源总结</h2>
<p>按时间线：</p>
<ul>
<li>2016 Dolan的PhD paper，提出了被称为<a
target="_blank" rel="noopener" href="https://www.cs.tufts.edu/~nr/cs257/archive/stephen-dolan/thesis.pdf">MLsub</a>的系统，是最原始的资源。但是偏理论。到中间才介绍自动机和图等算法，最后的算法不涉及前几章的理论。（我反复看了，略懂一些，有问题可以发邮件问我）<a
target="_blank" rel="noopener" href="https://github.com/stedolan/mlsub">代码</a>是OCaml写的。</li>
<li>2020 SimplSub <a
target="_blank" rel="noopener" href="https://infoscience.epfl.ch/entities/publication/106da598-3385-4029-892b-27ea85194046">论文</a>和<a
target="_blank" rel="noopener" href="https://github.com/LPTK/simple-sub">代码</a>和<a
target="_blank" rel="noopener" href="https://lptk.github.io/programming/2020/03/26/demystifying-mlsub.html">博客</a></li>
<li>CubiML系列<a
target="_blank" rel="noopener" href="https://blog.polybdenum.com/2020/07/04/subtype-inference-by-example-part-1-introducing-cubiml.html">博客</a>，以及系列代码<a
target="_blank" rel="noopener" href="https://github.com/Storyyeller/cubiml-demo">CubiML</a> -&gt; <a
target="_blank" rel="noopener" href="https://github.com/Storyyeller/IntercalScript">IntercalScript</a>
-&gt; <a
target="_blank" rel="noopener" href="https://github.com/Storyyeller/polysubml-demo">polysubML</a>。</li>
</ul>
<p>入门优先看几篇博客，然后考虑看SimpleSub论文，这个论文作者专门希望没什么基础的人也能看懂，对着代码讲。然后可以考虑看看相关代码。MLsub原代码和论文比较难懂，优先级最低。</p>
<h2 id="introduction">Introduction</h2>
<p>简单来说： -
<strong>子类型</strong>：子类型的本质是，如果某个类型在任何情况下都能替代另外一个类型被使用，我们称这种情况下为子类型。这种替换关系很直接，也很核心。
-
<strong>多态</strong>：一段程序可以接受不同类型的变量，使得它在不同上下文中有着不同的类型。可以想象一下C++的模版。但是python通过动态检查对象的类型不属于这种情况。</p>
<p>应用的角度： -
<strong>新的编程语言</strong>：想象一下，比如C++语言，所有的引用和指针不需要声明类型，只需要写auto即可。现在的auto只支持明确有类型的地方，而且只根据定义的初始化的时候确定类型。而这个算法可以根据变量的使用去综合确定类型，比如直接写不带初始化的auto变量。总之，它可以让你使用更多的auto。如果类型出问题了，编译器会告诉你的。不过分配堆、栈上的结构体对象的时候还是得完整声明具体的类型。
- <strong>更深入的静态分析</strong>： -
<strong>基于类型的安全检查</strong>：比如Rust语言的生命周期就是一种可以在类型中表示的特性，而编译器需要推理出没有标注的地方的生命周期，使得程序不会出错。这个算法可以应用于这种情况，让语言编写者写出更多的基于类型的安全检查。
-
<strong>加速动态语言</strong>：比如pypy这种转译python的方式，通过深入的类型分析，说不定可以让更多的python程序直接被编译出来，极大增加速度。</p>
<p>从PL的角度来说， -
SimpleSub与MLsub<strong>不需要很深入的基础知识</strong>：现在的类型推理算法其实并没有进步很多，入门PL与类型系统的经典书籍《Types
and Programming Languages》
TaPL中就介绍了ML语言的基于unification的类型推理。 -
<strong>系统更加简单高效</strong>：后续很长一段时间的类型推理系统，它基于单独维护一个约束集合，和约束求解器那边有一些关联，效率低且复杂。这次的算法高效且简洁。</p>
<h2 id="mlsub">MLsub</h2>
<p>传统的 Hindley-Milner
类型推断是基于Unification算法的过程，该过程通过不断地强迫两个未知类型相等，直到达到矛盾或所有程序约束满足为止。在MLsub中，Dolan
提出了一个叫做biunification的过程。biunification的一个关键部分是极性类型系统。极性意味着类型被分为两种类型，传统上称为正类型（+）和负类型（-）。<a
target="_blank" rel="noopener" href="https://blog.polybdenum.com/2020/07/11/subtype-inference-by-example-part-2-parsing-and-biunification.html">这个</a>里面说的很好，为了使理解更加容易，我称之为值类型（+）和用法类型（-）。为了避免导致半统一不可判定的无限循环，biunification将所有子类型约束限制为
v &lt;= u 的形式，其中 v 是值类型，u
是用法类型。这些约束可以自然地解释为要求程序值与其使用方式相兼容。</p>
<p><strong>类型变量</strong>：基本原则是，为每个表达式创建一个值类型（+，也称为正极性），为每个表达式操作数创建一个用法类型（-，也称为负极性），并在每个值类型（+）与其使用上下文（-）之间建立子类型约束，以确保一致性。我们将这些约束
v+ &lt;= u- 称为值流向其使用，它们是通过 TypeCheckerCore 中的 flow
方法创建的。</p>
<p>还有一个更复杂的方面——变量。变量由一对类型表示——值类型（+）和用法类型（-）。从概念上讲，值类型表示从变量读取的类型（），而用法类型表示分配给该变量的类型。自然，我们需要约束
v- &lt;=
v+，即对变量的每一次写入与对该变量的每一次读取都是兼容的。然而，这种类型的约束我们使用数据流边直接表示。它确保流关系的传递性。对于每个变量
(v1, u1)，以及每个流向 u1 的值类型 v2 和 v1 流向的每个用法类型
u2，我们添加约束 v2 流向
u2。本质上，变量（一对连接了数据流边的类型节点）在类型图中像小隧道或虫洞一样运作。无论从一端进入的是什么，都会从数据流另一端出来。直接把下界/上界类型约束沿着数据流边传递。</p>
<p><strong>位置约束</strong>
类型构成一种格（Lattice），我们有两种类型运算</p>
<ul>
<li>并类型（ <span class="math inline">\(\sqcup\)</span>
（Join），求两个类型的最小上界 least upper bound）</li>
<li>交类型 （ <span class="math inline">\(\sqcap\)</span>
（Meet），求两个类型的最大下界 greatest lower bound）</li>
</ul>
<p>我们要求交类型运算 <span class="math inline">\(\sqcap\)</span>
只出现在负极性处，并类型运算 <span class="math inline">\(\sqcup\)</span>
只出现在正极性处。</p>
<p>例如，下面的类型是不合法的：（例子取自MLsub论文的 5.2.3 节）</p>
<p><span class="math display">\[
\{\text{awake} : \text{bool}\} \sqcap α \rightarrow \{\text{awake} :
\text{bool}\} \sqcap α
\]</span></p>
<p>因为在返回值（正极性）的地方出现了交类型运算 <span
class="math inline">\(\sqcap\)</span> ，但是我们有</p>
<p><span class="math display">\[
\{\text{awake} : \text{bool}\} \sqcap α \rightarrow α \;\;\; \leq \;\;\;
\{\text{awake} : \text{bool}\} \sqcap α \rightarrow \{\text{awake} :
\text{bool}\} \sqcap α
\]</span></p>
<p>因此就直接会采取左边的表示方式。</p>
<h3 id="simplesub的三种简化方式">SimpleSub的三种简化方式</h3>
<p><strong>概述</strong>：其实结合SimpleSub代码，真正实现出来的简化操作按顺序总结如下：</p>
<ol type="1">
<li>CompactType
平坦化操作，将类型的上下界展开。这个阶段会把类型展开为特殊的表示，用新的数据结构CompactType存储。</li>
<li>Canonicalize 规范化，这个主要针对递归类型。</li>
<li>Co-occurrence 共现分析，这里涵盖了论文里的 去除极性变量
合并共现变量，以及和常量的共现，三种分析。</li>
<li>hash-consing
负责折叠完全相同的递归结构。这个阶段会和转换为用于打印的语法树类型结合，即将CompactType转换为最终的类型结构。</li>
</ol>
<p>这里我们先按照论文的顺序，先分析SimpleSub论文第4.3章里面提到的简化算法。CompactType和Canonicalize放到后面再介绍。</p>
<p><strong>背景</strong>：首先回忆一下，类型变量是干什么用的。类型变量通常给<strong>多态</strong>函数使用，对应的是数据流边。如果就是普通的类型的话，是不会有类型变量的。</p>
<ul>
<li>不是多态的函数，参数和返回值类型都是确定的，即使函数接受一个复杂的结构体类型，返回另外一个复杂的结构体类型，里面也不会出现变量。</li>
<li>多态函数的典型例子，比如id函数 <span class="math inline">\(\lambda
x.x\)</span>
，把参数原样返回，如果传入一个整数，返回的是整数类型，传入的是字符串，返回的是字符串类型。那么我们就不能简单给参数和返回值标记成具体的类型，标记为
<span class="math inline">\(int \rightarrow int\)</span> 或者 <span
class="math inline">\(str \rightarrow str\)</span>
都是错的。因此，我们引入类型变量 <span
class="math inline">\(\alpha\)</span> 表示参数x的类型，将它的类型标记为
<span class="math inline">\(\alpha \rightarrow \alpha\)</span>
。表示，假如参数给定的类型是 <span class="math inline">\(\alpha\)</span>
时，返回值的类型也是 <span class="math inline">\(\alpha\)</span> 。</li>
<li>类型推理的最后，类型变量表示的纯粹的未知类型，不会有约束，因为约束会通过替换操作表示到外面。
<ul>
<li>比如说同样是id函数 <span class="math inline">\(\lambda x.x\)</span>
，但是我在函数体里面访问了一下成员field1并当做int类型使用，但是最后还是返回x。此时，在类型推理时会生成约束
<span class="math inline">\(\alpha \leq \{f1: int\}\)</span> （其中
<span class="math inline">\(\alpha\)</span>
表示x的类型），它通过约束x是某个有f1成员的结构体类型，来约束x必须有这个成员。</li>
<li>既然说，<span class="math inline">\(\alpha\)</span>
表示x的类型了，那么，既然函数还是返回x，那么整个函数的类型依然还是 <span
class="math inline">\(\alpha \rightarrow \alpha\)</span>
？这个说法是错误的。因为类型推理解决这个约束的时候会产生一个替换， <span
class="math inline">\(\alpha^- \rightarrow \alpha^- \sqcap \{f1:
int\}\)</span> 最终推理出来的类型是 <span class="math inline">\(\alpha
\sqcap \{f1: int\} \rightarrow
\alpha\)</span>。这代表什么含义呢？这意味着<strong>类型变量如果有约束，总是会通过交类型或者并类型把约束单独表示，从而抽出身来变成没有约束的纯粹变量</strong>
（参考MLsub论文《Algebraic
Subtyping》的5.2.3节后半部分，这里涉及了一个细节，即类型使用产生的上界约束仅影响变量的负极性（上界）的使用点）</li>
</ul></li>
</ul>
<p><strong>简化1：去除极性变量</strong>
因为变量仅仅在正极性，或者负极性出现，则我们可以删掉它。因为变量表示的就只是参数到返回值之间的多态类型关系。这种仅在一个方面出现的变量无法表示数据流，因此可以去掉。比如对于类型
<span class="math inline">\(\alpha \sqcap \text{int} \rightarrow
\text{int} \sqcup \beta\)</span> ，直接简化成 <span
class="math inline">\(\text{int} \rightarrow \text{int}\)</span> 。</p>
<p><strong>简化2：共现分析</strong>：如果两个变量总是在相同极性位置同时出现，则我们可以将它们合并。这里同时出现的意思是，把类型中，用
<span class="math inline">\(\sqcap\)</span> 或 <span
class="math inline">\(\sqcup\)</span>
连接的部分看作一个槽位，里面可以同时存在被连接的多个变量。然后依次看正极性的所有槽位，和负极性的所有槽位，如果两个变量总是同时出现在某个槽位，则说明可以合并。</p>
<p>从最简单的角度理解，既然变量就已经抽身成单独的纯粹变量，那么多个变量其实就没有意义了。例如，比如说对于id函数
<span class="math inline">\(\lambda x.x\)</span> 它的类型是 <span
class="math inline">\(\alpha \rightarrow \alpha\)</span> 。
如果类型推理给出类型是 <span class="math inline">\(\alpha \sqcap \beta
\rightarrow \alpha \sqcup \beta\)</span>
这也是对的，可以化简成前面的类型。</p>
<p>但是，这里有一个坑点，<strong>两个极性下，任意一个极性下共现即可进行合并，即使另外一个极性不共现</strong>。例如，我们看论文里3.4章结尾提到的twice函数
twice = <span class="math inline">\(\lambda f. \lambda x. f(f
x)\)</span> 。初步得到的类型是 <span class="math inline">\(\alpha \sqcap
(\beta \sqcup \gamma \rightarrow \gamma \sqcap \delta) \rightarrow \beta
\rightarrow \delta\)</span>
接下来需要化简它。首先根据“简化1”去除只出现一次的 <span
class="math inline">\(\alpha\)</span>
变量，都只出现一次肯定只在一个极性出现。得到 <span
class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma \sqcap
\delta) \rightarrow \beta \rightarrow \delta\)</span>
。它是一个函数类型，第一个参数也是函数类型 <span
class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma \sqcap
\delta)\)</span> 第二个参数是 <span class="math inline">\(\beta\)</span>
返回值类型是 <span class="math inline">\(\delta\)</span> 。</p>
<p>首先我们需要区分极性。参数是负极性的，但是如果负极性的参数位置内部又是函数类型，里面的极性又要反过来。我们通过下划线标注负极性的位置，如下：
<span class="math inline">\((\beta \sqcup \gamma \rightarrow
\underline{\gamma \sqcap \delta}) \rightarrow \underline{\beta}
\rightarrow \delta\)</span> 。然后，我们不用区分 <span
class="math inline">\(\sqcap\)</span> 和 <span
class="math inline">\(\sqcup\)</span>
两个运算了，可以当做简单的集合连接符。比如表示成 <span
class="math inline">\((\{\beta, \gamma\} \rightarrow
\underline{\{\gamma, \delta\}}) \rightarrow \underline{\beta}
\rightarrow \delta\)</span>
总之就是四个槽位，然后每个位置可以有多个变量。</p>
<p><strong>标准解法</strong>：我们每次只看一个极性，看带下划线的负极性，此时，
<span class="math inline">\(\beta\)</span> 单独出现， <span
class="math inline">\(\gamma\)</span> 和 <span
class="math inline">\(\delta\)</span> 一起出现。因此 <span
class="math inline">\(\gamma\)</span> 和 <span
class="math inline">\(\delta\)</span> 可以合并。比如我们都合并成 <span
class="math inline">\(\gamma\)</span> ，把所有的 <span
class="math inline">\(\delta\)</span> 替换成 <span
class="math inline">\(\gamma\)</span> 即可。得到 <span
class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma)
\rightarrow \beta \rightarrow \gamma\)</span>。</p>
<p>论文的原文如下，和论文一样：</p>
<blockquote>
<p>this type can be compacted to α ⊓ (β ⊔ γ → γ ⊓ δ) → β → δ, and then
simplified to (β ⊔ γ → γ) → β → γ, since α occurs only negatively (thus
can be removed) and δ and γ co-occur negatively (thus can be merged into
a single variable).</p>
</blockquote>
<p>我们再看能不能进一步化简，这里 <span class="math inline">\((\beta
\sqcup \gamma \rightarrow \underline{\gamma}) \rightarrow
\underline{\beta} \rightarrow \gamma\)</span>
看带下划线的负极性，两个变量单独出现，因此不能化简。看正极性，虽然 <span
class="math inline">\(\beta \sqcup \gamma\)</span>
这里两个变量同时出现，但是 <span class="math inline">\(\gamma\)</span>
也会单独出现，所以不算是一直同时出现。</p>
<p><strong>标准解法2</strong>：如果我们先看正极性，可以发现其实也可以把
<span class="math inline">\(\beta\)</span> 和 <span
class="math inline">\(\gamma\)</span> 合并，此时得到的类型是： <span
class="math inline">\((\beta \rightarrow \beta \sqcap \delta)
\rightarrow \beta \rightarrow \delta\)</span>
这个简化方式也是正确的。</p>
<p><strong>共现分析：基于数据流的深入理解</strong></p>
<p>从数据流的角度，回忆MLsub论文，变量的本质就是连接数据流，只要数据流的边一致，类型就是一致的。如果某个变量在负极性槽位出现，然后又在正极性槽位出现，则我们认为存在一个从负极性槽位到正极性槽位的数据流。</p>
<p>比如，对于 <span class="math inline">\((\{\beta, \gamma\} \rightarrow
\underline{\{\gamma, \delta\}}) \rightarrow \underline{\beta}
\rightarrow \delta\)</span>
这里四个槽位标记为1到4，我们观察，对于下划线位置的变量，还在什么没有下划线的位置出现，得到下面的数据流</p>
<ol type="1">
<li>槽位2 -&gt; 槽位1 ( <span class="math inline">\(\gamma\)</span>
)</li>
<li>槽位2 -&gt; 槽位4 ( <span class="math inline">\(\gamma\)</span>
)</li>
<li>槽位3 -&gt; 槽位1 ( <span class="math inline">\(\beta\)</span>
)</li>
</ol>
<p>用同样的方式，给简化后的两种类型连接起来看看，得到下面的图：</p>
<p><img src="ML数据流示例.drawio.png" /></p>
<p>可以看到数据流完全一样！所以确实类型是一样的。</p>
<p>TODO 从数据流的角度，再次理解上面的简化。</p>
<p><strong>基于子类型定义的证明</strong></p>
<p>我们尝试基于定义，证明两个解法的类型是一致的。即尝试证明 <span
class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma)
\rightarrow \beta \rightarrow \gamma\)</span> 等价于 <span
class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma \sqcap
\delta) \rightarrow \beta \rightarrow \delta\)</span>
。我们通过证明两个类型互为对方的子类型，来证明类型等价。</p>
<p>首先回忆子类型的定义。MLsub中子类型的定义的，如果存在一个类型替换，使得类型A的变量在替换后，变成了类型B的子类型，则说明A是B的子类型。</p>
<ul>
<li>替换可以是变量替换为具体类型，比如说，类型 <span
class="math inline">\(\alpha \sqcap \text{int} \rightarrow \text{int}
\sqcup \alpha\)</span> 中，我们可以替换 <span
class="math inline">\(\alpha \rightarrow \text{int}\)</span> 得到 <span
class="math inline">\(\text{int} \sqcap \text{int} \rightarrow
\text{int} \sqcup \text{int}\)</span> 等价于 <span
class="math inline">\(\text{int} \rightarrow \text{int}\)</span>
。因此前者是后者的子类型。
<ul>
<li>注意到子类型关系也不仅仅局限于不带变量的具体类型，带变量的多态类型之间也可能存在子类型关系。即，无论变量怎么替换成具体类型，最终的实例之间依然保留子类型关系。</li>
</ul></li>
<li><strong>替换也可以是变量替换为变量！或者其他新的带新变量的类型表达式</strong>。比如我们尝试证明类型
<span class="math inline">\(\alpha \rightarrow \alpha \rightarrow
\alpha\)</span> 等价于 <span class="math inline">\(\alpha \rightarrow
\beta \rightarrow \alpha \sqcup \beta\)</span>
（参考MLsub论文《Algebraic Subtyping》4.2.1节）
<ul>
<li>对于后者，我们使用替换 <span class="math inline">\(\beta \rightarrow
\alpha\)</span> 得到前者，这很简单</li>
<li>对于前者，我们使用替换 <span class="math inline">\(\alpha
\rightarrow \beta \sqcup \gamma\)</span> 得到 <span
class="math inline">\(\beta \sqcup \gamma \rightarrow \beta \sqcup
\gamma \rightarrow \beta \sqcup \gamma\)</span> 而它 <span
class="math inline">\(\leq \gamma \rightarrow \beta \rightarrow \beta
\sqcup \gamma\)</span> 然后我们再把 <span
class="math inline">\(\gamma\)</span> 重命名为 <span
class="math inline">\(\alpha\)</span> 就得到后者了。</li>
</ul></li>
</ul>
<p>证明分两步：</p>
<ul>
<li>找一个替换，让 <span class="math inline">\((\beta \sqcup \gamma
\rightarrow \gamma \sqcap \delta) \rightarrow \beta \rightarrow
\delta\)</span> 变成 <span class="math inline">\((\beta \sqcup \gamma
\rightarrow \gamma) \rightarrow \beta \rightarrow \gamma\)</span>
<ul>
<li>TODO 好像有点难</li>
</ul></li>
<li>找一个替换，让 <span class="math inline">\((\beta \sqcup \gamma
\rightarrow \gamma) \rightarrow \beta \rightarrow \gamma\)</span> 变成
<span class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma
\sqcap \delta) \rightarrow \beta \rightarrow \delta\)</span>
<ul>
<li>TODO 好像有点难</li>
</ul></li>
</ul>
<p>同理，也可以证明 <span class="math inline">\((\beta \rightarrow \beta
\sqcap \delta) \rightarrow \beta \rightarrow \delta\)</span> 也等价于
<span class="math inline">\((\beta \sqcup \gamma \rightarrow \gamma
\sqcap \delta) \rightarrow \beta \rightarrow \delta\)</span></p>
<p><strong>和常量的共现</strong>：比如，变量 <span
class="math inline">\(\alpha\)</span> 和 int
总是在负极性同时出现，同时也和int总是在正极性同时出现，则将这个变量替换为int类型。</p>
<p>因为，变量 <span class="math inline">\(\alpha\)</span> 和 int
总是在负极性同时出现，则其实对应的是，之前存在约束 <span
class="math inline">\(\alpha \leq \text{int}\)</span>
。同理，总是在正极性对应的是 <span class="math inline">\(\text{int} \leq
\alpha\)</span> 两个合起来，不就说明 <span
class="math inline">\(\alpha\)</span> 等价于int类型了。</p>
<p><strong>简化方法3：哈希合并（Hash
Consing）</strong>：这个方法是SimpleSub特有的，MLsub没有进行这一步。这个涉及递归类型。</p>
<p>原文如下：</p>
<blockquote>
<p>考虑以下递归项：</p>
<p><span class="math display">\[ \text{let } f = \lambda x. \{ L = x ; R
= f x \} \text{ in } f \]</span></p>
<p>为这个项推断出的合并类型将是：</p>
<p><span class="math display">\[ \alpha \rightarrow \{ L : \alpha; R :
\mu\beta. \{ L : \alpha; R : \beta \} \} \]</span></p>
<p>注意，这里有一个冗余的外部结构体层。我们希望推断出：</p>
<p><span class="math display">\[ \alpha \rightarrow \mu\beta. \{ L :
\alpha; R : \beta \} \]</span></p>
<p>这可以通过在 <code>coalesceType</code>
函数中对正在合并的类型执行哈希合并来完成：我们可以记住正在合并的整个类型表达式，而不仅仅是哪个
<em>变量</em>
正在被合并；当我们遇到一个已经在合并中的类型表达式时，我们会在这个位置引入一个递归类型变量，从而去除像上述那样冗余的外层类型。MLsub
当前并不执行类似的简化，因此在像上述示例中，Simple-sub
推导出更简单的类型。</p>
</blockquote>
<p>简单来说，就是在遇到递归类型的时候，可以多向外匹配一层，消除一层冗余。</p>
<p>首先我们复习递归类型：比如说有类型 <span
class="math inline">\(\mu\beta. \{ L : \alpha; R : \beta \}\)</span>
这里的 <span class="math inline">\(\mu\)</span> 是不动点算子。其中 <span
class="math inline">\(\beta\)</span> 等于这个类型，同时 <span
class="math inline">\(\{ L : \alpha; R : \beta \}\)</span>
也等于这个类型。总之我们得到等价关系 <span class="math inline">\(\beta =
\{ L : \alpha; R : \beta \}\)</span> 这意味着我们可以不断展开：</p>
<ul>
<li><span class="math inline">\(\beta\)</span></li>
<li><span class="math inline">\(\{ L : \alpha; R : \beta
\}\)</span></li>
<li><span class="math inline">\(\{ L : \alpha; R : \{ L : \alpha; R :
\beta \} \}\)</span></li>
<li><span class="math inline">\(\{ L : \alpha; R : \{ L : \alpha; R : \{
L : \alpha; R : \beta \} \} \}\)</span></li>
<li>......</li>
</ul>
<p>总之 <span class="math inline">\(\mu\)</span>
就是表示这种递归类型。例如我们常用的链表结构体，内部有指向自己的指针。</p>
<p>经过前面的简化之后，有下面的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;o → &#123;self: &#x27;q; thing: &#x27;o&#125;)</span><br><span class="line">其中&#x27;q是递归类型：</span><br><span class="line">  &#x27;q = &#123;self: &#x27;q; thing: &#x27;o&#125;</span><br></pre></td></tr></table></figure>
<p>匹配的时候不仅会匹配变量，对于递归类型也会匹配相同的递归结构。即维护一个从CompactType到变量的映射。（对应代码中coalesceCompactType函数）比如对于上面的类型，我们进行递归访问。首先访问整体的函数类型，然后访问函数的参数类型（即<code>'o</code>），然后访问函数体了，放入map中<code>&#123;self: 'q; thing: 'o&#125;</code>。然后我们递归访问成员，访问self成员，访问到<code>'q</code>的时候，我们发现它是递归变量，因此我们访问它等价的递归类型。此时我们发现，又访问到了<code>&#123;self: 'q; thing: 'o&#125;</code>，和前面的一致！因此我们为它创建一个专门的递归变量，比如<code>μ0</code>。然后返回作为</p>
<h3 id="类型优化的具体细节">类型优化的具体细节</h3>
<p>具体到代码的话，其实还有一些论文中没有写出来的细节。
这里介绍CompactType和Canonicalize，即在优化之前的平坦化和规范化操作。</p>
<p><strong>类型平坦化：CompactType</strong>：当我们遇到类型：<code>&#123;x: A&#125; ∧ &#123;x: B; y: C&#125;</code>的时候，我们可以进一步合并结构体类型，变成
<code>&#123;x: A ∧ B; y: C&#125;</code>。它会让后续的共现分析更准确</p>
<p>下面是CompactType的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intermediate representation for simplification (Section 4.4)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompactType</span> &#123;</span><br><span class="line">  std::set&lt;SimpleType&gt; vars;                          <span class="comment">// type variables</span></span><br><span class="line">  std::set&lt;SimpleType, SimpleTypeValueCompare&gt; prims; <span class="comment">// primitive types</span></span><br><span class="line">  std::optional&lt;std::map&lt;std::string, std::shared_ptr&lt;CompactType&gt;&gt;&gt;</span><br><span class="line">      record; <span class="comment">// record fields</span></span><br><span class="line">  std::optional&lt;std::pair&lt;std::vector&lt;std::shared_ptr&lt;CompactType&gt;&gt;, std::shared_ptr&lt;CompactType&gt;&gt;&gt;</span><br><span class="line">      function; <span class="comment">// function type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>CompactType本身可以看作一个很大的集合，里面归类放置了各种类型。我们回忆之前，SimpleType核心类型推理结构，它其实并不是我们常见的基于语法树的类型，而是有上下界指向其他类型。如果我们单看变量类型的一个界，比如上界，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VariableState</span> &#123;</span><br><span class="line">  std::vector&lt;SimpleType&gt; lowerBounds;</span><br><span class="line">  std::vector&lt;SimpleType&gt; upperBounds; <span class="comment">// CompactType即分类整理数组里的类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实含义是，所有上界指向的类型，全部用类型交运算连接起来。那么就是把这个上界数组里的类型，分类整理了起来。保存成上面那种集合的样子。根据所处位置的极性，表示类型交运算或者并运算。</p>
<p>同理，因为我们会展开结构体和函数类型，比如<code>&#123;x: A&#125; ∧ &#123;x: B; y: C&#125;</code>展开成<code>&#123;x: A ∧ B; y: C&#125;</code>，所以这里对于结构体类型，并不是也保存成集合，而是保存为单独的CompactType，因为即使有很多结构体，也会合并起来变成一个，然后在结构体内部再用类型交运算或者并运算。</p>
<p>这样转换为Compact类型的过程也非常直接。
<!-- TODO 贴代码展示？ --></p>
<p><strong>类型规范化：Canonicalize</strong>：</p>
<h2 id="faq">FAQ</h2>
<p><strong>Q1:</strong>
比如我有一个函数，原始参数类型就是Animal。传递参数的两个时候是分别传入了Dog，传入了Cat。那么我是不是有
<code>func_in &lt;= Dog</code> 和
<code>func_in &lt;= cat</code>。那么为什么求交类型运算 <code>^</code>
只出现在负极性处，而不是并运算？（Dog 并 Cat = Animal，Dog 交 Cat =
Bottom）</p>
<p>Answer 1:</p>
<ul>
<li>参数类型之所以是 animal，是因为后面当 animal
用，而不是因为传进来什么，不用的话，甚至可以当 top。</li>
<li>参数是负极性，所以是看使用。如果后面返回了参数这个值，返回值就会因为数据流把这两个约束拿过来。</li>
</ul>
<p>MLsub
原文处理约束就是，把负极性到正极性的约束连成数据流，正极性到负极性的约束才看作约束。约束可以随便生成，但是求类型的时候，负极性顺着数据流收集，正极性逆着数据流收集，不管另外一个方向。另外一个方向，因为连了数据流，数据流是负极性到正极性的，会传给另一头。总结：负极性
顺着数据流收集上界。正极性逆着数据流收集下界。</p>
<p><strong>Q2: 类型的交和并怎么理解来着？</strong></p>
<p>Answer 2:
实际程序执行的时候都是具体的值，而类型对应的是所有可能的值的集合。比如说程序执行的时候都是具体的数字，而我们用int类型表示所有int类型能存的有具体数字的集合。然后子类型相比父类型更精确，即集合范围更小。比如我们根据上面的<code>Animal，Dog, Cat</code>创建类型：</p>
<ul>
<li>Top类型，它包含所有可能的值，甚至包括冲突的值，比如结构体类型，和整数，和浮点数。它的集合最大，是所有类型的父类型。</li>
<li>Animal类型，它表示所有动物的集合</li>
<li>Dog类型, Cat类型，它表示所有具体的猫和狗的集合。</li>
<li>Bottom类型，对应空集合，没有任何具体值的类型，通常不会出现。</li>
</ul>
<p>可以观察到：</p>
<ul>
<li>集合之间的子集关系，就是子类型关系。比如<code>Dot &lt;= Animal</code>，即Dog是Animal的子类型，对应Dog是Animal的子集</li>
<li>集合越小，越靠近子类型。</li>
<li>类型的并（Join, v），即求最小公共上界，会往父类型走。</li>
<li>类型的交（Meet, v），即最大公共下节，会往子类型走。</li>
</ul>
<p>但是要注意：</p>
<ul>
<li>类型的并集 对应 结构体成员的交集</li>
<li>类型的交集 对应 结构体成员的并集</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjk.moe/2025/%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%8E%A8%E7%90%86SimpleSub%E5%92%8CMLsub/" data-id="cmks49mcm00584gue21of86nj" data-title="多态类型推理SimpleSub和MLsub" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PL/" rel="tag">PL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/StaticAnalysis/" rel="tag">StaticAnalysis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8A%95%E8%B5%84%E4%B8%AD%E7%9A%84%E5%87%AF%E5%88%A9%E5%85%AC%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          深入理解投资中的凯利公式
        
      </div>
    </a>
  
  
    <a href="/2025/SVF-LLVM%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">SVF-LLVM指针分析框架</div>
    </a>
  
</nav>

  
</article>

<!-- 2024年1月11日 giscus -->

  <section id="comments" class="vcomment">
    <script src="https://giscus.app/client.js"
      data-repo="am009/am009.github.io"
      data-repo-id="MDEwOlJlcG9zaXRvcnkxOTI3MTU2MzI="
      data-category="Comments"
      data-category-id="DIC_kwDOC3ybcM4CcWIQ"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="light"
      data-lang="zh-CN"
      data-loading="lazy"
      crossorigin="anonymous"
      async>
    </script>
  </section>



</section>
        
      </div>
      <footer id="footer">
  
    <aside id="sidebar" class="outer">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Digi/">Digi</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hack/">Hack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Project/">Project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Read/">Read</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Compiler/" rel="tag">Compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Decompile/" rel="tag">Decompile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/" rel="tag">English</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzz/" rel="tag">Fuzz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Investing/" rel="tag">Investing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM/" rel="tag">LLVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Learning/" rel="tag">Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Networking/" rel="tag">Networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Openwrt/" rel="tag">Openwrt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PL/" rel="tag">PL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/" rel="tag">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Read/" rel="tag">Read</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scientific/" rel="tag">Scientific</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/StaticAnalysis/" rel="tag">StaticAnalysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebAssembly/" rel="tag">WebAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rcore/" rel="tag">rcore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 12.5px;">AI</a> <a href="/tags/CTF/" style="font-size: 17.5px;">CTF</a> <a href="/tags/Compiler/" style="font-size: 16.25px;">Compiler</a> <a href="/tags/Decompile/" style="font-size: 18.75px;">Decompile</a> <a href="/tags/Embedded/" style="font-size: 12.5px;">Embedded</a> <a href="/tags/English/" style="font-size: 10px;">English</a> <a href="/tags/Fuzz/" style="font-size: 17.5px;">Fuzz</a> <a href="/tags/Investing/" style="font-size: 12.5px;">Investing</a> <a href="/tags/Java/" style="font-size: 11.25px;">Java</a> <a href="/tags/LLVM/" style="font-size: 11.25px;">LLVM</a> <a href="/tags/Learning/" style="font-size: 13.75px;">Learning</a> <a href="/tags/Linux/" style="font-size: 11.25px;">Linux</a> <a href="/tags/Networking/" style="font-size: 15px;">Networking</a> <a href="/tags/OS/" style="font-size: 12.5px;">OS</a> <a href="/tags/Openwrt/" style="font-size: 10px;">Openwrt</a> <a href="/tags/PL/" style="font-size: 20px;">PL</a> <a href="/tags/Raspberrypi/" style="font-size: 10px;">Raspberrypi</a> <a href="/tags/Read/" style="font-size: 11.25px;">Read</a> <a href="/tags/Scientific/" style="font-size: 12.5px;">Scientific</a> <a href="/tags/StaticAnalysis/" style="font-size: 18.75px;">StaticAnalysis</a> <a href="/tags/WebAssembly/" style="font-size: 10px;">WebAssembly</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/rcore/" style="font-size: 10px;">rcore</a> <a href="/tags/ucore/" style="font-size: 10px;">ucore</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">November 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
</aside>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 am009@github.com<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>